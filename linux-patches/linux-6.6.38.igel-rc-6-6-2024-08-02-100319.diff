diff -Naurp a/linux-6.6.38.igel/arch/x86/kernel/acpi/boot.c b/linux-6.6.38.igel/arch/x86/kernel/acpi/boot.c
--- a/linux-6.6.38.igel/arch/x86/kernel/acpi/boot.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/arch/x86/kernel/acpi/boot.c	2024-08-02 15:41:31.531491012 +0200
@@ -22,6 +22,9 @@
 #include <linux/efi-bgrt.h>
 #include <linux/serial_core.h>
 #include <linux/pgtable.h>
+#ifdef CONFIG_IGEL_SURFACE_IRQ7_QUIRK
+#include <linux/dmi.h>
+#endif
 
 #include <asm/e820/api.h>
 #include <asm/irqdomain.h>
@@ -1255,6 +1258,26 @@ static void __init mp_config_acpi_legacy
 	}
 }
 
+#ifdef CONFIG_IGEL_SURFACE_IRQ7_QUIRK
+static const struct dmi_system_id surface_quirk[] __initconst = {
+	{
+		.ident = "Microsoft Surface Laptop 4 (AMD 15\")",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "Surface_Laptop_4_1952:1953")
+		},
+	},
+	{
+		.ident = "Microsoft Surface Laptop 4 (AMD 13\")",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
+			DMI_MATCH(DMI_PRODUCT_SKU, "Surface_Laptop_4_1958:1959")
+		},
+	},
+	{}
+};
+#endif
+
 /*
  * Parse IOAPIC related entries in MADT
  * returns 0 on success, < 0 on error
@@ -1310,6 +1333,13 @@ static int __init acpi_parse_madt_ioapic
 		acpi_sci_ioapic_setup(acpi_gbl_FADT.sci_interrupt, 0, 0,
 				      acpi_gbl_FADT.sci_interrupt);
 
+#ifdef CONFIG_IGEL_SURFACE_IRQ7_QUIRK
+	if (dmi_check_system(surface_quirk)) {
+		pr_warn("Surface hack: Override irq 7\n");
+		mp_override_legacy_irq(7, 3, 3, 7);
+	}
+#endif
+
 	/* Fill in identity legacy mappings where no override */
 	mp_config_acpi_legacy_irqs();
 
diff -Naurp a/linux-6.6.38.igel/crypto/asymmetric_keys/signature.c b/linux-6.6.38.igel/crypto/asymmetric_keys/signature.c
--- a/linux-6.6.38.igel/crypto/asymmetric_keys/signature.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/crypto/asymmetric_keys/signature.c	2024-08-02 15:41:31.535491108 +0200
@@ -127,6 +127,83 @@ int create_signature(struct kernel_pkey_
 }
 EXPORT_SYMBOL_GPL(create_signature);
 
+#ifdef CONFIG_IGEL_VERIFY_SIGNATURE_AGAINST_KEYRING
+struct igel_signature_iter {
+	const struct public_key_signature *pks;
+	uint32_t serial;
+};
+
+/**
+ * Iterator callback for signature verification. It's called with a pointer
+ * to the initialized struct public_key_signature and an asymmetric key to
+ * use for the verification.
+ *
+ * In case of a successfull signature verification, it returns 1.
+ *
+ * NOTE: The pointers used in associative arrays as well as those used by the
+ *       keyrings use the second-least significant bit to store additional
+ *       information. Unfortunately, keyring_ptr_to_key() is static in
+ *       keyring.c so we have to strip the bit ourselves.
+ */
+static int verify_signature_iter(const void *obj, void *parms)
+{
+	const struct key *key = (const struct key *) ((unsigned long) obj & ~2UL);
+	struct igel_signature_iter *igel_iter = parms;
+	const struct public_key_signature *pks = igel_iter->pks;
+
+
+	if (key->type == &key_type_asymmetric) {
+		printk(KERN_INFO "key = %p, description = %s, perm = 0x%x\n", key, key->description, key->perm);
+		if (verify_signature_igel(key, pks, NULL) == 0) {
+			igel_iter->serial = key->serial;
+			return 1;
+		}
+	}
+
+	return 0;
+}
+/**
+ * verify_signature_igel - Initiate the use of an asymmetric key to verify a signature
+ * @key: The asymmetric key to verify against
+ * @sig: The signature to check
+ * @serial: key serial of found asymmetric key
+ *
+ * Returns 0 if successful or else an error.
+ */
+int verify_signature_igel(const struct key *key,
+			  const struct public_key_signature *sig,
+			  uint32_t *serial)
+{
+	int ret;
+	struct igel_signature_iter igel_iter;
+
+	if (serial)
+		*serial = 0;
+	igel_iter.pks = sig;
+	igel_iter.serial = 0;
+
+	pr_devel("==>%s()\n", __func__);
+
+	if (key->type == &key_type_keyring) {
+		rcu_read_lock();
+		ret = assoc_array_iterate(&key->keys, verify_signature_iter, (void *)&igel_iter);
+		rcu_read_unlock();
+		if (ret == 0) {
+			return -ENOKEY;
+		} else {
+			if (serial)
+				*serial = igel_iter.serial;
+			return 0;
+		}
+	} else {
+		return verify_signature(key, sig);
+	}
+
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(verify_signature_igel);
+#endif
+
 /**
  * verify_signature - Initiate the use of an asymmetric key to verify a signature
  * @key: The asymmetric key to verify against
diff -Naurp a/linux-6.6.38.igel/Documentation/admin-guide/laptops/thinkpad-acpi.rst b/linux-6.6.38.igel/Documentation/admin-guide/laptops/thinkpad-acpi.rst
--- a/linux-6.6.38.igel/Documentation/admin-guide/laptops/thinkpad-acpi.rst	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Documentation/admin-guide/laptops/thinkpad-acpi.rst	2024-08-02 15:41:31.527490917 +0200
@@ -53,6 +53,7 @@ detailed description):
 	- Lap mode sensor
 	- Setting keyboard language
 	- WWAN Antenna type
+	- Auxmac
 
 A compatibility table by model and feature is maintained on the web
 site, http://ibm-acpi.sf.net/. I appreciate any success or failure
@@ -1511,6 +1512,25 @@ Currently 2 antenna types are supported
 The property is read-only. If the platform doesn't have support the sysfs
 class is not created.
 
+Auxmac
+------
+
+sysfs: auxmac
+
+Some newer Thinkpads have a feature called MAC Address Pass-through. This
+feature is implemented by the system firmware to provide a system unique MAC,
+that can override a dock or USB ethernet dongle MAC, when connected to a
+network. This property enables user-space to easily determine the MAC address
+if the feature is enabled.
+
+The values of this auxiliary MAC are:
+
+        cat /sys/devices/platform/thinkpad_acpi/auxmac
+
+If the feature is disabled, the value will be 'disabled'.
+
+This property is read-only.
+
 Adaptive keyboard
 -----------------
 
diff -Naurp a/linux-6.6.38.igel/Documentation/leds/well-known-leds.txt b/linux-6.6.38.igel/Documentation/leds/well-known-leds.txt
--- a/linux-6.6.38.igel/Documentation/leds/well-known-leds.txt	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Documentation/leds/well-known-leds.txt	2024-08-02 15:41:31.527490917 +0200
@@ -44,6 +44,14 @@ Legacy: "lp5523:kb{1,2,3,4,5,6}" (Nokia
 
 Frontlight/backlight of main keyboard.
 
+Good: ":*:kbd_backlight"
+Good: "input*:*:kbd_backlight"
+Legacy: "*:*:kbd_backlight"
+
+Many drivers have the vendor or product name as the first field of the led name,
+this makes names inconsistent and is redundant as that information is already in
+sysfs.
+
 Legacy: "button-backlight" (Motorola Droid 4)
 
 Some phones have touch buttons below screen; it is different from main
diff -Naurp a/linux-6.6.38.igel/Documentation/security/lsm.rst b/linux-6.6.38.igel/Documentation/security/lsm.rst
--- a/linux-6.6.38.igel/Documentation/security/lsm.rst	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Documentation/security/lsm.rst	2024-08-02 15:41:31.527490917 +0200
@@ -129,3 +129,31 @@ to identify it as the first security mod
 The capabilities security module does not use the general security
 blobs, unlike other modules. The reasons are historical and are
 based on overhead, complexity and performance concerns.
+
+LSM External Interfaces
+=======================
+
+The LSM infrastructure does not generally provide external interfaces.
+The individual security modules provide what external interfaces they
+require.
+
+The file ``/sys/kernel/security/lsm`` provides a comma
+separated list of the active security modules.
+
+The file ``/proc/pid/attr/display`` contains the name of the security
+module for which the ``/proc/pid/attr/current`` interface will
+apply. This interface can be written to.
+
+The infrastructure does provide an interface for the special
+case where multiple security modules provide a process context.
+This is provided in compound context format.
+
+-  `lsm\0value\0lsm\0value\0`
+
+The `lsm` and `value` fields are nul terminated bytestrings.
+Each field may contain whitespace or non-printable characters.
+The nul bytes are included in the size of a compound context.
+The context ``Bell\0Secret\0Biba\0Loose\0`` has a size of 23.
+
+The file ``/proc/pid/attr/context`` provides the security
+context of the identified process.
diff -Naurp a/linux-6.6.38.igel/Documentation/userspace-api/media/mediactl/media-controller-model.rst b/linux-6.6.38.igel/Documentation/userspace-api/media/mediactl/media-controller-model.rst
--- a/linux-6.6.38.igel/Documentation/userspace-api/media/mediactl/media-controller-model.rst	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Documentation/userspace-api/media/mediactl/media-controller-model.rst	2024-08-02 15:41:31.527490917 +0200
@@ -38,4 +38,4 @@ are:
   entities form a single logical unit. For example this could represent the
   fact that a particular camera sensor and lens controller form a single
   physical module, meaning this lens controller drives the lens for this
-  camera sensor.
\ No newline at end of file
+  camera sensor.
diff -Naurp a/linux-6.6.38.igel/drivers/acpi/acpica/dswexec.c b/linux-6.6.38.igel/drivers/acpi/acpica/dswexec.c
--- a/linux-6.6.38.igel/drivers/acpi/acpica/dswexec.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/acpi/acpica/dswexec.c	2024-08-02 15:41:31.535491108 +0200
@@ -393,7 +393,11 @@ acpi_status acpi_ds_exec_end_op(struct a
 		 * take no arguments.
 		 */
 		if (!(walk_state->op_info->flags & AML_NO_OPERAND_RESOLVE) &&
+#ifdef CONFIG_IGEL_APPLE_ACPI
+			walk_state->num_operands > 0) {
+#else
 		    (walk_state->op_info->flags & AML_HAS_ARGS)) {
+#endif
 
 			/* Resolve all operands */
 
diff -Naurp a/linux-6.6.38.igel/drivers/acpi/acpi_tad.c b/linux-6.6.38.igel/drivers/acpi/acpi_tad.c
--- a/linux-6.6.38.igel/drivers/acpi/acpi_tad.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/acpi/acpi_tad.c	2024-08-02 15:41:31.535491108 +0200
@@ -432,6 +432,16 @@ static ssize_t caps_show(struct device *
 
 static DEVICE_ATTR_RO(caps);
 
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+static struct attribute *acpi_tad_attrs[] = {
+	&dev_attr_caps.attr,
+	NULL,
+};
+static const struct attribute_group acpi_tad_attr_group = {
+	.attrs	= acpi_tad_attrs,
+};
+#endif
+
 static ssize_t ac_alarm_store(struct device *dev, struct device_attribute *attr,
 			      const char *buf, size_t count)
 {
@@ -480,16 +490,26 @@ static ssize_t ac_status_show(struct dev
 
 static DEVICE_ATTR_RW(ac_status);
 
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+static struct attribute *acpi_tad_ac_attrs[] = {
+#else
 static struct attribute *acpi_tad_attrs[] = {
 	&dev_attr_caps.attr,
+#endif
 	&dev_attr_ac_alarm.attr,
 	&dev_attr_ac_policy.attr,
 	&dev_attr_ac_status.attr,
 	NULL,
 };
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+static const struct attribute_group acpi_tad_ac_attr_group = {
+	.attrs	= acpi_tad_ac_attrs,
+};
+#else
 static const struct attribute_group acpi_tad_attr_group = {
 	.attrs	= acpi_tad_attrs,
 };
+#endif
 
 static ssize_t dc_alarm_store(struct device *dev, struct device_attribute *attr,
 			      const char *buf, size_t count)
@@ -564,13 +584,25 @@ static int acpi_tad_remove(struct platfo
 
 	pm_runtime_get_sync(dev);
 
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+	if (dd->capabilities & ACPI_TAD_AC_WAKE)
+		sysfs_remove_group(&dev->kobj, &acpi_tad_ac_attr_group);
+#endif
+
 	if (dd->capabilities & ACPI_TAD_DC_WAKE)
 		sysfs_remove_group(&dev->kobj, &acpi_tad_dc_attr_group);
 
 	sysfs_remove_group(&dev->kobj, &acpi_tad_attr_group);
 
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+	if (dd->capabilities & ACPI_TAD_AC_WAKE) {
+		acpi_tad_disable_timer(dev, ACPI_TAD_AC_TIMER);
+		acpi_tad_clear_status(dev, ACPI_TAD_AC_TIMER);
+	}
+#else
 	acpi_tad_disable_timer(dev, ACPI_TAD_AC_TIMER);
 	acpi_tad_clear_status(dev, ACPI_TAD_AC_TIMER);
+#endif
 	if (dd->capabilities & ACPI_TAD_DC_WAKE) {
 		acpi_tad_disable_timer(dev, ACPI_TAD_DC_TIMER);
 		acpi_tad_clear_status(dev, ACPI_TAD_DC_TIMER);
@@ -613,11 +645,13 @@ static int acpi_tad_probe(struct platfor
 		goto remove_handler;
 	}
 
+#ifndef CONFIG_IGEL_SURFACE_ACPI_CHANGES
 	if (!acpi_has_method(handle, "_PRW")) {
 		dev_info(dev, "Missing _PRW\n");
 		ret = -ENODEV;
 		goto remove_handler;
 	}
+#endif
 
 	dd = devm_kzalloc(dev, sizeof(*dd), GFP_KERNEL);
 	if (!dd) {
@@ -649,6 +683,14 @@ static int acpi_tad_probe(struct platfor
 	if (ret)
 		goto fail;
 
+#ifdef CONFIG_IGEL_SURFACE_ACPI_CHANGES
+	if (caps & ACPI_TAD_AC_WAKE) {
+		ret = sysfs_create_group(&dev->kobj, &acpi_tad_ac_attr_group);
+		if (ret)
+			goto fail;
+	}
+#endif
+
 	if (caps & ACPI_TAD_DC_WAKE) {
 		ret = sysfs_create_group(&dev->kobj, &acpi_tad_dc_attr_group);
 		if (ret)
diff -Naurp a/linux-6.6.38.igel/drivers/acpi/battery.c b/linux-6.6.38.igel/drivers/acpi/battery.c
--- a/linux-6.6.38.igel/drivers/acpi/battery.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/acpi/battery.c	2024-08-02 15:41:31.535491108 +0200
@@ -54,6 +54,9 @@ static bool battery_driver_registered;
 static int battery_bix_broken_package;
 static int battery_notification_delay_ms;
 static int battery_ac_is_broken;
+#ifndef CONFIG_IGEL_REPLACE_UNKNOWN_BATTERY_STATE_WITH_NOT_CHARGING
+static int battery_quirk_notcharging;
+#endif
 static unsigned int cache_time = 1000;
 module_param(cache_time, uint, 0644);
 MODULE_PARM_DESC(cache_time, "cache time in milliseconds");
@@ -217,8 +220,15 @@ static int acpi_battery_get_property(str
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 		else if (acpi_battery_is_charged(battery))
 			val->intval = POWER_SUPPLY_STATUS_FULL;
+#ifndef CONFIG_IGEL_REPLACE_UNKNOWN_BATTERY_STATE_WITH_NOT_CHARGING
+		else if (battery_quirk_notcharging)
+			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_UNKNOWN;
+#else
 		else
 			val->intval = POWER_SUPPLY_STATUS_NOT_CHARGING;
+#endif
 		break;
 	case POWER_SUPPLY_PROP_PRESENT:
 		val->intval = acpi_battery_present(battery);
@@ -1117,6 +1127,14 @@ battery_ac_is_broken_quirk(const struct
 	return 0;
 }
 
+#ifndef CONFIG_IGEL_REPLACE_UNKNOWN_BATTERY_STATE_WITH_NOT_CHARGING
+static int __init battery_quirk_not_charging(const struct dmi_system_id *d)
+{
+	battery_quirk_notcharging = 1;
+	return 0;
+}
+#endif
+
 static const struct dmi_system_id bat_dmi_table[] __initconst = {
 	{
 		/* NEC LZ750/LS */
@@ -1145,6 +1163,21 @@ static const struct dmi_system_id bat_dm
 			DMI_MATCH(DMI_BIOS_DATE, "08/22/2014"),
 		},
 	},
+#ifndef CONFIG_IGEL_REPLACE_UNKNOWN_BATTERY_STATE_WITH_NOT_CHARGING
+	{
+		/*
+		 * On Lenovo ThinkPads the BIOS specification defines
+		 * a state when the bits for charging and discharging
+		 * are both set to 0. That state is "Not Charging".
+		 */
+		.callback = battery_quirk_not_charging,
+		.ident = "Lenovo ThinkPad",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "LENOVO"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "ThinkPad"),
+		},
+	},
+#endif
 	{
 		/* Microsoft Surface Go 3 */
 		.callback = battery_notification_delay_quirk,
diff -Naurp a/linux-6.6.38.igel/drivers/acpi/osi.c b/linux-6.6.38.igel/drivers/acpi/osi.c
--- a/linux-6.6.38.igel/drivers/acpi/osi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/acpi/osi.c	2024-08-02 15:41:31.535491108 +0200
@@ -44,6 +44,22 @@ osi_setup_entries[OSI_STRING_ENTRIES_MAX
 	{"Processor Device", true},
 	{"3.0 _SCP Extensions", true},
 	{"Processor Aggregator Device", true},
+#ifdef CONFIG_IGEL_HP_MT645_BIOS_S3
+	/*
+	 * Following is no longer supported since kernel 6.1:
+	 *
+	 * In the past _OSI strings have been abused by other BIOS vendors to change
+	 * completely unrelated code on completely unrelated systems.  This prompted
+	 * an evaluation of all of it's uses. This uncovered that they aren't needed
+	 * for any of the original reasons. As such, the kernel will not respond to
+	 * any custom Linux-* strings by default.
+	 *
+	 * Below defined _OSI string is used by hp mt645
+	 * System BIOS: U81 Ver.01.10.01 01/09/2023
+	 * for S3 (suspend to ram) functionality.
+	 */
+	{"Linux-HPI-Hybrid-Graphics", true},
+#endif
 };
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
diff -Naurp a/linux-6.6.38.igel/drivers/acpi/scan.c b/linux-6.6.38.igel/drivers/acpi/scan.c
--- a/linux-6.6.38.igel/drivers/acpi/scan.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/acpi/scan.c	2024-08-02 15:41:31.535491108 +0200
@@ -2110,6 +2110,11 @@ static acpi_status acpi_bus_check_add_2(
 
 static void acpi_default_enumeration(struct acpi_device *device)
 {
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	if (!acpi_dev_ready_for_enumeration(device))
+		return;
+#endif
+
 	/*
 	 * Do not enumerate devices with enumeration_by_parent flag set as
 	 * they will be enumerated by their respective parents.
diff -Naurp a/linux-6.6.38.igel/drivers/base/firmware_loader/fallback.c b/linux-6.6.38.igel/drivers/base/firmware_loader/fallback.c
--- a/linux-6.6.38.igel/drivers/base/firmware_loader/fallback.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/base/firmware_loader/fallback.c	2024-08-02 15:41:31.535491108 +0200
@@ -135,7 +135,13 @@ static int fw_load_from_user_helper(stru
 	if (opt_flags & FW_OPT_NOWAIT) {
 		timeout = usermodehelper_read_lock_wait(timeout);
 		if (!timeout) {
+#ifdef CONFIG_IGEL_MORE_VERBOSE_FIRMWARE_LOADING
+			/* gottwald@igel.com : Take patch from debian firmware_class-log-every-success-and-failure.patch
+			 * to improve the log messages for firmware loading */
+			dev_err(device, "firmware: %s loading timed out\n",
+#else
 			dev_dbg(device, "firmware: %s loading timed out\n",
+#endif
 				name);
 			return -EBUSY;
 		}
diff -Naurp a/linux-6.6.38.igel/drivers/base/firmware_loader/main.c b/linux-6.6.38.igel/drivers/base/firmware_loader/main.c
--- a/linux-6.6.38.igel/drivers/base/firmware_loader/main.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/base/firmware_loader/main.c	2024-08-02 15:41:31.535491108 +0200
@@ -551,8 +551,13 @@ fw_get_filesystem_firmware(struct device
 						       READING_FIRMWARE);
 		if (rc < 0) {
 			if (rc != -ENOENT)
+#ifdef CONFIG_IGEL_MORE_VERBOSE_FIRMWARE_LOADING
+				dev_dbg(device, "loading %s failed with error %d\n",
+					path, rc);
+#else
 				dev_warn(device, "loading %s failed with error %d\n",
 					 path, rc);
+#endif
 			else
 				dev_dbg(device, "loading %s failed for no such file or directory.\n",
 					 path);
@@ -563,8 +568,13 @@ fw_get_filesystem_firmware(struct device
 
 		dev_dbg(device, "Loading firmware from %s\n", path);
 		if (decompress) {
+#ifdef CONFIG_IGEL_MORE_VERBOSE_FIRMWARE_LOADING
+			dev_info(device, "firmware: f/w decompressing %s\n",
+				 fw_priv->fw_name);
+#else
 			dev_dbg(device, "f/w decompressing %s\n",
 				fw_priv->fw_name);
+#endif
 			rc = decompress(device, fw_priv, size, buffer);
 			/* discard the superfluous original content */
 			vfree(buffer);
@@ -574,8 +584,13 @@ fw_get_filesystem_firmware(struct device
 				continue;
 			}
 		} else {
+#ifdef CONFIG_IGEL_MORE_VERBOSE_FIRMWARE_LOADING
+			dev_info(device, "firmware: direct-loading %s\n",
+				 fw_priv->fw_name);
+#else
 			dev_dbg(device, "direct-loading %s\n",
 				fw_priv->fw_name);
+#endif
 			if (!fw_priv->data)
 				fw_priv->data = buffer;
 			fw_priv->size = size;
@@ -584,6 +599,14 @@ fw_get_filesystem_firmware(struct device
 		break;
 	}
 	__putname(path);
+#ifdef CONFIG_IGEL_MORE_VERBOSE_FIRMWARE_LOADING
+	if (rc == -ENOENT)
+		dev_err(device, "firmware: failed to load %s (no such file or directory)\n",
+			fw_priv->fw_name);
+	else if (rc)
+		dev_err(device, "firmware: failed to load %s (errorcode: %d)\n",
+			fw_priv->fw_name, rc);
+#endif
 
 	return rc;
 }
diff -Naurp a/linux-6.6.38.igel/drivers/bcma/host_pci.c b/linux-6.6.38.igel/drivers/bcma/host_pci.c
--- a/linux-6.6.38.igel/drivers/bcma/host_pci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/bcma/host_pci.c	2024-08-02 15:41:31.535491108 +0200
@@ -282,6 +282,8 @@ static SIMPLE_DEV_PM_OPS(bcma_pm_ops, bc
 
 static const struct pci_device_id bcma_pci_bridge_tbl[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x0576) },
+	 /* gottwald@igel.com The following devices could be handled by WL (broadcom_sta kernel driver) */
+#ifdef CONFIG_IGEL_BCMA_PREFER_BROADCOM_STA
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4313) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43224) },	/* 0xa8d8 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4331) },
@@ -301,6 +303,7 @@ static const struct pci_device_id bcma_p
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4727) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43227) },	/* 0xa8db, BCM43217 (sic!) */
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43228) },	/* 0xa8dc */
+#endif /* CONFIG_IGEL_BCMA_PREFER_BROADCOM_STA */
 	{ 0, },
 };
 MODULE_DEVICE_TABLE(pci, bcma_pci_bridge_tbl);
diff -Naurp a/linux-6.6.38.igel/drivers/bluetooth/btusb.c b/linux-6.6.38.igel/drivers/bluetooth/btusb.c
--- a/linux-6.6.38.igel/drivers/bluetooth/btusb.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/bluetooth/btusb.c	2024-08-02 15:41:31.535491108 +0200
@@ -65,6 +65,9 @@ static struct usb_driver btusb_driver;
 #define BTUSB_INTEL_BROKEN_INITIAL_NCMD BIT(25)
 #define BTUSB_INTEL_NO_WBS_SUPPORT	BIT(26)
 #define BTUSB_ACTIONS_SEMI		BIT(27)
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+#define BTUSB_LOWER_LESCAN_INTERVAL	BIT(28)
+#endif
 
 static const struct usb_device_id btusb_table[] = {
 	/* Generic Bluetooth USB device */
@@ -468,6 +471,9 @@ static const struct usb_device_id quirks
 	{ USB_DEVICE(0x1286, 0x2044), .driver_info = BTUSB_MARVELL },
 	{ USB_DEVICE(0x1286, 0x2046), .driver_info = BTUSB_MARVELL },
 	{ USB_DEVICE(0x1286, 0x204e), .driver_info = BTUSB_MARVELL },
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	{ USB_DEVICE(0x1286, 0x204c), .driver_info = BTUSB_LOWER_LESCAN_INTERVAL },
+#endif
 
 	/* Intel Bluetooth devices */
 	{ USB_DEVICE(0x8087, 0x0025), .driver_info = BTUSB_INTEL_COMBINED },
@@ -3246,9 +3252,18 @@ done:
 static int btusb_mtk_shutdown(struct hci_dev *hdev)
 {
 	struct btmtk_hci_wmt_params wmt_params;
+#ifdef CONFIG_IGEL_MT7921E_BLUETOOTH_QUIRK
+	struct btusb_data *data = hci_get_drvdata(hdev);
+#endif
 	u8 param = 0;
 	int err;
 
+#ifdef CONFIG_IGEL_MT7921E_BLUETOOTH_QUIRK
+	err = usb_autopm_get_interface(data->intf);
+	if (err < 0)
+		return err;
+#endif
+
 	/* Disable the device */
 	wmt_params.op = BTMTK_WMT_FUNC_CTRL;
 	wmt_params.flag = 0;
@@ -3259,9 +3274,15 @@ static int btusb_mtk_shutdown(struct hci
 	err = btusb_mtk_hci_wmt_sync(hdev, &wmt_params);
 	if (err < 0) {
 		bt_dev_err(hdev, "Failed to send wmt func ctrl (%d)", err);
+#ifdef CONFIG_IGEL_MT7921E_BLUETOOTH_QUIRK
+		usb_autopm_put_interface(data->intf);
+#endif
 		return err;
 	}
 
+#ifdef CONFIG_IGEL_MT7921E_BLUETOOTH_QUIRK
+	usb_autopm_put_interface(data->intf);
+#endif
 	return 0;
 }
 
@@ -4393,6 +4414,21 @@ static int btusb_probe(struct usb_interf
 	if (id->driver_info & BTUSB_MARVELL)
 		hdev->set_bdaddr = btusb_set_bdaddr_marvell;
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	/* The Marvell 88W8897 combined wifi and bluetooth card is known for
+	 * very bad bt+wifi coexisting performance.
+	 *
+	 * Decrease the passive BT Low Energy scan interval a bit
+	 * (0x0190 * 0.625 msec = 250 msec) and make the scan window shorter
+	 * (0x000a * 0,625 msec = 6.25 msec). This allows for significantly
+	 * higher wifi throughput while passively scanning for BT LE devices.
+	 */
+	if (id->driver_info & BTUSB_LOWER_LESCAN_INTERVAL) {
+		hdev->le_scan_interval = 0x0190;
+		hdev->le_scan_window = 0x000a;
+	}
+#endif
+
 	if (IS_ENABLED(CONFIG_BT_HCIBTUSB_MTK) &&
 	    (id->driver_info & BTUSB_MEDIATEK)) {
 		hdev->setup = btusb_mtk_setup;
@@ -4410,6 +4446,12 @@ static int btusb_probe(struct usb_interf
 		set_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks);
 	}
 
+#ifdef CONFIG_IGEL_MT7630E_BLUETOOTH_QUIRK
+	if (id->driver_info & BTUSB_MEDIATEK) {
+		set_bit(HCI_QUIRK_BROKEN_LOCAL_COMMANDS, &hdev->quirks);
+	}
+#endif
+
 	if (id->driver_info & BTUSB_INTEL_BOOT) {
 		hdev->manufacturer = 2;
 		set_bit(HCI_QUIRK_RAW_DEVICE, &hdev->quirks);
diff -Naurp a/linux-6.6.38.igel/drivers/cpufreq/intel_pstate.c b/linux-6.6.38.igel/drivers/cpufreq/intel_pstate.c
--- a/linux-6.6.38.igel/drivers/cpufreq/intel_pstate.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/cpufreq/intel_pstate.c	2024-08-02 15:41:31.535491108 +0200
@@ -25,6 +25,9 @@
 #include <linux/acpi.h>
 #include <linux/vmalloc.h>
 #include <linux/pm_qos.h>
+#ifdef CONFIG_IGEL_MTL_CPU_POWERSAVE
+#include <linux/bitfield.h>
+#endif
 #include <trace/events/power.h>
 
 #include <asm/cpu.h>
@@ -3406,6 +3409,7 @@ static bool intel_pstate_hwp_is_enabled(
 	return !!(value & 0x1);
 }
 
+#ifndef CONFIG_IGEL_MTL_CPU_POWERSAVE
 static const struct x86_cpu_id intel_epp_balance_perf[] = {
 	/*
 	 * Set EPP value as 102, this is the max suggested EPP
@@ -3416,6 +3420,37 @@ static const struct x86_cpu_id intel_epp
 	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, 32),
 	{}
 };
+#else
+#define POWERSAVE_MASK			GENMASK(7, 0)
+#define BALANCE_POWER_MASK		GENMASK(15, 8)
+#define BALANCE_PERFORMANCE_MASK	GENMASK(23, 16)
+#define PERFORMANCE_MASK		GENMASK(31, 24)
+
+#define HWP_SET_EPP_VALUES(powersave, balance_power, balance_perf, performance) \
+	(FIELD_PREP_CONST(POWERSAVE_MASK, powersave) |\
+	 FIELD_PREP_CONST(BALANCE_POWER_MASK, balance_power) |\
+	 FIELD_PREP_CONST(BALANCE_PERFORMANCE_MASK, balance_perf) |\
+	 FIELD_PREP_CONST(PERFORMANCE_MASK, performance))
+
+#define HWP_SET_DEF_BALANCE_PERF_EPP(balance_perf) \
+	(HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE, HWP_EPP_BALANCE_POWERSAVE,\
+	 balance_perf, HWP_EPP_PERFORMANCE))
+
+static const struct x86_cpu_id intel_epp_default[] = {
+ 	/*
+ 	 * Set EPP value as 102, this is the max suggested EPP
+ 	 * which can result in one core turbo frequency for
+ 	 * AlderLake Mobile CPUs.
+ 	 */
+	X86_MATCH_INTEL_FAM6_MODEL(ALDERLAKE_L, HWP_SET_DEF_BALANCE_PERF_EPP(102)),
+	X86_MATCH_INTEL_FAM6_MODEL(SAPPHIRERAPIDS_X, HWP_SET_DEF_BALANCE_PERF_EPP(32)),
+	X86_MATCH_INTEL_FAM6_MODEL(METEORLAKE_L, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE,
+								    HWP_EPP_BALANCE_POWERSAVE, 115, 16)),
+	X86_MATCH_INTEL_FAM6_MODEL(ARROWLAKE, HWP_SET_EPP_VALUES(HWP_EPP_POWERSAVE,
+								 HWP_EPP_BALANCE_POWERSAVE, 115, 16)),
+	{}
+};
+#endif /* CONFIG_IGEL_MTL_CPU_POWERSAVE */
 
 static int __init intel_pstate_init(void)
 {
@@ -3506,10 +3541,29 @@ hwp_cpu_matched:
 	intel_pstate_sysfs_expose_params();
 
 	if (hwp_active) {
+#ifdef CONFIG_IGEL_MTL_CPU_POWERSAVE
+		const struct x86_cpu_id *id = x86_match_cpu(intel_epp_default);
+		if (id) {
+			epp_values[EPP_INDEX_POWERSAVE] =
+					FIELD_GET(POWERSAVE_MASK, id->driver_data);
+			epp_values[EPP_INDEX_BALANCE_POWERSAVE] =
+					FIELD_GET(BALANCE_POWER_MASK, id->driver_data);
+			epp_values[EPP_INDEX_BALANCE_PERFORMANCE] =
+					FIELD_GET(BALANCE_PERFORMANCE_MASK, id->driver_data);
+			epp_values[EPP_INDEX_PERFORMANCE] =
+					FIELD_GET(PERFORMANCE_MASK, id->driver_data);
+			pr_debug("Updated EPPs powersave:%x balanced power:%x balanced perf:%x performance:%x\n",
+				 epp_values[EPP_INDEX_POWERSAVE],
+				 epp_values[EPP_INDEX_BALANCE_POWERSAVE],
+				 epp_values[EPP_INDEX_BALANCE_PERFORMANCE],
+				 epp_values[EPP_INDEX_PERFORMANCE]);
+		}
+#else /* CONFIG_IGEL_MTL_CPU_POWERSAVE */
 		const struct x86_cpu_id *id = x86_match_cpu(intel_epp_balance_perf);
 
 		if (id)
 			epp_values[EPP_INDEX_BALANCE_PERFORMANCE] = id->driver_data;
+#endif /* CONFIG_IGEL_MTL_CPU_POWERSAVE */
 	}
 
 	mutex_lock(&intel_pstate_driver_lock);
diff -Naurp a/linux-6.6.38.igel/drivers/firmware/efi/efi.c b/linux-6.6.38.igel/drivers/firmware/efi/efi.c
--- a/linux-6.6.38.igel/drivers/firmware/efi/efi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/firmware/efi/efi.c	2024-08-02 15:41:31.535491108 +0200
@@ -383,7 +383,12 @@ static int __init efisubsys_init(void)
 	if (!efi_enabled(EFI_RUNTIME_SERVICES))
 		efi.runtime_supported_mask = 0;
 
+#ifdef CONFIG_IGEL_DISBALE_EFI_COMPLETE_WITH_NOEFI_PARAM
+	/* gottwald@igel.com ensure EFI is really fully disabled if noefi kernel parameter was set */
+	if (!efi_enabled(EFI_BOOT) || efi_runtime_disabled())
+#else
 	if (!efi_enabled(EFI_BOOT))
+#endif
 		return 0;
 
 	if (efi.runtime_supported_mask) {
diff -Naurp a/linux-6.6.38.igel/drivers/firmware/sysfb.c b/linux-6.6.38.igel/drivers/firmware/sysfb.c
--- a/linux-6.6.38.igel/drivers/firmware/sysfb.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/firmware/sysfb.c	2024-08-02 15:41:31.535491108 +0200
@@ -33,6 +33,9 @@
 #include <linux/platform_device.h>
 #include <linux/screen_info.h>
 #include <linux/sysfb.h>
+#ifdef CONFIG_IGEL_VMWGFX_FIX
+#include <linux/pci.h>
+#endif
 
 static struct platform_device *pd;
 static DEFINE_MUTEX(disable_lock);
@@ -84,7 +87,17 @@ static __init int sysfb_init(void)
 	sysfb_apply_efi_quirks();
 
 	/* try to create a simple-framebuffer device */
+#ifdef CONFIG_IGEL_VMWGFX_FIX
+	if (pci_get_device(0x15ad, 0x0405, NULL) ||
+	    pci_get_device(0x15ad, 0x0406, NULL)) {
+		compatible = 0;
+	} else {
+		compatible = sysfb_parse_mode(si, &mode);
+	}
+#else
 	compatible = sysfb_parse_mode(si, &mode);
+#endif
+
 	if (compatible) {
 		pd = sysfb_create_simplefb(si, &mode);
 		if (!IS_ERR(pd))
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2024-08-02 15:41:31.535491108 +0200
@@ -184,7 +184,11 @@ int amdgpu_mcbp = -1;
 int amdgpu_discovery = -1;
 int amdgpu_mes;
 int amdgpu_mes_kiq;
+#ifdef CONFIG_IGEL_AMDGPU_CHANGE_DEFAULT_NORETRY_OPTION
+int amdgpu_noretry = 0;
+#else
 int amdgpu_noretry = -1;
+#endif
 int amdgpu_force_asic_type = -1;
 int amdgpu_tmz = -1; /* auto */
 int amdgpu_reset_method = -1; /* auto */
@@ -192,6 +196,15 @@ int amdgpu_num_kcq = -1;
 int amdgpu_smartshift_bias;
 int amdgpu_use_xgmi_p2p = 1;
 int amdgpu_vcnfw_log;
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+int amdgpu_use_fbc = 0;
+#endif
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+int amdgpu_prefer_vram_over_gtt = -1;
+#endif
+#ifdef CONFIG_IGEL_AMDGPU_ADD_DISABLE_MST_SUPPORT_MOD_OPTION
+int amdgpu_disable_mst_support = 0;
+#endif
 int amdgpu_sg_display = -1; /* auto */
 int amdgpu_user_partt_mode = AMDGPU_AUTO_COMPUTE_PARTITION_MODE;
 
@@ -930,7 +943,6 @@ MODULE_PARM_DESC(
 						4 = AMDGPU_CPX_PARTITION_MODE)");
 module_param_named(user_partt_mode, amdgpu_user_partt_mode, uint, 0444);
 
-
 /**
  * DOC: enforce_isolation (bool)
  * enforce process isolation between graphics and compute via using the same reserved vmid.
@@ -938,6 +950,21 @@ module_param_named(user_partt_mode, amdg
 module_param(enforce_isolation, bool, 0444);
 MODULE_PARM_DESC(enforce_isolation, "enforce process isolation between graphics and compute . enforce_isolation = on");
 
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+MODULE_PARM_DESC(use_fbc, "Use framebuffer compression. (0=disable, 1=enable)");
+module_param_named(use_fbc, amdgpu_use_fbc, int, 0600);
+#endif
+
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+MODULE_PARM_DESC(prefer_vram_over_gtt, "Prefer use of VRAM over GTT (-1=auto, 0=disable, 1=enable)");
+module_param_named(prefer_vram_over_gtt, amdgpu_prefer_vram_over_gtt, int, 0600);
+#endif
+
+#ifdef CONFIG_IGEL_AMDGPU_ADD_DISABLE_MST_SUPPORT_MOD_OPTION
+MODULE_PARM_DESC(disable_mst, "Disable DP MST support (0=no (default), 1=yes)");
+module_param_named(disable_mst, amdgpu_disable_mst_support, int, 0600);
+#endif
+
 /* These devices are not supported by amdgpu.
  * They are supported by the mach64, r128, radeon drivers
  */
@@ -2051,6 +2078,11 @@ static int amdgpu_pci_probe(struct pci_d
 	int ret, retry = 0, i;
 	bool supports_atomic = false;
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	if (vga_switcheroo_client_probe_defer(pdev))
+		return -EPROBE_DEFER;
+#endif
+
 	/* skip devices which are owned by radeon */
 	for (i = 0; i < ARRAY_SIZE(amdgpu_unsupported_pciidlist); i++) {
 		if (amdgpu_unsupported_pciidlist[i] == pdev->device)
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2024-08-02 15:41:31.535491108 +0200
@@ -230,6 +230,15 @@ extern bool pcie_p2p;
 
 extern int amdgpu_tmz;
 extern int amdgpu_reset_method;
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+extern int amdgpu_use_fbc;
+#endif
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+extern int amdgpu_prefer_vram_over_gtt;
+#endif
+#ifdef CONFIG_IGEL_AMDGPU_ADD_DISABLE_MST_SUPPORT_MOD_OPTION
+extern int amdgpu_disable_mst_support;
+#endif
 
 #ifdef CONFIG_DRM_AMDGPU_SI
 extern int amdgpu_si_support;
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.c	2024-08-02 15:41:31.535491108 +0200
@@ -903,6 +903,9 @@ int amdgpu_bo_pin_restricted(struct amdg
 	struct amdgpu_device *adev = amdgpu_ttm_adev(bo->tbo.bdev);
 	struct ttm_operation_ctx ctx = { false, false };
 	int r, i;
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+	u32 orig_domain;
+#endif
 
 	if (amdgpu_ttm_tt_get_usermm(bo->tbo.ttm))
 		return -EPERM;
@@ -922,12 +925,21 @@ int amdgpu_bo_pin_restricted(struct amdg
 			return -EINVAL;
 	}
 
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+	orig_domain = domain;
+#endif
+
 	if (bo->tbo.pin_count) {
 		uint32_t mem_type = bo->tbo.resource->mem_type;
 		uint32_t mem_flags = bo->tbo.resource->placement;
 
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+		if (!(orig_domain & amdgpu_mem_type_to_domain(mem_type)))
+			return -EINVAL;
+#else
 		if (!(domain & amdgpu_mem_type_to_domain(mem_type)))
 			return -EINVAL;
+#endif
 
 		if ((mem_type == TTM_PL_VRAM) &&
 		    (bo->flags & AMDGPU_GEM_CREATE_VRAM_CONTIGUOUS) &&
@@ -949,7 +961,11 @@ int amdgpu_bo_pin_restricted(struct amdg
 	/* This assumes only APU display buffers are pinned with (VRAM|GTT).
 	 * See function amdgpu_display_supported_domains()
 	 */
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+	domain = amdgpu_bo_get_preferred_domain(adev, orig_domain);
+#else
 	domain = amdgpu_bo_get_preferred_domain(adev, domain);
+#endif
 
 	if (bo->tbo.base.import_attach)
 		dma_buf_pin(bo->tbo.base.import_attach);
@@ -957,6 +973,9 @@ int amdgpu_bo_pin_restricted(struct amdg
 	/* force to pin into visible video ram */
 	if (!(bo->flags & AMDGPU_GEM_CREATE_NO_CPU_ACCESS))
 		bo->flags |= AMDGPU_GEM_CREATE_CPU_ACCESS_REQUIRED;
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+retry_bo_pin:
+#endif
 	amdgpu_bo_placement_from_domain(bo, domain);
 	for (i = 0; i < bo->placement.num_placement; i++) {
 		unsigned int fpfn, lpfn;
@@ -973,6 +992,15 @@ int amdgpu_bo_pin_restricted(struct amdg
 
 	r = ttm_bo_validate(&bo->tbo, &bo->placement, &ctx);
 	if (unlikely(r)) {
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+		if (r == -ENOMEM &&
+		    orig_domain == (AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT) &&
+		    domain == AMDGPU_GEM_DOMAIN_VRAM) {
+			domain = AMDGPU_GEM_DOMAIN_GTT;
+			dev_err(adev->dev, "%p pin goto retry bo pin\n", bo);
+			goto retry_bo_pin;
+		}
+#endif
 		dev_err(adev->dev, "%p pin failed\n", bo);
 		goto error;
 	}
@@ -1558,11 +1586,33 @@ uint32_t amdgpu_bo_get_preferred_domain(
 	if ((domain == (AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT)) &&
 	    ((adev->asic_type == CHIP_CARRIZO) || (adev->asic_type == CHIP_STONEY))) {
 		domain = AMDGPU_GEM_DOMAIN_VRAM;
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+		if (amdgpu_prefer_vram_over_gtt == 0) {
+			domain = AMDGPU_GEM_DOMAIN_GTT;
+		} else if (amdgpu_prefer_vram_over_gtt != 1) {
+			if (adev->gmc.real_vram_size <= AMDGPU_SG_THRESHOLD)
+                 	       domain = AMDGPU_GEM_DOMAIN_GTT;
+		}
+#else
 		if (adev->gmc.real_vram_size <= AMDGPU_SG_THRESHOLD)
 			domain = AMDGPU_GEM_DOMAIN_GTT;
+#endif
+	}
+	return domain;
+}
+
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+uint32_t amdgpu_bo_get_preferred_fbc_domain(struct amdgpu_device *adev,
+					    uint32_t domain)
+{
+	if (domain == (AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT)) {
+		domain = AMDGPU_GEM_DOMAIN_VRAM;
+		if (amdgpu_prefer_vram_over_gtt != 1)
+			domain = AMDGPU_GEM_DOMAIN_GTT;
 	}
 	return domain;
 }
+#endif
 
 #if defined(CONFIG_DEBUG_FS)
 #define amdgpu_bo_print_flag(m, bo, flag)		        \
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_object.h	2024-08-02 15:41:31.535491108 +0200
@@ -348,6 +348,10 @@ int amdgpu_bo_restore_shadow(struct amdg
 			     struct dma_fence **fence);
 uint32_t amdgpu_bo_get_preferred_domain(struct amdgpu_device *adev,
 					    uint32_t domain);
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+uint32_t amdgpu_bo_get_preferred_fbc_domain(struct amdgpu_device *adev,
+					    uint32_t domain);
+#endif
 
 /*
  * sub allocation
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c	2024-08-02 15:41:31.535491108 +0200
@@ -1937,12 +1937,33 @@ int amdgpu_ttm_init(struct amdgpu_device
 	DRM_INFO("amdgpu: %uM of VRAM memory ready\n",
 		 (unsigned int)(adev->gmc.real_vram_size / (1024 * 1024)));
 
+#ifdef CONFIG_IGEL_AMDGPU_LIMIT_MAX_GTT_SIZE
+	/* Compute GTT size, either based on 1/4 the size of RAM size
+	 * or whatever the user passed on module init */
+	if (amdgpu_gtt_size == -1) {
+		struct sysinfo si;
+
+		si_meminfo(&si);
+		/* Certain GL unit tests for large textures can cause problems
+		 * with the OOM killer since there is no way to link this memory
+		 * to a process.  This was originally mitigated (but not necessarily
+		 * eliminated) by limiting the GTT size.  The problem is this limit
+		 * is often too low for many modern games so just make the limit 1/2
+		 * of system memory which aligns with TTM. The OOM accounting needs
+		 * to be addressed, but we shouldn't prevent common 3D applications
+		 * from being usable just to potentially mitigate that corner case.
+		 */
+		gtt_size = min((3072ULL << 20),
+			       ((u64)si.totalram * si.mem_unit / 4));
+	} else
+#else
 	/* Compute GTT size, either based on TTM limit
 	 * or whatever the user passed on module init.
 	 */
 	if (amdgpu_gtt_size == -1)
 		gtt_size = ttm_tt_pages_limit() << PAGE_SHIFT;
 	else
+#endif
 		gtt_size = (uint64_t)amdgpu_gtt_size << 20;
 
 	/* Initialize GTT memory pool */
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm.c	2024-08-02 15:41:31.539491203 +0200
@@ -896,6 +896,11 @@ static void amdgpu_dm_fbc_init(struct dr
 	struct drm_display_mode *mode;
 	unsigned long max_size = 0;
 
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+	if (amdgpu_use_fbc == 0)
+		return;
+#endif
+
 	if (adev->dm.dc->fbc_compressor == NULL)
 		return;
 
@@ -912,9 +917,17 @@ static void amdgpu_dm_fbc_init(struct dr
 	}
 
 	if (max_size) {
+#ifdef CONFIG_IGEL_AMDGPU_ADD_PREFER_VRAM_MOD_OPTION
+		uint32_t domain = amdgpu_bo_get_preferred_fbc_domain(adev,
+					(AMDGPU_GEM_DOMAIN_VRAM | AMDGPU_GEM_DOMAIN_GTT));
 		int r = amdgpu_bo_create_kernel(adev, max_size * 4, PAGE_SIZE,
-			    AMDGPU_GEM_DOMAIN_GTT, &compressor->bo_ptr,
+			    domain, &compressor->bo_ptr,
 			    &compressor->gpu_addr, &compressor->cpu_addr);
+		if (r == -ENOMEM && domain == AMDGPU_GEM_DOMAIN_VRAM) {
+			r = amdgpu_bo_create_kernel(adev, max_size * 4, PAGE_SIZE,
+				    AMDGPU_GEM_DOMAIN_GTT, &compressor->bo_ptr,
+				    &compressor->gpu_addr, &compressor->cpu_addr);
+		}
 
 		if (r)
 			DRM_ERROR("DM: Failed to initialize FBC\n");
@@ -922,7 +935,18 @@ static void amdgpu_dm_fbc_init(struct dr
 			adev->dm.dc->ctx->fbc_gpu_addr = compressor->gpu_addr;
 			DRM_INFO("DM: FBC alloc %lu\n", max_size*4);
 		}
+#else
+		int r = amdgpu_bo_create_kernel(adev, max_size * 4, PAGE_SIZE,
+			    AMDGPU_GEM_DOMAIN_GTT, &compressor->bo_ptr,
+			    &compressor->gpu_addr, &compressor->cpu_addr);
 
+		if (r)
+			DRM_ERROR("DM: Failed to initialize FBC\n");
+		else {
+			adev->dm.dc->ctx->fbc_gpu_addr = compressor->gpu_addr;
+			DRM_INFO("DM: FBC alloc %lu\n", max_size*4);
+		}
+#endif
 	}
 
 }
@@ -3205,17 +3229,36 @@ void amdgpu_dm_update_connector_after_de
 		dc_sink_retain(aconnector->dc_sink);
 		if (sink->dc_edid.length == 0) {
 			aconnector->edid = NULL;
+#ifdef CONFIG_IGEL_AMDGPU_CALL_DP_CEC_FUNCS_ONLY_FOR_DP
+			if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+			    connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+				if (aconnector->dc_link->aux_mode) {
+					drm_dp_cec_unset_edid(
+						&aconnector->dm_dp_aux.aux);
+				}
+			}
+#else
 			if (aconnector->dc_link->aux_mode) {
 				drm_dp_cec_unset_edid(
 					&aconnector->dm_dp_aux.aux);
 			}
+#endif
 		} else {
 			aconnector->edid =
 				(struct edid *)sink->dc_edid.raw_edid;
 
+#ifdef CONFIG_IGEL_AMDGPU_CALL_DP_CEC_FUNCS_ONLY_FOR_DP
+			if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+			    connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+				if (aconnector->dc_link->aux_mode)
+					drm_dp_cec_set_edid(&aconnector->dm_dp_aux.aux,
+							    aconnector->edid);
+			}
+#else
 			if (aconnector->dc_link->aux_mode)
 				drm_dp_cec_set_edid(&aconnector->dm_dp_aux.aux,
 						    aconnector->edid);
+#endif
 		}
 
 		if (!aconnector->timing_requested) {
@@ -3229,7 +3272,14 @@ void amdgpu_dm_update_connector_after_de
 		amdgpu_dm_update_freesync_caps(connector, aconnector->edid);
 		update_connector_ext_caps(aconnector);
 	} else {
+#ifdef CONFIG_IGEL_AMDGPU_CALL_DP_CEC_FUNCS_ONLY_FOR_DP
+		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+		    connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+			drm_dp_cec_unset_edid(&aconnector->dm_dp_aux.aux);
+		}
+#else
 		drm_dp_cec_unset_edid(&aconnector->dm_dp_aux.aux);
+#endif
 		amdgpu_dm_update_freesync_caps(connector, NULL);
 		drm_connector_update_edid_property(connector, NULL);
 		aconnector->num_modes = 0;
@@ -3462,9 +3512,16 @@ out:
 			hdcp_handle_cpirq(adev->dm.hdcp_workqueue,  aconnector->base.index);
 	}
 
-	if (dc_link->type != dc_connection_mst_branch)
+	if (dc_link->type != dc_connection_mst_branch) {
+#ifdef CONFIG_IGEL_AMDGPU_CALL_DP_CEC_FUNCS_ONLY_FOR_DP
+		if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+		    connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+			drm_dp_cec_irq(&aconnector->dm_dp_aux.aux);
+		}
+#else
 		drm_dp_cec_irq(&aconnector->dm_dp_aux.aux);
-
+#endif
+	}
 	mutex_unlock(&aconnector->hpd_lock);
 }
 
@@ -6311,7 +6368,14 @@ static void amdgpu_dm_connector_destroy(
 		dc_sink_release(aconnector->dc_sink);
 	aconnector->dc_sink = NULL;
 
+#ifdef CONFIG_IGEL_AMDGPU_CALL_DP_CEC_FUNCS_ONLY_FOR_DP
+	if (connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort ||
+	    connector->connector_type == DRM_MODE_CONNECTOR_eDP) {
+		drm_dp_cec_unregister_connector(&aconnector->dm_dp_aux.aux);
+	}
+#else
 	drm_dp_cec_unregister_connector(&aconnector->dm_dp_aux.aux);
+#endif
 	drm_connector_unregister(connector);
 	drm_connector_cleanup(connector);
 	if (aconnector->i2c) {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dce110/dce110_hw_sequencer.c	2024-08-02 15:41:31.539491203 +0200
@@ -35,7 +35,9 @@
 #include "gpio_service_interface.h"
 
 #include "dce110_compressor.h"
-
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+#include "amdgpu.h"
+#endif
 #include "bios/bios_parser_helper.h"
 #include "timing_generator.h"
 #include "mem_input.h"
@@ -1987,6 +1989,10 @@ static bool should_enable_fbc(struct dc
 	struct resource_context *res_ctx = &context->res_ctx;
 	unsigned int underlay_idx = dc->res_pool->underlay_pipe_index;
 
+#ifdef CONFIG_IGEL_AMDGPU_ADD_USE_FBC_MOD_OPTION
+	if (amdgpu_use_fbc != 1)
+		return false;
+#endif
 
 	ASSERT(dc->fbc_compressor);
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/amd/display/dc/dml/calcs/dce_calcs.c	2024-08-02 15:41:31.539491203 +0200
@@ -2528,7 +2528,12 @@ void bw_calcs_init(struct bw_calcs_dceip
 	case BW_CALCS_VERSION_STONEY:
 		vbios->memory_type = bw_def_gddr5;
 		vbios->dram_channel_width_in_bits = 64;
+#ifdef CONFIG_IGEL_FAKE_DUAL_CHANNEL_ON_AMD_STONEY
+		/* gottwald@igel.com fake dual channel RAM */
+		vbios->number_of_dram_channels = 2;
+#else
 		vbios->number_of_dram_channels = asic_id.vram_width / vbios->dram_channel_width_in_bits;
+#endif
 		vbios->number_of_dram_banks = 8;
 		vbios->high_yclk = bw_int_to_fixed(1866);
 		vbios->mid_yclk = bw_int_to_fixed(1866);
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/drm_client_modeset.c b/linux-6.6.38.igel/drivers/gpu/drm/drm_client_modeset.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/drm_client_modeset.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/drm_client_modeset.c	2024-08-02 15:41:31.539491203 +0200
@@ -373,6 +373,408 @@ static int drm_client_get_tile_offsets(s
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+/* gottwald@igel.com: find the best mode for a single screen or a mode common
+ * to all connected displays. Modes with the highest resolution and correct
+ * aspect ratio are choosen. Also the max resolution is limited to modes
+ * smaller then <drm_use_max_w>x<drm_use_max_h>.
+ * Mostly stolen from schneider@igel.com: drm_target_common_modes */
+
+static struct drm_display_mode *drm_find_best_mode(struct drm_client_dev *client,
+						   struct drm_connector **connectors,
+						   unsigned int connector_count,
+					           bool *enabled, int width, int height,
+						   int m_width, int m_height,
+						   struct drm_connector *conn)
+{
+	struct drm_device *dev = client->dev;
+	struct drm_connector *connector;
+	int i, count, aspect, aspect_ratio;
+	bool match_found, first_active;
+	struct list_head *common_mode_entry;
+	struct list_head *tmp_mode_entry;
+	struct drm_display_mode *this_mode, *conn_mode, *found_mode;
+	struct drm_display_mode *copied_mode;
+	struct drm_display_mode *best_mode, *best_mode_aspect, *pref_mode, *pref_first, *current_mode;
+	static int prev_width = 0;
+	static int prev_height = 0;
+	LIST_HEAD(common_modes);
+	LIST_HEAD(common_modes2);
+	int max_width, max_height;
+	struct list_head *work_list = NULL;
+
+	if (width > m_width)
+		max_width = m_width;
+	else
+		max_width = width;
+
+	if (height > m_height)
+		max_height = m_height;
+	else
+		max_height = height;
+
+	count = 0;
+	for (i = 0; i < connector_count; i++) {
+		if (enabled[i])
+			count++;
+	}
+
+	aspect = 3;
+	pref_first = NULL;
+
+	/* Create list of all modes of the first connector and then check if the successive connectors support these modes as well.
+	 * If a mode is not supported by a successive connector, the mode will be removed from our list. */
+	first_active = true;
+	for (i = 0; i < connector_count; i++) {
+		connector = connectors[i];
+
+		if (enabled[i] == false
+		    || connector->status != connector_status_connected
+		    || list_empty(&connector->modes))
+			continue;
+
+		pref_mode = drm_connector_has_preferred_mode(connector, width, height);
+		if (!pref_mode) {
+			list_for_each_entry(this_mode, &connector->modes, head) {
+				if(pref_mode) {
+					if((this_mode->hdisplay * this_mode->vdisplay) > (pref_mode->hdisplay * pref_mode->vdisplay)) {
+						pref_mode = this_mode;
+					}
+				} else {
+					pref_mode = this_mode;
+				}
+			}
+		}
+		if (pref_mode) {
+			aspect_ratio = ((pref_mode->hdisplay * 100) / pref_mode->vdisplay);
+			if (aspect_ratio == 160 && aspect > 0)
+				aspect = 0;
+			else if (aspect_ratio == 177 && aspect > 1)
+				aspect = 1;
+			else if ((aspect_ratio == 133 || aspect_ratio == 125) && aspect > 2)
+				aspect = 2;
+		}
+		if (first_active) {
+			pref_first = pref_mode;
+			if (pref_mode && pref_mode->hdisplay <= max_width && pref_mode->vdisplay <= max_height) {
+				copied_mode = drm_mode_duplicate(dev, pref_mode);
+				list_add_tail(&copied_mode->head, &common_modes);
+				copied_mode = drm_mode_duplicate(dev, pref_mode);
+				list_add_tail(&copied_mode->head, &common_modes2);
+			}
+			/* This is the first active connector, so just add all modes to our list */
+			list_for_each_entry(this_mode, &connector->modes, head) {
+				if (this_mode->hdisplay <= max_width && this_mode->vdisplay <= max_height ) {
+					if (!pref_mode ||
+					    !drm_mode_match(pref_mode, this_mode,
+					   DRM_MODE_MATCH_TIMINGS |
+					   DRM_MODE_MATCH_CLOCK |
+					   DRM_MODE_MATCH_FLAGS |
+					   DRM_MODE_MATCH_3D_FLAGS)) {
+						copied_mode = drm_mode_duplicate(dev, this_mode);
+						list_add_tail(&copied_mode->head, &common_modes);
+						copied_mode = drm_mode_duplicate(dev, this_mode);
+						list_add_tail(&copied_mode->head, &common_modes2);
+					}
+				}
+			}
+			first_active = false;
+		} else {
+			/* This is another connector, so check if our list contains modes that are not supported by this connector and remove them */
+			list_for_each_safe(common_mode_entry, tmp_mode_entry, &common_modes) {
+				struct drm_display_mode *common_mode = list_entry(common_mode_entry, struct drm_display_mode, head);
+				match_found = false;
+				list_for_each_entry(this_mode, &connector->modes, head) {
+					if (drm_mode_match(common_mode, this_mode,
+					   DRM_MODE_MATCH_TIMINGS |
+					   DRM_MODE_MATCH_CLOCK |
+					   DRM_MODE_MATCH_FLAGS |
+					   DRM_MODE_MATCH_3D_FLAGS)) {
+						match_found = true;
+						break;
+					}
+				}
+				if(!match_found) {
+					/* Remove this_mode from the list */
+					list_del_init(&common_mode->head);
+					drm_mode_destroy(dev, common_mode);
+				}
+			}
+			list_for_each_safe(common_mode_entry, tmp_mode_entry, &common_modes2) {
+				struct drm_display_mode *common_mode = list_entry(common_mode_entry, struct drm_display_mode, head);
+				match_found = false;
+				list_for_each_entry(this_mode, &connector->modes, head) {
+					if (common_mode->hdisplay == this_mode->hdisplay &&
+					    common_mode->vdisplay == this_mode->vdisplay) {
+						match_found = true;
+						break;
+					}
+				}
+				if(!match_found) {
+					/* Remove this_mode from the list */
+					list_del_init(&common_mode->head);
+					drm_mode_destroy(dev, common_mode);
+				}
+			}
+		}
+	}
+
+	current_mode = NULL;
+	best_mode = NULL;
+	best_mode_aspect = NULL;
+	work_list = &common_modes2;
+	if (list_empty(work_list))
+		work_list = &common_modes;
+
+	if (!list_empty(work_list) && !best_mode) {
+		/* Find the larges mode in our list */
+		list_for_each_entry(this_mode, work_list, head) {
+			if (prev_width > 0 && prev_height > 0) {
+				if(this_mode->hdisplay == prev_width && this_mode->vdisplay == prev_height) {
+					current_mode = this_mode;
+					break;
+				}
+			}
+			if(best_mode) {
+				if((this_mode->hdisplay * this_mode->vdisplay) > (best_mode->hdisplay * best_mode->vdisplay)) {
+					best_mode = this_mode;
+				}
+			} else {
+				best_mode = this_mode;
+			}
+			aspect_ratio = ((this_mode->hdisplay * 100) / this_mode->vdisplay);
+
+			if ((aspect_ratio == 160 && aspect == 0) ||
+			    (aspect_ratio == 177 && aspect == 1) ||
+			    ((aspect_ratio == 133 || aspect_ratio == 125) && aspect == 2) ||
+			    (aspect == 3)) {
+				if(best_mode_aspect) {
+					if((this_mode->hdisplay * this_mode->vdisplay) > (best_mode_aspect->hdisplay * best_mode_aspect->vdisplay)) {
+						best_mode_aspect = this_mode;
+					}
+				} else {
+					best_mode_aspect = this_mode;
+				}
+			}
+		}
+	}
+
+	if (current_mode)
+		this_mode = current_mode;
+	else if (best_mode_aspect)
+		this_mode = best_mode_aspect;
+	else if (pref_first)
+		this_mode = pref_first;
+	else
+		this_mode = best_mode;
+
+	found_mode = NULL;
+	if (conn && this_mode) {
+		list_for_each_entry(conn_mode, &conn->modes, head) {
+			if (this_mode->hdisplay == conn_mode->hdisplay &&
+			    this_mode->vdisplay == conn_mode->vdisplay &&
+			    ((conn_mode->type & DRM_MODE_TYPE_PREFERRED) ||
+			    found_mode == NULL)) {
+				found_mode = conn_mode;
+			}
+		}
+	}
+
+	if (found_mode) {
+		best_mode = drm_mode_duplicate(dev, found_mode);
+	} else if (this_mode) {
+		best_mode = drm_mode_duplicate(dev, this_mode);
+	}
+
+	/* cleanup after searching best mode */
+
+	list_for_each_safe(common_mode_entry, tmp_mode_entry, &common_modes) {
+		struct drm_display_mode *common_mode = list_entry(common_mode_entry, struct drm_display_mode, head);
+		list_del_init(&common_mode->head);
+		drm_mode_destroy(dev, common_mode);
+	}
+
+	list_for_each_safe(common_mode_entry, tmp_mode_entry, &common_modes2) {
+		struct drm_display_mode *common_mode = list_entry(common_mode_entry, struct drm_display_mode, head);
+		list_del_init(&common_mode->head);
+		drm_mode_destroy(dev, common_mode);
+	}
+
+	if (best_mode) {
+		DRM_INFO("BEST MODE:%dx%d\n", best_mode->hdisplay, best_mode->vdisplay);
+		prev_width = best_mode->hdisplay;
+		prev_height = best_mode->vdisplay;
+	}
+
+	return best_mode;
+}
+
+
+
+/* schneider@igel.com: find a mode common to all connected displays with highest horizontal size */
+static bool drm_client_target_common_modes(struct drm_client_dev *client,
+					   struct drm_connector **connectors,
+					   unsigned int connector_count,
+					   struct drm_display_mode **modes,
+					   bool *enabled, int width, int height,
+					   int m_width, int m_height)
+{
+	struct drm_connector *connector;
+	struct drm_mode_set *mode_set;
+	struct drm_display_mode *this_mode;
+	struct drm_display_mode *best_mode;
+	struct drm_display_mode *found_mode = NULL;
+	int count, i;
+	bool success = false;
+
+	count = 0;
+	drm_client_for_each_modeset(mode_set, client) {
+		struct drm_display_mode *desired_mode;
+		desired_mode = mode_set->mode;
+
+		if (!desired_mode)
+			continue;
+
+		count++;
+	}
+
+	if (count <= 1)
+		return false;
+
+	count = 0;
+	for (i = 0; i < connector_count; i++) {
+		if (enabled[i])
+			count++;
+	}
+
+	/* only contemplate cloning if more than one connector is enabled */
+	if (count <= 1)
+		return false;
+
+	best_mode = drm_find_best_mode(client, connectors, connector_count, enabled, width, height, m_width, m_height, NULL);
+
+	/* If we have found a mode, find the matching modes in all connectors and set the related modes[] value to it */
+	if(best_mode) {
+		for (i = 0; i < connector_count; i++) {
+			connector = connectors[i];
+
+			if (enabled[i] == false) {
+				continue;
+			}
+			found_mode = NULL;
+			success = false;
+			list_for_each_entry(this_mode, &connector->modes, head) {
+				if (best_mode->hdisplay == this_mode->hdisplay &&
+				    best_mode->vdisplay == this_mode->vdisplay &&
+				    ((this_mode->type & DRM_MODE_TYPE_PREFERRED) ||
+				    found_mode == NULL)) {
+					found_mode = this_mode;
+				}
+				if (drm_mode_match(best_mode, this_mode,
+					   DRM_MODE_MATCH_TIMINGS |
+					   DRM_MODE_MATCH_CLOCK |
+					   DRM_MODE_MATCH_FLAGS |
+					   DRM_MODE_MATCH_3D_FLAGS)) {
+					modes[i] = this_mode;
+					success = true;
+				}
+			}
+			/* if no equal mode was found take one with the same hdisplay and vdisplay size */
+			if (found_mode) {
+				modes[i] = found_mode;
+				success = true;
+			}
+			if (success == true) {
+				DRM_INFO("BEST MODE[%s]:%dx%d\n", connector->name, modes[i]->hdisplay, modes[i]->vdisplay);
+			}
+		}
+	}
+
+	return success;
+}
+
+static bool drm_client_best_mode(struct drm_client_dev *client,
+				 struct drm_connector **connectors,
+				 unsigned int connector_count,
+				 struct drm_display_mode **modes,
+				 struct drm_client_offset *offsets,
+				 bool *enabled, int width, int height,
+				 int m_width, int m_height)
+{
+	const u64 mask = BIT_ULL(connector_count) - 1;
+	struct drm_connector *connector;
+	u64 conn_configured = 0;
+	int tile_pass = 0;
+	int i;
+
+retry:
+	for (i = 0; i < connector_count; i++) {
+		connector = connectors[i];
+
+		if (conn_configured & BIT_ULL(i))
+			continue;
+
+		if (enabled[i] == false) {
+			conn_configured |= BIT_ULL(i);
+			continue;
+		}
+
+		/* first pass over all the untiled connectors */
+		if (tile_pass == 0 && connector->has_tile)
+			continue;
+
+		if (tile_pass == 1) {
+			if (connector->tile_h_loc != 0 ||
+			    connector->tile_v_loc != 0)
+				continue;
+
+		} else {
+			if (connector->tile_h_loc != tile_pass - 1 &&
+			    connector->tile_v_loc != tile_pass - 1)
+			/* if this tile_pass doesn't cover any of the tiles - keep going */
+				continue;
+
+			/*
+			 * find the tile offsets for this pass - need to find
+			 * all tiles left and above
+			 */
+			drm_client_get_tile_offsets(connectors, connector_count, modes, offsets, i,
+						    connector->tile_h_loc, connector->tile_v_loc);
+		}
+		DRM_DEBUG_KMS("looking for cmdline mode on connector %d\n",
+			      connector->base.id);
+
+		/* got for command line mode first */
+		modes[i] = drm_connector_pick_cmdline_mode(connector);
+		if (!modes[i]) {
+			DRM_DEBUG_KMS("looking for best mode on connector %d %d\n",
+				      connector->base.id, connector->tile_group ? connector->tile_group->id : 0);
+			modes[i] = drm_find_best_mode(client, connectors, connector_count, enabled, width, height, m_width, m_height, connector);
+			DRM_INFO("BEST MODE[%s]:%dx%d\n", connector->name, modes[i]->hdisplay, modes[i]->vdisplay);
+		}
+		if (!modes[i]) {
+			DRM_DEBUG_KMS("looking for preferred mode on connector %d %d\n",
+				      connector->base.id, connector->tile_group ? connector->tile_group->id : 0);
+			modes[i] = drm_connector_has_preferred_mode(connector, width, height);
+		}
+		/* No preferred modes, pick one off the list */
+		if (!modes[i] && !list_empty(&connector->modes)) {
+			list_for_each_entry(modes[i], &connector->modes, head)
+				break;
+		}
+		DRM_DEBUG_KMS("found mode %s\n", modes[i] ? modes[i]->name :
+			  "none");
+		conn_configured |= BIT_ULL(i);
+	}
+
+	if ((conn_configured & mask) != mask) {
+		tile_pass++;
+		goto retry;
+	}
+	return true;
+}
+#endif /* CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER */
+
 static bool drm_client_target_preferred(struct drm_connector **connectors,
 					unsigned int connector_count,
 					struct drm_display_mode **modes,
@@ -769,7 +1171,11 @@ bail:
  * Returns:
  * Zero on success or negative error code on failure.
  */
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height, bool use_best_mode, unsigned int m_width, unsigned int m_height)
+#else
 int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height)
+#endif
 {
 	struct drm_connector *connector, **connectors = NULL;
 	struct drm_connector_list_iter conn_iter;
@@ -782,6 +1188,9 @@ int drm_client_modeset_probe(struct drm_
 	struct drm_crtc **crtcs;
 	int i, ret = 0;
 	bool *enabled;
+#if defined(CONFIG_IGEL_FIX_RADEON_3_SCREENS_BEST_MODE_ISSUE) || defined(CONFIG_IGEL_4_SCREENS_BEST_MODE_ISSUE)
+	int count = 0;
+#endif
 
 	DRM_DEBUG_KMS("\n");
 
@@ -828,17 +1237,68 @@ int drm_client_modeset_probe(struct drm_
 		DRM_DEBUG_KMS("No connectors reported connected with modes\n");
 	drm_client_connectors_enabled(connectors, connector_count, enabled);
 
+#if defined(CONFIG_IGEL_FIX_RADEON_3_SCREENS_BEST_MODE_ISSUE) || defined(CONFIG_IGEL_4_SCREENS_BEST_MODE_ISSUE)
+	count = 0;
+	for (i = 0; i < connector_count; i++) {
+		if (enabled[i])
+			count++;
+	}
+#endif
+
+#ifdef CONFIG_IGEL_FIX_RADEON_3_SCREENS_BEST_MODE_ISSUE
+	/* We have a radeon device which behave really badly if trying to set a common
+	 * mode with more then 2 monitors with different resolutions so try to fix this */
+	if (count > 2) {
+		if (dev &&
+		dev->driver &&
+		dev->driver->name) {
+			if (!strcmp(dev->driver->name, "radeon")) {
+				use_best_mode = 0;
+			}
+		}
+	}
+#endif /* CONFIG_IGEL_FIX_RADEON_3_SCREENS_BEST_MODE_ISSUE */
+
+#ifdef CONFIG_IGEL_4_SCREENS_BEST_MODE_ISSUE
+	/* we tested with a AMD V1000 platform and 4 x 4K screens and run into issues
+	 * so do not use best_mode for more then 3 screens */
+	if (count > 3) {
+		use_best_mode = 0;
+	}
+#endif /* CONFIG_IGEL_4_SCREENS_BEST_MODE_ISSUE */
+
 	if (!drm_client_firmware_config(client, connectors, connector_count, crtcs,
 					modes, offsets, enabled, width, height)) {
 		memset(modes, 0, connector_count * sizeof(*modes));
 		memset(crtcs, 0, connector_count * sizeof(*crtcs));
 		memset(offsets, 0, connector_count * sizeof(*offsets));
 
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+		if (!drm_client_target_cloned(dev, connectors, connector_count, modes,
+					      offsets, enabled, width, height)) {
+			if (use_best_mode) {
+				if (!drm_client_target_common_modes(client, connectors, connector_count, modes,
+								    enabled, width, height,
+								    (int)m_width, (int)m_height)) {
+					if (!drm_client_best_mode(client, connectors, connector_count, modes,
+								  offsets, enabled, width, height,
+								  (int)m_width, (int)m_height)) {
+						DRM_ERROR("Unable to find initial modes\n");
+					}
+				}
+			} else {
+				if(!drm_client_target_preferred(connectors, connector_count, modes,
+								offsets, enabled, width, height))
+					DRM_ERROR("Unable to find initial modes\n");
+			}
+		}
+#else
 		if (!drm_client_target_cloned(dev, connectors, connector_count, modes,
 					      offsets, enabled, width, height) &&
 		    !drm_client_target_preferred(connectors, connector_count, modes,
 						 offsets, enabled, width, height))
 			DRM_ERROR("Unable to find initial modes\n");
+#endif
 
 		DRM_DEBUG_KMS("picking CRTCs for %dx%d config\n",
 			      width, height);
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/drm_edid.c b/linux-6.6.38.igel/drivers/gpu/drm/drm_edid.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/drm_edid.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/drm_edid.c	2024-08-02 15:41:31.539491203 +0200
@@ -2176,8 +2176,20 @@ drm_do_probe_ddc_edid(void *data, u8 *bu
 		ret = i2c_transfer(adapter, &msgs[3 - xfers], xfers);
 
 		if (ret == -ENXIO) {
+#ifdef CONFIG_IGEL_EDID_DETECTION_SECOND_TRY_QUIRK
+			/* gottwald@igel.com try a second time if getting a ENXIO
+			 * this fix wrong detection on Lenovo ThinkCentre M32 */
+			if (retries <= 2) {
+				DRM_DEBUG_KMS("drm: skipping non-existent adapter %s\n",
+						adapter->name);
+				break;
+			} else {
+				retries = 2;
+			}
+#else
 			DRM_DEBUG_KMS("drm: skipping non-existent adapter %s\n",
 					adapter->name);
+#endif
 			break;
 		}
 	} while (ret != xfers && --retries);
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/drm_fb_helper.c b/linux-6.6.38.igel/drivers/gpu/drm/drm_fb_helper.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/drm_fb_helper.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/drm_fb_helper.c	2024-08-02 15:41:31.539491203 +0200
@@ -56,6 +56,21 @@ MODULE_PARM_DESC(drm_fbdev_overalloc,
 		 "Overallocation of the fbdev buffer (%) [default="
 		 __MODULE_STRING(CONFIG_DRM_FBDEV_OVERALLOC) "]");
 
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+static bool drm_use_best_mode = true;
+module_param_named(best_mode, drm_use_best_mode, bool, 0600);
+MODULE_PARM_DESC(best_mode,
+		 "Enable use of best mode on console [default=true]");
+static int drm_use_max_w = 1920;
+module_param_named(max_width, drm_use_max_w, int, 0600);
+MODULE_PARM_DESC(max_width,
+		 "Limit max resolution width on console [default=1920]");
+static int drm_use_max_h = 1200;
+module_param_named(max_height, drm_use_max_h, int, 0600);
+MODULE_PARM_DESC(max_height,
+		 "Limit max resolution height on console [default=1200]");
+#endif
+
 /*
  * In order to keep user-space compatibility, we want in certain use-cases
  * to keep leaking the fbdev physical address to the user-space program
@@ -1669,6 +1684,11 @@ static int drm_fb_helper_single_fb_probe
 
 	/* push down into drivers */
 	ret = (*fb_helper->funcs->fb_probe)(fb_helper, &sizes);
+
+#ifdef CONFIG_IGEL_VGA_USE_DVI_MODES_IF_MODES_MISSING_QUIRK
+	/* schneider@igel.com: call fb_probe() another time to allow the VGA to use the DVI modes if there is no VGA EDID found */
+ 	ret = (*fb_helper->funcs->fb_probe)(fb_helper, &sizes);
+#endif
 	if (ret < 0)
 		return ret;
 
@@ -1845,7 +1865,11 @@ __drm_fb_helper_initial_config_and_unloc
 	width = dev->mode_config.max_width;
 	height = dev->mode_config.max_height;
 
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+	drm_client_modeset_probe(&fb_helper->client, width, height, drm_use_best_mode, drm_use_max_w, drm_use_max_h);
+#else
 	drm_client_modeset_probe(&fb_helper->client, width, height);
+#endif
 	ret = drm_fb_helper_single_fb_probe(fb_helper);
 	if (ret < 0) {
 		if (ret == -EAGAIN) {
@@ -1983,7 +2007,20 @@ int drm_fb_helper_hotplug_event(struct d
 
 	drm_dbg_kms(fb_helper->dev, "\n");
 
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+	/* gottwald@igel.com : No we do not want to limit the max mode sizes to the current console modes, WTF */
+#ifndef CONFIG_IGEL_DO_NOT_LIMIT_MAX_MODE_SIZE
+	drm_client_modeset_probe(&fb_helper->client, fb_helper->fb->width, fb_helper->fb->height, drm_use_best_mode, drm_use_max_w, drm_use_max_h);
+#else
+	drm_client_modeset_probe(&fb_helper->client, 0, 0, drm_use_best_mode, drm_use_max_w, drm_use_max_h);
+#endif
+#else /* CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER */
+#ifndef CONFIG_IGEL_DO_NOT_LIMIT_MAX_MODE_SIZE_TO_CURRENT_FB
 	drm_client_modeset_probe(&fb_helper->client, fb_helper->fb->width, fb_helper->fb->height);
+#else
+	drm_client_modeset_probe(&fb_helper->client, 0, 0);
+#endif
+#endif /* CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER */
 	drm_setup_crtcs_fb(fb_helper);
 	mutex_unlock(&fb_helper->lock);
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_bios.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_bios.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_bios.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_bios.c	2024-08-02 15:41:31.539491203 +0200
@@ -3647,6 +3647,15 @@ void intel_bios_for_each_encoder(struct
 {
 	struct intel_bios_encoder_data *devdata;
 
+#ifdef CONFIG_IGEL_I915_ADD_OPTION_TO_CHANGE_CONNECTOR_ENUM_ORDER
+	if (i915_modparams.reverse_enum_order != 0)
+		list_for_each_entry_reverse(devdata, &i915->display.vbt.display_devices, node)
+			func(i915, devdata);
+	else
+		list_for_each_entry(devdata, &i915->display.vbt.display_devices, node)
+			func(i915, devdata);
+#else
 	list_for_each_entry(devdata, &i915->display.vbt.display_devices, node)
 		func(i915, devdata);
+#endif
 }
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_ddi.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_ddi.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_ddi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_ddi.c	2024-08-02 15:41:31.539491203 +0200
@@ -2908,7 +2908,12 @@ static void intel_ddi_post_disable_dp(st
 	 * Power down sink before disabling the port, otherwise we end
 	 * up getting interrupts from the sink on detecting link loss.
 	 */
+#ifdef CONFIG_IGEL_I915_WYSE_3040_DP_QUIRK
+	if (!(intel_has_quirk(dev_priv, QUIRK_SKIP_DP_DPMS_D3)))
+		intel_dp_set_power(intel_dp, DP_SET_POWER_D3);
+#else
 	intel_dp_set_power(intel_dp, DP_SET_POWER_D3);
+#endif
 
 	if (DISPLAY_VER(dev_priv) >= 12) {
 		if (is_mst) {
@@ -3775,6 +3780,9 @@ static void intel_ddi_get_config(struct
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder->base.dev);
 	enum transcoder cpu_transcoder = pipe_config->cpu_transcoder;
+#if defined(CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION) || defined(CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION)
+	bool has_audio = false;
+#endif
 
 	/* XXX: DSI transcoder paranoia */
 	if (drm_WARN_ON(&dev_priv->drm, transcoder_is_dsi(cpu_transcoder)))
@@ -3784,8 +3792,21 @@ static void intel_ddi_get_config(struct
 
 	intel_ddi_mso_get_config(encoder, pipe_config);
 
+#if defined(CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION) || defined(CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION)
+	has_audio = intel_ddi_is_audio_enabled(dev_priv, cpu_transcoder);
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION
+	if ((enum intel_output_type) encoder->compute_output_type == (enum intel_output_type)INTEL_OUTPUT_DP && i915_modparams.disable_dp_audio)
+		has_audio = false;
+#endif
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION
+	if ((enum intel_output_type) encoder->compute_output_type == (enum intel_output_type)INTEL_OUTPUT_HDMI && i915_modparams.disable_hdmi_audio)
+		has_audio = false;
+#endif
+	pipe_config->has_audio = has_audio;
+#else
 	pipe_config->has_audio =
 		intel_ddi_is_audio_enabled(dev_priv, cpu_transcoder);
+#endif
 
 	if (encoder->type == INTEL_OUTPUT_EDP)
 		intel_edp_fixup_vbt_bpp(encoder, pipe_config->pipe_bpp);
@@ -4508,6 +4529,11 @@ static bool intel_ddi_a_force_4_lanes(st
 	if (dig_port->saved_port_bits & DDI_A_4_LANES)
 		return false;
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	if (intel_has_quirk(dev_priv, QUIRK_DDI_A_FORCE_4_LANES))
+		return true;
+#endif
+
 	/* Broxton/Geminilake: Bspec says that DDI_A_4_LANES is the only
 	 *                     supported configuration
 	 */
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display.c	2024-08-02 15:41:31.539491203 +0200
@@ -7481,6 +7481,37 @@ void intel_setup_outputs(struct drm_i915
 
 		if (intel_de_read(dev_priv, PCH_DP_D) & DP_DETECTED)
 			g4x_dp_init(dev_priv, PCH_DP_D, PORT_D);
+#ifdef CONFIG_IGEL_I915_H830_CHANGE_CONNECTOR_ORDER
+	} else if (IS_VALLEYVIEW(dev_priv) && IS_IGEL_H830C) {
+		bool has_edp, has_port;
+
+		if (IS_VALLEYVIEW(dev_priv) && dev_priv->display.vbt.int_crt_support)
+			intel_crt_init(dev_priv);
+
+		/* nagel@igel.com:
+		 * On IGEL_H830C board, the DVI connector is init'd first and will get
+		 * numbered as 'HDMI1', as the DVI/DisplayPort connectors on the PCB are switched.
+		 * Because the DVI connector of the H820C got numbered as 'HDMI2',
+		 * this may cause switched monitors when migrating from a H820C to a H830C,
+		 * while using a dual-monitor setup.
+		 */
+
+		has_edp = intel_dp_is_port_edp(dev_priv, PORT_C);
+		has_port = intel_bios_is_port_present(dev_priv, PORT_C);
+		if (intel_de_read(dev_priv, VLV_DP_C) & DP_DETECTED || has_port)
+			has_edp &= g4x_dp_init(dev_priv, VLV_DP_C, PORT_C);
+		if ((intel_de_read(dev_priv, VLV_HDMIC) & SDVO_DETECTED || has_port) && !has_edp)
+			g4x_hdmi_init(dev_priv, VLV_HDMIC, PORT_C);
+
+		has_edp = intel_dp_is_port_edp(dev_priv, PORT_B);
+		has_port = intel_bios_is_port_present(dev_priv, PORT_B);
+		if (intel_de_read(dev_priv, VLV_DP_B) & DP_DETECTED || has_port)
+			has_edp &= g4x_dp_init(dev_priv, VLV_DP_B, PORT_B);
+		if ((intel_de_read(dev_priv, VLV_HDMIB) & SDVO_DETECTED || has_port) && !has_edp)
+			g4x_hdmi_init(dev_priv, VLV_HDMIB, PORT_B);
+
+		vlv_dsi_init(dev_priv);
+#endif
 	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {
 		bool has_edp, has_port;
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display_types.h b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display_types.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display_types.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_display_types.h	2024-08-02 15:41:31.543491299 +0200
@@ -1751,6 +1751,12 @@ struct intel_dp {
 	/* connector directly attached - won't be use for modeset in mst world */
 	struct intel_connector *attached_connector;
 
+#ifdef CONFIG_IGEL_I915_DP_DETECT_WORKAROUND
+	/* gottwald@igel.com variables for DPMS OFF/ON workaround */
+	bool detect_workaround;
+	ktime_t detect_workaround_timestamp;
+#endif /* CONFIG_IGEL_I915_DP_DETECT_WORKAROUND */
+
 	/* mst connector list */
 	struct intel_dp_mst_encoder *mst_encoders[I915_MAX_PIPES];
 	struct drm_dp_mst_topology_mgr mst_mgr;
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp.c	2024-08-02 15:41:31.543491299 +0200
@@ -529,6 +529,12 @@ intel_dp_set_source_rates(struct intel_d
 	else if (vbt_max_rate)
 		max_rate = vbt_max_rate;
 
+#ifdef CONFIG_IGEL_I915_ADD_LIMIT_DP_RATE_OPTION
+	/* gottwald@igel.com : Added module parameter to limit max DP link rate */
+	if (i915_modparams.limit_dp_max_rate >= 162000 && (max_rate == 0 || max_rate > i915_modparams.limit_dp_max_rate))
+			max_rate = i915_modparams.limit_dp_max_rate;
+#endif
+
 	if (max_rate)
 		size = intel_dp_rate_limit_len(source_rates, size, max_rate);
 
@@ -1911,7 +1917,15 @@ bool intel_dp_limited_color_range(const
 		to_intel_digital_connector_state(conn_state);
 	const struct drm_display_mode *adjusted_mode =
 		&crtc_state->hw.adjusted_mode;
+#ifdef CONFIG_IGEL_I915_ADD_M250C_NO_LIMITED_COLOR_RANGE_OPTION
+	struct intel_connector *intel_connector =
+		to_intel_connector(conn_state->connector);
+	struct drm_connector *connector = &intel_connector->base;
 
+	/* gottwald@igel.com Ugly workaround for M250C colorspace problems on DP-1 connector */
+	if (strcmp("DP-1", connector->name) == 0 && i915_modparams.m250c_no_limited_color_range != 0)
+		return 0;
+#endif
 	/*
 	 * Our YCbCr output is always limited range.
 	 * crtc_state->limited_color_range only applies to RGB,
@@ -1945,6 +1959,12 @@ static bool intel_dp_port_has_audio(stru
 	if (DISPLAY_VER(dev_priv) < 12 && port == PORT_A)
 		return false;
 
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION
+        if (i915_modparams.disable_dp_audio) {
+                return false;
+        }
+#endif
+
 	return true;
 }
 
@@ -2277,9 +2297,19 @@ intel_dp_compute_config(struct intel_enc
 	if (HAS_PCH_SPLIT(dev_priv) && !HAS_DDI(dev_priv) && encoder->port != PORT_A)
 		pipe_config->has_pch_encoder = true;
 
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION
+	if (i915_modparams.disable_dp_audio) {
+		pipe_config->has_audio = false;
+	} else {
+		pipe_config->has_audio =
+			intel_dp_has_audio(encoder, conn_state) &&
+			intel_audio_compute_config(encoder, pipe_config, conn_state);
+	}
+#else
 	pipe_config->has_audio =
 		intel_dp_has_audio(encoder, conn_state) &&
 		intel_audio_compute_config(encoder, pipe_config, conn_state);
+#endif
 
 	fixed_mode = intel_panel_fixed_mode(connector, adjusted_mode);
 	if (intel_dp_is_edp(intel_dp) && fixed_mode) {
@@ -4844,6 +4874,18 @@ intel_dp_set_edid(struct intel_dp *intel
 
 	/* FIXME: Get rid of drm_edid_raw() */
 	edid = drm_edid_raw(drm_edid);
+	if (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {
+
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION
+		if (i915_modparams.disable_dp_audio) {
+			connector->base.display_info.has_audio = false;
+		} else {
+			connector->base.display_info.has_audio = drm_detect_monitor_audio(edid);
+		}
+#else
+		connector->base.display_info.has_audio = drm_detect_monitor_audio(edid);
+#endif
+	}
 
 	drm_dp_cec_set_edid(&intel_dp->aux, edid);
 }
@@ -4891,12 +4933,34 @@ intel_dp_detect(struct drm_connector *co
 		return connector_status_disconnected;
 
 	/* Can't disconnect eDP */
+#ifdef CONFIG_IGEL_I915_DP_DETECT_WORKAROUND
+	if (intel_dp_is_edp(intel_dp)) {
+		status = edp_detect(intel_dp);
+	} else {
+		/* gottwald@igel.com some monitors (Samsung U28D590D) took some time after
+		 * a DPMS OFF/ON event before ibx_digital_port_connected is working again.
+		 * The detect workaround is set if the DP link train was sucessful.
+		 * So if detect_workaround is set and detect_workaround_timestamp is less
+		 * then 900 ms from now do not use ibx_digital_port_connected result
+		 */
+
+		if (intel_digital_port_connected(encoder))
+			status = intel_dp_detect_dpcd(intel_dp);
+		else if (intel_dp->detect_workaround == true &&
+			 ktime_to_ms(ktime_sub(ktime_get(), intel_dp->detect_workaround_timestamp)) <= 900)
+			status = intel_dp_detect_dpcd(intel_dp);
+		else
+			status = connector_status_disconnected;
+	}
+	intel_dp->detect_workaround = false;
+#else
 	if (intel_dp_is_edp(intel_dp))
 		status = edp_detect(intel_dp);
 	else if (intel_digital_port_connected(encoder))
 		status = intel_dp_detect_dpcd(intel_dp);
 	else
 		status = connector_status_disconnected;
+#endif /* CONFIG_IGEL_I915_DP_DETECT_WORKAROUND */
 
 	if (status == connector_status_disconnected) {
 		memset(&intel_dp->compliance, 0, sizeof(intel_dp->compliance));
@@ -5353,6 +5417,11 @@ static bool _intel_dp_is_port_edp(struct
 	if (DISPLAY_VER(dev_priv) < 5)
 		return false;
 
+#ifdef CONFIG_IGEL_I915_EDP_IS_DP_MODULE_OPTION
+	if (i915_modparams.edp_is_dp == 1)
+		return false;
+#endif
+
 	if (DISPLAY_VER(dev_priv) < 9 && port == PORT_A)
 		return true;
 
@@ -5726,6 +5795,12 @@ intel_dp_init_connector(struct intel_dig
 	else
 		intel_connector->get_hw_state = intel_connector_get_hw_state;
 
+#ifdef CONFIG_IGEL_I915_DP_DETECT_WORKAROUND
+	/* gottwald@igel.com init dp detect workaround */
+
+	intel_dp->detect_workaround = false;
+	intel_dp->detect_workaround_timestamp = ktime_get();
+#endif
 	if (!intel_edp_init_connector(intel_dp, intel_connector)) {
 		intel_dp_aux_fini(intel_dp);
 		goto fail;
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_link_training.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_link_training.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_link_training.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_link_training.c	2024-08-02 15:41:31.543491299 +0200
@@ -1364,6 +1364,30 @@ void intel_dp_start_link_train(struct in
 		/* Still continue with enabling the port and link training. */
 		lttpr_count = 0;
 
+#ifdef CONFIG_IGEL_I915_DP_DETECT_WORKAROUND
+	/* gottwald@igel.com some monitors (Samsung U28D590D) took some time after
+	 * a DPMS OFF/ON event before ibx_digital_port_connected is working again.
+	 * The detect workaround is set if the DP link train was sucessful. */
+
+	intel_dp->detect_workaround = true;
+	intel_dp->detect_workaround_timestamp = ktime_get();
+#endif
+
+#ifdef CONFIG_IGEL_I915_DP_RETRY_LINK_TRAINING
+	intel_dp_prepare_link_train(intel_dp, crtc_state);
+
+	if (intel_dp_is_uhbr(crtc_state))
+		passed = intel_dp_128b132b_link_train(intel_dp, crtc_state, lttpr_count);
+	else
+		passed = intel_dp_link_train_all_phys(intel_dp, crtc_state, lttpr_count);
+
+	if (!passed) {
+		usleep_range(50000, 200000);
+	} else {
+		return;
+	}
+#endif
+
 	intel_dp_prepare_link_train(intel_dp, crtc_state);
 
 	if (intel_dp_is_uhbr(crtc_state))
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_mst.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_mst.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_mst.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_dp_mst.c	2024-08-02 15:41:31.543491299 +0200
@@ -266,6 +266,7 @@ static int intel_dp_dsc_mst_compute_link
 
 	return 0;
 }
+
 static int intel_dp_mst_update_slots(struct intel_encoder *encoder,
 				     struct intel_crtc_state *crtc_state,
 				     struct drm_connector_state *conn_state)
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_fbdev.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_fbdev.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_fbdev.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_fbdev.c	2024-08-02 15:41:31.543491299 +0200
@@ -233,6 +233,26 @@ static int intelfb_create(struct drm_fb_
 	if (ret)
 		return ret;
 
+#ifdef CONFIG_IGEL_I915_ALWAYS_RESIZE_FRAMEBUFFER
+	if (intel_fb &&
+	    (sizes->fb_width != intel_fb->base.width ||
+	     sizes->fb_height != intel_fb->base.height)) {
+		drm_dbg_kms(&dev_priv->drm,
+			    "BIOS fb (%dx%d) do not match the required (%dx%d),"
+			    " releasing it\n",
+			    intel_fb->base.width, intel_fb->base.height,
+			    sizes->fb_width, sizes->fb_height);
+#else
+# ifdef CONFIG_IGEL_APPLE_FRAMEBUF
+	if (intel_fb &&
+	    (sizes->fb_width != intel_fb->base.width ||
+	     sizes->fb_height != intel_fb->base.height)) {
+		drm_dbg_kms(&dev_priv->drm,
+			    "BIOS fb not valid (%dx%d), we require (%dx%d),"
+			    " releasing it\n",
+			    intel_fb->base.width, intel_fb->base.height,
+			    sizes->fb_width, sizes->fb_height);
+# else
 	if (intel_fb &&
 	    (sizes->fb_width > intel_fb->base.width ||
 	     sizes->fb_height > intel_fb->base.height)) {
@@ -241,6 +261,8 @@ static int intelfb_create(struct drm_fb_
 			    " releasing it\n",
 			    intel_fb->base.width, intel_fb->base.height,
 			    sizes->fb_width, sizes->fb_height);
+# endif
+#endif
 		drm_framebuffer_put(&intel_fb->base);
 		intel_fb = ifbdev->fb = NULL;
 	}
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_hdmi.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_hdmi.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_hdmi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_hdmi.c	2024-08-02 15:41:31.543491299 +0200
@@ -2182,6 +2182,11 @@ static bool intel_hdmi_has_audio(struct
 	if (!crtc_state->has_hdmi_sink)
 		return false;
 
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION
+        if (i915_modparams.disable_hdmi_audio)
+		return false;
+#endif
+
 	if (intel_conn_state->force_audio == HDMI_AUDIO_AUTO)
 		return connector->display_info.has_audio;
 	else
@@ -2306,9 +2311,19 @@ int intel_hdmi_compute_config(struct int
 	if (adjusted_mode->flags & DRM_MODE_FLAG_DBLCLK)
 		pipe_config->pixel_multiplier = 2;
 
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION
+	if (i915_modparams.disable_hdmi_audio) {
+		pipe_config->has_audio = false;
+	} else {
+		pipe_config->has_audio =
+			intel_hdmi_has_audio(encoder, pipe_config, conn_state) &&
+			intel_audio_compute_config(encoder, pipe_config, conn_state);
+	}
+#else
 	pipe_config->has_audio =
 		intel_hdmi_has_audio(encoder, pipe_config, conn_state) &&
 		intel_audio_compute_config(encoder, pipe_config, conn_state);
+#endif
 
 	/*
 	 * Try to respect downstream TMDS clock limits first, if
@@ -2449,6 +2464,15 @@ intel_hdmi_dp_dual_mode_detect(struct dr
 	}
 }
 
+#ifdef CONFIG_IGEL_FIX_I915_DVI_I_PORT_DETECTION
+/*
+ * lang@igel:
+ * fix DVI Monitor detection on H830 DVI-I port, if a dvi dual link
+ * cable is used together with a dvi dual link capable monitor
+ */
+static int igel_hdmi_fix = 1;
+#endif
+
 static bool
 intel_hdmi_set_edid(struct drm_connector *connector)
 {
@@ -2474,6 +2498,21 @@ intel_hdmi_set_edid(struct drm_connector
 		intel_gmbus_force_bit(i2c, false);
 	}
 
+#ifdef CONFIG_IGEL_FIX_I915_DVI_I_PORT_DETECTION
+	/*
+	 * lang@igel:
+	 * fix DVI Monitor detection on H830 DVI-I port, if a dvi dual link
+	 * cable is used together with a dvi dual link capable monitor
+	 */
+	if (igel_hdmi_fix) {
+		if (! edid)
+			edid = drm_get_edid(connector,
+			    intel_gmbus_get_adapter(dev_priv,
+						    intel_hdmi->ddc_bus));
+		igel_hdmi_fix = 0;
+	}
+#endif
+
 	/* Below we depend on display info having been updated */
 	drm_edid_connector_update(connector, drm_edid);
 
@@ -2482,6 +2521,14 @@ intel_hdmi_set_edid(struct drm_connector
 	/* FIXME: Get rid of drm_edid_raw() */
 	edid = drm_edid_raw(drm_edid);
 	if (edid && edid->input & DRM_EDID_INPUT_DIGITAL) {
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION
+		if (i915_modparams.disable_hdmi_audio)
+			connector->display_info.has_audio = false;
+		else
+			connector->display_info.has_audio = drm_detect_monitor_audio(edid);
+#else
+		connector->display_info.has_audio = drm_detect_monitor_audio(edid);
+#endif
 		intel_hdmi_dp_dual_mode_detect(connector);
 
 		connected = true;
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_lvds.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_lvds.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_lvds.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_lvds.c	2024-08-02 15:41:31.543491299 +0200
@@ -857,6 +857,13 @@ void intel_lvds_init(struct drm_i915_pri
 		return;
 	}
 
+#ifdef CONFIG_IGEL_I915_DISABLE_LVDS_MODULE_OPTION
+	/* lang@igel.de: Skip init if LVDS is disabled */
+	if (! i915_modparams.lvds) {
+		DRM_INFO("LVDS is disabled by module parameter\n");
+		return;
+	}
+#endif
 	if (HAS_PCH_SPLIT(i915))
 		lvds_reg = PCH_LVDS;
 	else
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.c	2024-08-02 15:41:31.543491299 +0200
@@ -59,12 +59,37 @@ static void quirk_increase_ddi_disabled_
 	drm_info(&i915->drm, "Applying Increase DDI Disabled quirk\n");
 }
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+/*
+ * In some cases, the firmware might not set the lane count to 4 (for example,
+ * when booting in some dual GPU Macs with the dGPU as the default GPU), this
+ * quirk is used to force it as otherwise it might not be possible to compute a
+ * valid link configuration.
+ */
+static void quirk_ddi_a_force_4_lanes(struct drm_i915_private *i915)
+{
+	intel_set_quirk(i915, QUIRK_DDI_A_FORCE_4_LANES);
+	drm_info(&i915->drm, "Applying DDI A Forced 4 Lanes quirk\n");
+}
+#endif
+
 static void quirk_no_pps_backlight_power_hook(struct drm_i915_private *i915)
 {
 	intel_set_quirk(i915, QUIRK_NO_PPS_BACKLIGHT_POWER_HOOK);
 	drm_info(&i915->drm, "Applying no pps backlight power quirk\n");
 }
 
+#ifdef CONFIG_IGEL_I915_WYSE_3040_DP_QUIRK
+/* Dell Wyse 3040 doesn't work well with some Dell monitors (E-series).
+ * Workaround this by skipping DP DPMS D3 transition.
+ */
+static void quirk_disable_dp_dpms_d3(struct drm_i915_private *i915)
+{
+	intel_set_quirk(i915, QUIRK_SKIP_DP_DPMS_D3);
+	DRM_INFO("Applying Wyse 3040 quirk\n");
+}
+#endif
+
 struct intel_quirk {
 	int device;
 	int subsystem_vendor;
@@ -199,6 +224,14 @@ static struct intel_quirk intel_quirks[]
 	/* ECS Liva Q2 */
 	{ 0x3185, 0x1019, 0xa94d, quirk_increase_ddi_disabled_time },
 	{ 0x3184, 0x1019, 0xa94d, quirk_increase_ddi_disabled_time },
+#ifdef CONFIG_IGEL_I915_WYSE_3040_DP_QUIRK
+	/* Dell Wyse 3040 */
+	{ 0x22b0, 0x1028, 0x07c1, quirk_disable_dp_dpms_d3 },
+#endif
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	/* Apple MacBookPro15,1 */
+	{ 0x3e9b, 0x106b, 0x0176, quirk_ddi_a_force_4_lanes },
+#endif
 	/* HP Notebook - 14-r206nv */
 	{ 0x0f31, 0x103c, 0x220f, quirk_invert_brightness },
 };
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.h b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_quirks.h	2024-08-02 15:41:31.543491299 +0200
@@ -17,6 +17,9 @@ enum intel_quirk_id {
 	QUIRK_INVERT_BRIGHTNESS,
 	QUIRK_LVDS_SSC_DISABLE,
 	QUIRK_NO_PPS_BACKLIGHT_POWER_HOOK,
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	QUIRK_DDI_A_FORCE_4_LANES,
+#endif
 };
 
 void intel_init_quirks(struct drm_i915_private *i915);
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.c	2024-08-02 15:41:31.543491299 +0200
@@ -124,6 +124,13 @@ struct intel_sdvo {
 	 * the sdvo flag gets lost in round trip: dtd->adjusted_mode->dtd
 	 */
 	u8 dtd_sdvo_flags;
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+	/**
+	 * schneider@igel.com: Vendor registers for save/restore (suspend/resume)
+	 */
+	bool    vendor_regs_valid;
+	uint8_t vendor_regs[0x100-SDVO_I2C_VENDOR_BEGIN];
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
 };
 
 struct intel_sdvo_connector {
@@ -277,6 +284,32 @@ static bool intel_sdvo_read_byte(struct
 	return false;
 }
 
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+/* schneider@igel.com: intel_sdvo_write_byte allows to write single SDVO registers */
+static bool intel_sdvo_write_byte(struct intel_sdvo *intel_sdvo, u8 addr, u8 val)
+{
+	int ret;
+	uint8_t out_buf[2];
+	struct i2c_msg msg[] = {
+		{
+			.addr = intel_sdvo->slave_addr,
+			.flags = 0,
+			.len = 2,
+			.buf = out_buf,
+		}
+	};
+
+	out_buf[0] = addr;
+	out_buf[1] = val;
+
+	if ((ret = i2c_transfer(intel_sdvo->i2c, msg, 1)) == 1)
+		return true;
+
+	DRM_DEBUG_KMS("i2c WRITE transfer returned %d\n", ret);
+	return false;
+}
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
+
 #define SDVO_CMD_NAME_ENTRY(cmd_) { .cmd = SDVO_CMD_ ## cmd_, .name = #cmd_ }
 
 /** Mapping of command numbers to names, for debug output */
@@ -2179,6 +2212,19 @@ intel_sdvo_detect(struct drm_connector *
 		}
 	}
 
+#ifdef CONFIG_IGEL_LVDS_CONNECTED_ON_TC215
+	/* lang@igel.de: fix dual monitor with TC215 hardware */
+	if ((ret != connector_status_connected) &&
+	    (response & SDVO_LVDS_MASK)) {
+		struct intel_connector *intel_connector = to_intel_connector(connector);
+		if (intel_connector->panel.vbt.sdvo_lvds_vbt_mode != NULL) {
+			DRM_INFO("%s: set LVDS connector_status_connected "
+			  "- VBT mode available\n", SDVO_NAME(intel_sdvo));
+			ret = connector_status_connected;
+		}
+	}
+#endif
+
 	return ret;
 }
 
@@ -2489,6 +2535,78 @@ intel_sdvo_connector_unregister(struct d
 	intel_connector_unregister(connector);
 }
 
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+
+/* schneider@igel.com: SDVO register save function for given connector */
+static void intel_sdvo_connector_save(struct drm_connector *connector)
+{
+    struct intel_connector *intel_conn =
+    	   to_intel_connector(connector);
+    struct intel_sdvo *intel_sdvo = intel_attached_sdvo(intel_conn);
+    int i;
+
+	/* Read the vendor regs */
+    for (i = SDVO_I2C_VENDOR_BEGIN; i < 0x100; i++) {
+        if (!intel_sdvo_read_byte(intel_sdvo, i, &intel_sdvo->vendor_regs[i-SDVO_I2C_VENDOR_BEGIN])) {
+            DRM_DEBUG_KMS("No SDVO device found on %s\n",
+                    SDVO_NAME(intel_sdvo));
+            break;
+        }
+        DRM_DEBUG_KMS("%s: %s: REG 0x%02X=0x%02X [READ]\n", __FUNCTION__, SDVO_NAME(intel_sdvo), i, intel_sdvo->vendor_regs[i-SDVO_I2C_VENDOR_BEGIN]);
+    }
+    intel_sdvo->vendor_regs_valid = true;
+}
+
+/* schneider@igel.com: SDVO register save function */
+void intel_sdvo_save(struct drm_device *dev)
+{
+    struct drm_connector *connector;
+
+    list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+        if(connector->funcs->save == intel_sdvo_connector_save) {
+            intel_sdvo_connector_save(connector);
+        }
+    }
+}
+
+/* schneider@igel.com: SDVO register restore function for given connector */
+static void intel_sdvo_connector_restore(struct drm_connector* connector)
+{
+    struct intel_connector *intel_conn =
+    	   to_intel_connector(connector);
+    struct intel_sdvo *intel_sdvo = intel_attached_sdvo(intel_conn);
+    int i;
+
+    if(!intel_sdvo->vendor_regs_valid) {
+        DRM_DEBUG_KMS("SDVO %s vendor regs have not been saved bevore\n",
+                SDVO_NAME(intel_sdvo));
+        return;
+    }
+
+	/* Write back the vendor regs */
+    for (i = SDVO_I2C_VENDOR_BEGIN; i < 0x100; i++) {
+        if (!intel_sdvo_write_byte(intel_sdvo, i, intel_sdvo->vendor_regs[i-SDVO_I2C_VENDOR_BEGIN])) {
+            DRM_DEBUG_KMS("No SDVO device found on %s\n",
+                    SDVO_NAME(intel_sdvo));
+            break;
+        }
+        DRM_DEBUG_KMS("%s: %s: REG 0x%02X=0x%02X [WRITE]\n", __FUNCTION__, SDVO_NAME(intel_sdvo), i, intel_sdvo->vendor_regs[i-SDVO_I2C_VENDOR_BEGIN]);
+    }
+}
+
+/* schneider@igel.com: SDVO register restore function */
+void intel_sdvo_restore(struct drm_device *dev)
+{
+    struct drm_connector *connector;
+
+    list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+        if(connector->funcs->restore == intel_sdvo_connector_restore) {
+            intel_sdvo_connector_restore(connector);
+        }
+    }
+}
+# endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
+
 static struct drm_connector_state *
 intel_sdvo_connector_duplicate_state(struct drm_connector *connector)
 {
@@ -2512,6 +2630,10 @@ static const struct drm_connector_funcs
 	.destroy = intel_connector_destroy,
 	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
 	.atomic_duplicate_state = intel_sdvo_connector_duplicate_state,
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+	.save = intel_sdvo_connector_save, /* schneider@igel.com: SDVO suspend helper */
+	.restore = intel_sdvo_connector_restore, /* schneider@igel.com: SDVO resume helper */	
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
 };
 
 static int intel_sdvo_atomic_check(struct drm_connector *conn,
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.h b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_sdvo.h	2024-08-02 15:41:31.543491299 +0200
@@ -19,4 +19,9 @@ bool intel_sdvo_port_enabled(struct drm_
 bool intel_sdvo_init(struct drm_i915_private *dev_priv,
 		     i915_reg_t reg, enum port port);
 
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+extern void intel_sdvo_save(struct drm_device *dev); /* schneider@igel.com: SDVO suspend helper */
+extern void intel_sdvo_restore(struct drm_device *dev); /* schneider@igel.com: SDVO resume helper */
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
+
 #endif /* __INTEL_SDVO_H__ */
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_tv.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_tv.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_tv.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/display/intel_tv.c	2024-08-02 15:41:31.543491299 +0200
@@ -1948,6 +1948,14 @@ intel_tv_init(struct drm_i915_private *d
 		return;
 	}
 
+#ifdef CONFIG_IGEL_I915_DISABLE_TV_MODULE_OPTION
+	/* lang@igel.de: Skip init if TV is disabled */
+	if (! i915_modparams.tv) {
+		DRM_INFO("Integrated TV is disabled by module parameter\n");
+		return;
+	}
+#endif
+
 	/*
 	 * Sanity check the TV output by checking to see if the
 	 * DAC register holds a value
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/gt/uc/intel_uc_fw.c	2024-08-02 15:41:31.543491299 +0200
@@ -131,6 +131,19 @@ void intel_uc_fw_change_status(struct in
 	fw_def(BROXTON,      0, huc_mmp(bxt,  2, 0, 0)) \
 	fw_def(SKYLAKE,      0, huc_mmp(skl,  2, 0, 0))
 
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+/*
+ * The GSC FW has multiple version (see intel_gsc_uc.h for details); since what
+ * we care about is the interface, we use the compatibility version in the
+ * binary names.
+ * Same as with the GuC, a major version bump indicate a
+ * backward-incompatible change, while a minor version bump indicates a
+ * backward-compatible one, so we use only the former in the file name.
+ */
+#define INTEL_GSC_FIRMWARE_DEFS(fw_def, gsc_def) \
+	fw_def(METEORLAKE,   0, gsc_def(mtl, 1, 0))
+#endif
+
 /*
  * Set of macros for producing a list of filenames from the above table.
  */
@@ -166,6 +179,11 @@ void intel_uc_fw_change_status(struct in
 #define MAKE_HUC_FW_PATH_MMP(prefix_, major_, minor_, patch_) \
 	__MAKE_UC_FW_PATH_MMP(prefix_, "huc", major_, minor_, patch_)
 
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+#define MAKE_GSC_FW_PATH(prefix_, major_, minor_) \
+	__MAKE_UC_FW_PATH_MAJOR(prefix_, "gsc", major_)
+#endif
+
 /*
  * All blobs need to be declared via MODULE_FIRMWARE().
  * This first expansion of the table macros is solely to provide
@@ -176,6 +194,9 @@ void intel_uc_fw_change_status(struct in
 
 INTEL_GUC_FIRMWARE_DEFS(INTEL_UC_MODULE_FW, MAKE_GUC_FW_PATH_MAJOR, MAKE_GUC_FW_PATH_MMP)
 INTEL_HUC_FIRMWARE_DEFS(INTEL_UC_MODULE_FW, MAKE_HUC_FW_PATH_BLANK, MAKE_HUC_FW_PATH_MMP, MAKE_HUC_FW_PATH_GSC)
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+INTEL_GSC_FIRMWARE_DEFS(INTEL_UC_MODULE_FW, MAKE_GSC_FW_PATH)
+#endif
 
 /*
  * The next expansion of the table macros (in __uc_fw_auto_select below) provides
@@ -225,6 +246,12 @@ struct __packed uc_fw_blob {
 #define HUC_FW_BLOB_GSC(prefix_) \
 	UC_FW_BLOB_NEW(0, 0, 0, true, MAKE_HUC_FW_PATH_GSC(prefix_))
 
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+#define GSC_FW_BLOB(prefix_, major_, minor_) \
+	UC_FW_BLOB_NEW(major_, minor_, 0, true, \
+		       MAKE_GSC_FW_PATH(prefix_, major_, minor_))
+#endif
+
 struct __packed uc_fw_platform_requirement {
 	enum intel_platform p;
 	u8 rev; /* first platform rev using this FW */
@@ -251,9 +278,18 @@ static const struct uc_fw_platform_requi
 	INTEL_HUC_FIRMWARE_DEFS(MAKE_FW_LIST, HUC_FW_BLOB, HUC_FW_BLOB_MMP, HUC_FW_BLOB_GSC)
 };
 
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+static const struct uc_fw_platform_requirement blobs_gsc[] = {
+	INTEL_GSC_FIRMWARE_DEFS(MAKE_FW_LIST, GSC_FW_BLOB)
+};
+#endif
+
 static const struct fw_blobs_by_type blobs_all[INTEL_UC_FW_NUM_TYPES] = {
 	[INTEL_UC_FW_TYPE_GUC] = { blobs_guc, ARRAY_SIZE(blobs_guc) },
 	[INTEL_UC_FW_TYPE_HUC] = { blobs_huc, ARRAY_SIZE(blobs_huc) },
+#ifdef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
+	[INTEL_UC_FW_TYPE_GSC] = { blobs_gsc, ARRAY_SIZE(blobs_gsc) },
+#endif
 };
 
 static void
@@ -266,13 +302,15 @@ __uc_fw_auto_select(struct drm_i915_priv
 	int i;
 	bool found;
 
+#ifndef CONFIG_IGEL_I915_LOWER_METEOR_LAKE_POWER_CONSUMPTION
 	/*
-	 * GSC FW support is still not fully in place, so we're not defining
-	 * the FW blob yet because we don't want the driver to attempt to load
-	 * it until we're ready for it.
-	 */
+	* GSC FW support is still not fully in place, so we're not defining
+	* the FW blob yet because we don't want the driver to attempt to load
+	* it until we're ready for it.
+	*/
 	if (uc_fw->type == INTEL_UC_FW_TYPE_GSC)
 		return;
+#endif
 
 	/*
 	 * The only difference between the ADL GuC FWs is the HWConfig support.
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_drv.h b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_drv.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_drv.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_drv.h	2024-08-02 15:41:31.543491299 +0200
@@ -64,11 +64,27 @@
 #include "intel_step.h"
 #include "intel_uncore.h"
 
+#ifdef CONFIG_IGEL_ADD_I915_HW_DETECTION
+/* nagel@igel.com: define enum for IGEL platforms,
+ * that require special treatment. */
+enum igel_platforms {
+	NO_IGEL_PLATFORM = -1,
+	IGEL_H830C,
+	IGEL_TC215B
+};
+extern enum igel_platforms igel_platform;
+#define IS_IGEL_H830C (igel_platform==IGEL_H830C)
+#define IS_IGEL_TC215B (igel_platform==IGEL_TC215B)
+#endif
+
 struct drm_i915_clock_gating_funcs;
 struct vlv_s0ix_state;
 struct intel_pxp;
 
 #define GEM_QUIRK_PIN_SWIZZLED_PAGES	BIT(0)
+#ifdef CONFIG_IGEL_I915_WYSE_3040_DP_QUIRK
+#define QUIRK_SKIP_DP_DPMS_D3 (1<<15)
+#endif
 
 /* Data Stolen Memory (DSM) aka "i915 stolen memory" */
 struct i915_dsm {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.c	2024-08-02 15:41:31.543491299 +0200
@@ -130,7 +130,11 @@ i915_param_named_unsafe(force_probe, cha
 
 i915_param_named_unsafe(disable_power_well, int, 0400,
 	"Disable display power wells when possible "
+#ifdef CONFIG_IGEL_I915_CHANGE_DEFAULT_POWER_WELL_OPTION
+	"(-1=auto, 0=power wells always on [default], 1=power wells disabled when possible)");
+#else
 	"(-1=auto [default], 0=power wells always on, 1=power wells disabled when possible)");
+#endif
 
 i915_param_named_unsafe(enable_ips, int, 0400, "Enable IPS (default: true)");
 
@@ -228,6 +232,55 @@ i915_param_named_unsafe(lmem_size, uint,
 i915_param_named_unsafe(lmem_bar_size, uint, 0400,
 			"Set the lmem bar size(in MiB).");
 
+#ifdef CONFIG_IGEL_I915_DISABLE_LVDS_MODULE_OPTION
+i915_param_named(lvds, int, 0444,
+	"LVDS enable (0 = disable)");
+#endif
+
+#ifdef CONFIG_IGEL_I915_DISABLE_TV_MODULE_OPTION
+i915_param_named(tv, int, 0444,
+	"TV enable (0 = disable)");
+#endif
+
+#ifdef CONFIG_IGEL_I915_EDP_IS_DP_MODULE_OPTION
+/* gottwald@igel.com: sometimes a dp is wrongly detected as edp which makes
+ * problems with hotplug. Try to determine this automatically failed so
+ * added module param to fix this. */
+i915_param_named(edp_is_dp, bool, 0444,
+	"eDP is DP (0 = disable, 1 = edp is dp)");
+#endif
+
+#ifdef CONFIG_IGEL_I915_ADD_LIMIT_DP_RATE_OPTION
+/* gottwald@igel.com: sometimes the max dp link speed is not detected correctly
+ * to prevent black screen issues this parameter can be used to limit the
+ * max DisplayPort link speed */
+i915_param_named(limit_dp_max_rate, int, 0644,
+	"DP port max link rate (0 = not set (default), 162000, 216000, 270000, 324000, 432000, 540000, 648000, 810000)");
+#endif
+
+/* gottwald@igel.com: some devices have problems with higher resolutions and
+ * DP audio where the screen will get black if the DP audio get initialized
+ * to be able to work around this you can use this option to disable DP audio.
+ * Add the same option for HDMI also just to be sure... */
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_DP_AUDIO_OPTION
+i915_param_named(disable_dp_audio, bool, 0644,
+	"Disable DP audio support (0 = audio enabled (default), 1 audio disabled)");
+#endif
+#ifdef CONFIG_IGEL_I915_ADD_DISABLE_HDMI_AUDIO_OPTION
+i915_param_named(disable_hdmi_audio, bool, 0644,
+	"Disable HDMI audio support (0 = audio enabled (default), 1 audio disabled)");
+#endif
+#ifdef CONFIG_IGEL_I915_ADD_M250C_NO_LIMITED_COLOR_RANGE_OPTION
+/* gottwald@igel.com: M250C workaround to fix color space limit problems */
+i915_param_named(m250c_no_limited_color_range, bool, 0444,
+	"Do not use limited color range for DP1 on M250C (0 = not set (default), 1 = do not use limited color range)");
+#endif
+
+#ifdef CONFIG_IGEL_I915_ADD_OPTION_TO_CHANGE_CONNECTOR_ENUM_ORDER
+i915_param_named(reverse_enum_order, bool, 0444,
+	"Reverse connector enumeration order (0 = not set (default), 1 = do not use limited color range)");
+#endif
+
 static void _param_print_bool(struct drm_printer *p, const char *name,
 			      bool val)
 {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.h b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_params.h	2024-08-02 15:41:31.543491299 +0200
@@ -30,6 +30,12 @@
 
 struct drm_printer;
 
+#ifdef CONFIG_IGEL_I915_CHANGE_DEFAULT_POWER_WELL_OPTION
+#define POWER_WELL_DEFAULT 0
+#else
+#define POWER_WELL_DEFAULT -1
+#endif
+
 #define ENABLE_GUC_SUBMISSION		BIT(0)
 #define ENABLE_GUC_LOAD_HUC		BIT(1)
 #define ENABLE_GUC_MASK			GENMASK(1, 0)
@@ -45,6 +51,59 @@ struct drm_printer;
  * mode: debugfs file permissions, one of {0400, 0600, 0}, use 0 to not create
  *       debugfs file
  */
+#ifndef CONFIG_IGEL_I915_CHANGE_DEFAULT_POWER_WELL_OPTION
+#define I915_PARAMS_FOR_EACH(param) \
+	param(char *, vbt_firmware, NULL, 0400) \
+	param(int, modeset, -1, 0400) \
+	param(int, lvds_channel_mode, 0, 0400) \
+	param(int, panel_use_ssc, -1, 0600) \
+	param(int, vbt_sdvo_panel_type, -1, 0400) \
+	param(int, enable_dc, -1, 0400) \
+	param(int, enable_fbc, -1, 0600) \
+	param(int, enable_psr, -1, 0600) \
+	param(bool, enable_dpt, true, 0400) \
+	param(bool, psr_safest_params, false, 0400) \
+	param(bool, enable_psr2_sel_fetch, true, 0400) \
+	param(bool, enable_sagv, true, 0600) \
+	param(int, disable_power_well, POWER_WELL_DEFAULT, 0400) \
+	param(int, enable_ips, 1, 0600) \
+	param(int, invert_brightness, 0, 0600) \
+	param(int, enable_guc, -1, 0400) \
+	param(int, guc_log_level, -1, 0400) \
+	param(char *, guc_firmware_path, NULL, 0400) \
+	param(char *, huc_firmware_path, NULL, 0400) \
+	param(char *, dmc_firmware_path, NULL, 0400) \
+	param(char *, gsc_firmware_path, NULL, 0400) \
+	param(bool, memtest, false, 0400) \
+	param(int, mmio_debug, -IS_ENABLED(CONFIG_DRM_I915_DEBUG_MMIO), 0600) \
+	param(int, edp_vswing, 0, 0400) \
+	param(unsigned int, reset, 3, 0600) \
+	param(unsigned int, inject_probe_failure, 0, 0) \
+	param(int, fastboot, -1, 0600) \
+	param(int, enable_dpcd_backlight, -1, 0600) \
+	param(char *, force_probe, CONFIG_DRM_I915_FORCE_PROBE, 0400) \
+	param(unsigned int, request_timeout_ms, CONFIG_DRM_I915_REQUEST_TIMEOUT, CONFIG_DRM_I915_REQUEST_TIMEOUT ? 0600 : 0) \
+	param(unsigned int, lmem_size, 0, 0400) \
+	param(unsigned int, lmem_bar_size, 0, 0400) \
+	/* leave bools at the end to not create holes */ \
+	param(bool, enable_hangcheck, true, 0600) \
+	param(bool, load_detect_test, false, 0600) \
+	param(bool, force_reset_modeset_test, false, 0600) \
+	param(bool, error_capture, true, IS_ENABLED(CONFIG_DRM_I915_CAPTURE_ERROR) ? 0600 : 0) \
+	param(bool, disable_display, false, 0400) \
+	param(bool, verbose_state_checks, true, 0) \
+	param(bool, nuclear_pageflip, false, 0400) \
+	param(bool, enable_dp_mst, true, 0600) \
+	param(bool, enable_gvt, false, IS_ENABLED(CONFIG_DRM_I915_GVT) ? 0400 : 0) \
+	param(unsigned int, lvds, 1, 0400) \
+	param(unsigned int, tv, 1, 0400) \
+	param(bool, edp_is_dp, false, 0400) \
+	param(unsigned int, limit_dp_max_rate, 0, 0400) \
+	param(bool, disable_dp_audio, false, 0400) \
+	param(bool, disable_hdmi_audio, false, 0400) \
+	param(bool, m250c_no_limited_color_range, false, 0400) \
+	param(bool, reverse_enum_order, false, 0400)
+#else
 #define I915_PARAMS_FOR_EACH(param) \
 	param(char *, vbt_firmware, NULL, 0400) \
 	param(int, modeset, -1, 0400) \
@@ -58,7 +117,7 @@ struct drm_printer;
 	param(bool, psr_safest_params, false, 0400) \
 	param(bool, enable_psr2_sel_fetch, true, 0400) \
 	param(bool, enable_sagv, true, 0600) \
-	param(int, disable_power_well, -1, 0400) \
+	param(int, disable_power_well, POWER_WELL_DEFAULT, 0400) \
 	param(int, enable_ips, 1, 0600) \
 	param(int, invert_brightness, 0, 0600) \
 	param(int, enable_guc, -1, 0400) \
@@ -87,7 +146,16 @@ struct drm_printer;
 	param(bool, verbose_state_checks, true, 0) \
 	param(bool, nuclear_pageflip, false, 0400) \
 	param(bool, enable_dp_mst, true, 0600) \
-	param(bool, enable_gvt, false, IS_ENABLED(CONFIG_DRM_I915_GVT) ? 0400 : 0)
+	param(bool, enable_gvt, false, IS_ENABLED(CONFIG_DRM_I915_GVT) ? 0400 : 0) \
+	param(unsigned int, lvds, 1, 0400) \
+	param(unsigned int, tv, 1, 0400) \
+	param(bool, edp_is_dp, false, 0400) \
+	param(unsigned int, limit_dp_max_rate, 0, 0400) \
+	param(bool, disable_dp_audio, false, 0400) \
+	param(bool, disable_hdmi_audio, false, 0400) \
+	param(bool, m250c_no_limited_color_range, false, 0400) \
+	param(bool, reverse_enum_order, false, 0400)
+#endif
 
 #define MEMBER(T, member, ...) T member;
 struct i915_params {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_pci.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_pci.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_pci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_pci.c	2024-08-02 15:41:31.543491299 +0200
@@ -22,6 +22,10 @@
  *
  */
 
+#ifdef CONFIG_IGEL_ADD_I915_HW_DETECTION
+#include <linux/dmi.h>
+#endif
+
 #include <drm/drm_color_mgmt.h>
 #include <drm/drm_drv.h>
 #include <drm/i915_pciids.h>
@@ -38,6 +42,10 @@
 #include "i915_reg.h"
 #include "intel_pci_config.h"
 
+#ifdef CONFIG_IGEL_ADD_I915_HW_DETECTION
+enum igel_platforms igel_platform = NO_IGEL_PLATFORM;
+#endif
+
 #define PLATFORM(x) .platform = (x)
 #define GEN(x) \
 	.__runtime.graphics.ip.ver = (x), \
@@ -837,7 +845,11 @@ static const struct intel_device_info mt
 	.has_pxp = 1,
 	.memory_regions = REGION_SMEM | REGION_STOLEN_LMEM,
 	.platform_engine_mask = BIT(RCS0) | BIT(BCS0) | BIT(CCS0),
+#ifdef CONFIG_IGEL_I915_ENABLE_METEOR_LAKE
+	.require_force_probe = 0,
+#else
 	.require_force_probe = 1,
+#endif
 	MTL_CACHELEVEL,
 };
 
@@ -1093,6 +1105,20 @@ static struct pci_driver i915_pci_driver
 
 int i915_pci_register_driver(void)
 {
+#ifdef CONFIG_IGEL_ADD_I915_HW_DETECTION
+	const char *product;
+	product = dmi_get_system_info(DMI_PRODUCT_NAME);
+
+	igel_platform = NO_IGEL_PLATFORM;
+
+	if (product != NULL) {
+		/* gottwald@igel.com Detect IGEL platform according to the DMI data */
+		if (strstr(product, "TC215B"))
+			igel_platform = IGEL_TC215B;
+		else if (strstr(product, "H830C"))
+			igel_platform = IGEL_H830C;
+	}
+#endif
 	return pci_register_driver(&i915_pci_driver);
 }
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_suspend.c b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_suspend.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_suspend.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/i915/i915_suspend.c	2024-08-02 15:41:31.543491299 +0200
@@ -27,6 +27,9 @@
 #include "display/intel_de.h"
 #include "display/intel_gmbus.h"
 #include "display/intel_vga.h"
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+#include "display/intel_sdvo.h"
+#endif
 
 #include "i915_drv.h"
 #include "i915_reg.h"
@@ -37,6 +40,11 @@ static void intel_save_swf(struct drm_i9
 {
 	int i;
 
+	/* schneider@igel.com: SDVO state save */
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+	intel_sdvo_save(&dev_priv->drm);
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
+
 	/* Scratch space */
 	if (GRAPHICS_VER(dev_priv) == 2 && IS_MOBILE(dev_priv)) {
 		for (i = 0; i < 7; i++) {
@@ -62,6 +70,11 @@ static void intel_restore_swf(struct drm
 {
 	int i;
 
+	/* schneider@igel.com: SDVO state save */
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+	intel_sdvo_restore(&dev_priv->drm);
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
+
 	/* Scratch space */
 	if (GRAPHICS_VER(dev_priv) == 2 && IS_MOBILE(dev_priv)) {
 		for (i = 0; i < 7; i++) {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/atombios_dp.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/atombios_dp.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/atombios_dp.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/atombios_dp.c	2024-08-02 15:41:31.543491299 +0200
@@ -358,11 +358,37 @@ static u8 radeon_dp_encoder_service(stru
 	return args.ucStatus;
 }
 
+#ifdef CONFIG_IGEL_RADEON_SINK_POWER_ON_QUIRK
+/* lang@igel: If the sink supports it, try to set the power state */
+static void radeon_dp_sink_power_on(struct radeon_connector *radeon_connector)
+{
+	int ret, i;
+	u16 reg = DP_SET_POWER;
+	u8 val = DP_SET_POWER_D0;
+
+	/*
+	 * When turning on, we need to retry for 1ms to give the sink
+	 * time to wake up.
+	 */
+	for (i = 0; i < 3; i++) {
+		ret = drm_dp_dpcd_writeb(&radeon_connector->ddc_bus->aux, reg, val);
+		if (ret == 1)
+			break;
+		msleep(1);
+	}
+}
+#endif
+
 u8 radeon_dp_getsinktype(struct radeon_connector *radeon_connector)
 {
 	struct drm_device *dev = radeon_connector->base.dev;
 	struct radeon_device *rdev = dev->dev_private;
 
+#ifdef CONFIG_IGEL_RADEON_SINK_POWER_ON_QUIRK
+	/* lang@igel: power up the sink */
+	radeon_dp_sink_power_on(radeon_connector);
+#endif
+
 	return radeon_dp_encoder_service(rdev, ATOM_DP_ACTION_GET_SINK_TYPE, 0,
 					 radeon_connector->ddc_bus->rec.i2c_id, 0);
 }
@@ -828,6 +854,11 @@ void radeon_dp_link_train(struct drm_enc
 	else
 		dp_info.enc_id |= ATOM_DP_CONFIG_LINK_A;
 
+#ifdef CONFIG_IGEL_RADEON_SINK_POWER_ON_QUIRK
+	/* lang@igel: power up the sink */
+	radeon_dp_sink_power_on(radeon_connector);
+#endif
+
 	if (drm_dp_dpcd_readb(&radeon_connector->ddc_bus->aux, DP_MAX_LANE_COUNT, &tmp)
 	    == 1) {
 		if (ASIC_IS_DCE5(rdev) && (tmp & DP_TPS3_SUPPORTED))
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_atombios.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_atombios.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_atombios.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_atombios.c	2024-08-02 15:41:31.543491299 +0200
@@ -30,7 +30,10 @@
 #include <drm/radeon_drm.h>
 
 #include "radeon.h"
-
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+#include "radeon_drv.h"
+#include <linux/dmi.h>
+#endif
 #include "atom.h"
 #include "atom-bits.h"
 #include "radeon_asic.h"
@@ -286,6 +289,18 @@ static bool radeon_atom_apply_quirks(str
 {
 	struct pci_dev *pdev = to_pci_dev(dev->dev);
 
+#if defined(CONFIG_IGEL_RADEON_DETECTION) || defined(CONFIG_IGEL_FUJITSU_DVI_VGA_SPLIT_QUIRKS)
+	const char *product;
+#endif
+#ifdef CONFIG_IGEL_RADEON_LVDS_SWITCH
+	/* lang@igel.de:
+	   if the user selected lvds=0 don't try and add the connector */
+	if ((*connector_type == DRM_MODE_CONNECTOR_LVDS) &&
+	    (radeon_lvds == 0)) {
+		DRM_INFO("apply quirk: LVDS is disabled by module parameter\n");
+		return false;
+	}
+#endif
 	/* Asus M2A-VM HDMI board lists the DVI port as HDMI */
 	if ((pdev->device == 0x791e) &&
 	    (pdev->subsystem_vendor == 0x1043) &&
@@ -449,6 +464,42 @@ static bool radeon_atom_apply_quirks(str
 		}
 	}
 
+#ifdef CONFIG_IGEL_FUJITSU_DVI_VGA_SPLIT_QUIRKS
+	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */
+	if ((pdev->device == 0x9805) &&
+	    (pdev->subsystem_vendor == 0x1734) &&
+	    (pdev->subsystem_device == 0x11bd)) {
+		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
+			/* gottwald@igel.com limit this only to the board which is mentioned in the 
+			 * BUG report https://bugs.freedesktop.org/show_bug.cgi?id=83184
+			 * this should fix the non working VGA port on Futro S700 devices */
+			product = dmi_get_system_info(DMI_BOARD_NAME);
+			if (product != NULL)
+				if (strstr(product, "D3003-S1"))
+					return false;
+		}
+	}
+#endif
+#ifdef CONFIG_IGEL_M340C_DVI_VGA_SPLIT_QUIRKS
+	/* Handle IGEL M340C outputs correctly */
+	if ((pdev->device == 0x9854) &&
+	    (pdev->subsystem_vendor == 0x1002) &&
+	    (pdev->subsystem_device == 0x9854)) {
+		if (! IS_IGEL_M340C) {
+			product = dmi_get_system_info(DMI_BOARD_NAME);
+			if (product != NULL)
+				if (strstr(product, "M340C")) 
+					igel_platform = IGEL_M340C;
+		}
+	}
+
+	if (IS_IGEL_M340C) {
+		if ((*connector_type == DRM_MODE_CONNECTOR_DisplayPort) &&
+		    (supported_device == ATOM_DEVICE_DFP2_SUPPORT) ) {
+			*connector_type = DRM_MODE_CONNECTOR_DVID;
+		}
+	}
+#endif
 	return true;
 }
 
@@ -820,7 +871,12 @@ bool radeon_get_atom_connector_info_from
 						  igp_lane_info,
 						  connector_object_id,
 						  &hpd,
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+						  &router,
+						  0);
+#else
 						  &router);
+#endif
 
 		}
 	}
@@ -878,6 +934,9 @@ struct bios_connector {
 	int connector_type;
 	struct radeon_i2c_bus_rec ddc_bus;
 	struct radeon_hpd hpd;
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	int splitted_dvii;
+#endif
 };
 
 bool radeon_get_atom_connector_info_from_supported_devices_table(struct
@@ -1046,6 +1105,33 @@ bool radeon_get_atom_connector_info_from
 						     (bios_connectors[j].devices & (ATOM_DEVICE_CRT_SUPPORT))) ||
 						    ((bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT)) &&
 						     (bios_connectors[i].devices & (ATOM_DEVICE_CRT_SUPPORT)))) {
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+							/* lang@igel: split DVI-I connector in analog + digital connector */
+							if (radeon_split_dvii) {
+								if (bios_connectors[i].splitted_dvii &&
+								bios_connectors[j].splitted_dvii)
+									continue;
+								DRM_INFO("split DVI-I connector in separate "
+								 "analog and digital connectors\n");
+								bios_connectors[i].splitted_dvii = 1;
+								bios_connectors[j].splitted_dvii = 1;
+								bios_connectors[i].connector_type = DRM_MODE_CONNECTOR_DVII;
+								bios_connectors[j].connector_type = DRM_MODE_CONNECTOR_DVII;
+								if (bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT))
+								bios_connectors[i].hpd = bios_connectors[j].hpd;
+								if (bios_connectors[i].devices & (ATOM_DEVICE_DFP_SUPPORT))
+								bios_connectors[j].hpd = bios_connectors[i].hpd;
+							} else {
+								bios_connectors[i].devices |=
+									bios_connectors[j].devices;
+								bios_connectors[i].connector_type =
+									DRM_MODE_CONNECTOR_DVII;
+								if (bios_connectors[j].devices & (ATOM_DEVICE_DFP_SUPPORT))
+									bios_connectors[i].hpd =
+										bios_connectors[j].hpd;
+								bios_connectors[j].valid = false;
+							}
+#else
 							bios_connectors[i].devices |=
 								bios_connectors[j].devices;
 							bios_connectors[i].connector_type =
@@ -1054,6 +1140,7 @@ bool radeon_get_atom_connector_info_from
 								bios_connectors[i].hpd =
 									bios_connectors[j].hpd;
 							bios_connectors[j].valid = false;
+#endif
 						}
 					}
 				}
@@ -1077,7 +1164,12 @@ bool radeon_get_atom_connector_info_from
 						  0,
 						  connector_object_id,
 						  &bios_connectors[i].hpd,
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+						  &router,
+						  bios_connectors[i].splitted_dvii);
+#else
 						  &router);
+#endif
 		}
 	}
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_connectors.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_connectors.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_connectors.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_connectors.c	2024-08-02 15:41:31.547491394 +0200
@@ -31,18 +31,45 @@
 #include <drm/drm_probe_helper.h>
 #include <drm/radeon_drm.h>
 #include "radeon.h"
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+#include "radeon_drv.h"
+#endif
 #include "radeon_audio.h"
 #include "atom.h"
 
 #include <linux/pm_runtime.h>
 #include <linux/vga_switcheroo.h>
+#ifdef CONFIG_IGEL_SAMSUNG_TC2_DVI_VGA_QUIRK
+#include <linux/pci.h>
+#endif
 
 void radeon_connector_hotplug(struct drm_connector *connector)
 {
 	struct drm_device *dev = connector->dev;
 	struct radeon_device *rdev = dev->dev_private;
 	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+#ifdef CONFIG_IGEL_RADEON_FIX_CONNECTOR_STATUS
+	enum drm_connector_status status;
+#endif
+
+#ifdef CONFIG_IGEL_RADEON_FIX_CONNECTOR_STATUS
+	/* gottwald@igel.com update status of connector */
+
+	status = connector->status;
+
+	if (connector->force) {
+		if (connector->force == DRM_FORCE_ON)
+			connector->status = connector_status_connected;
+		else
+			connector->status = connector_status_disconnected;
+		if (connector->funcs->force)
+			connector->funcs->force(connector);
+	}
 
+	if (connector->status == connector_status_disconnected) {
+		drm_connector_update_edid_property(connector, NULL);
+	}
+#endif
 	/* bail if the connector does not have hpd pin, e.g.,
 	 * VGA, TV, etc.
 	 */
@@ -73,6 +100,20 @@ void radeon_connector_hotplug(struct drm
 		if (dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT &&
 		    radeon_hpd_sense(rdev, radeon_connector->hpd.hpd) &&
 		    radeon_dp_needs_link_train(radeon_connector)) {
+#ifdef CONFIG_IGEL_RADEON_FIX_CONNECTOR_STATUS
+			/*
+			 * lang@igel:
+			 * fix monitor dpms on, when connector is disconnected 
+			 */
+			if (connector->status != connector_status_connected)  {
+				enum drm_connector_status new_status;
+
+				new_status = connector->funcs->detect(connector, false);
+				DRM_INFO("run %s detection during hotplug: %s\n", 
+					 connector->name,
+					 drm_get_connector_status_name(new_status));
+			}
+#endif
 			/* Don't start link training before we have the DPCD */
 			if (!radeon_dp_getdpcd(radeon_connector))
 				return;
@@ -1271,6 +1312,12 @@ radeon_dvi_detect(struct drm_connector *
 		radeon_connector->detected_by_load = false;
 		radeon_connector_free_edid(connector);
 		radeon_connector_get_edid(connector);
+#ifdef CONFIG_IGEL_RADEON_FIX_CONNECTOR_STATUS
+		if (!radeon_connector->edid) {
+			msleep(500);
+			radeon_connector_get_edid(connector);
+		}
+#endif
 
 		if (!radeon_connector->edid) {
 			DRM_ERROR("%s: probed a monitor but no|invalid EDID\n",
@@ -1294,9 +1341,18 @@ radeon_dvi_detect(struct drm_connector *
 			/* some oems have boards with separate digital and analog connectors
 			 * with a shared ddc line (often vga + hdmi)
 			 */
+#ifdef CONFIG_IGEL_M340C_DVI_VGA_SPLIT_QUIRKS
+			if ((!radeon_connector->use_digital) &&
+			    (radeon_connector->shared_ddc || IS_IGEL_M340C)) {
+#else
 			if ((!radeon_connector->use_digital) && radeon_connector->shared_ddc) {
+#endif
 				radeon_connector_free_edid(connector);
 				ret = connector_status_disconnected;
+#ifdef CONFIG_IGEL_M340C_DVI_VGA_SPLIT_QUIRKS
+				if (IS_IGEL_M340C)
+					goto out;
+#endif
 			} else {
 				ret = connector_status_connected;
 			}
@@ -1329,6 +1385,21 @@ radeon_dvi_detect(struct drm_connector *
 		}
 	}
 
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	/* lang@igel: split DVI-I connector in analog + digital connector:
+	   check if EDID fits to device type */
+	if (radeon_connector->splitted_dvii && (ret == connector_status_connected)) {
+		if ( (radeon_connector->use_digital && 
+		      ((radeon_connector->devices & (ATOM_DEVICE_DFP_SUPPORT)) == 0)) ||
+		     (! radeon_connector->use_digital && 
+		      ((radeon_connector->devices & (ATOM_DEVICE_CRT_SUPPORT)) == 0)) )
+			ret = connector_status_disconnected;
+	}
+	/* lang@igel: reset detected_by_load flag after EDID check */
+	if (radeon_connector->splitted_dvii && (ret == connector_status_connected))
+		radeon_connector->detected_by_load = false;
+#endif
+
 	if ((ret == connector_status_connected) && (radeon_connector->use_digital == true))
 		goto out;
 
@@ -1347,6 +1418,17 @@ radeon_dvi_detect(struct drm_connector *
 		goto out;
 	}
 
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	/* lang@igel: split DVI-I connector in analog + digital connector:
+	   never do destructive polling, you can see a black screen on analog output */
+	if (radeon_connector->splitted_dvii &&
+	    radeon_connector->detected_by_load &&
+	    (connector->status == connector_status_connected)) {
+		ret = connector->status;
+		goto out;
+	}
+#endif
+
 	/* find analog encoder */
 	if (radeon_connector->dac_load_detect) {
 		drm_connector_for_each_possible_encoder(connector, encoder) {
@@ -1655,6 +1737,32 @@ radeon_dp_detect(struct drm_connector *c
 		goto out;
 	}
 
+#ifdef CONFIG_IGEL_RADEON_DP_DVI_ADAPTER_PROBE_WORKAROUND
+	if (radeon_dp_dvi_probe_workaround != 0 &&
+	    connector->connector_type == DRM_MODE_CONNECTOR_DisplayPort &&
+	    radeon_dig_connector->dp_sink_type != CONNECTOR_OBJECT_ID_DISPLAYPORT) {
+		if (connector->dpms == DRM_MODE_DPMS_OFF) {
+			ret = connector->status;
+			goto out;
+		} else {
+			msleep(200);
+			radeon_connector_free_edid(connector);
+			/* try non-aux ddc (DP to DVI/HDMI/etc. adapter) */
+			if (radeon_ddc_probe(radeon_connector, false)) {
+				ret = connector_status_connected;
+				radeon_connector_update_scratch_regs(connector, ret);
+
+				radeon_connector_get_edid(connector);
+				if ((radeon_audio != 0) && encoder) {
+					radeon_audio_detect(connector, encoder, ret);
+				}
+
+				goto out;
+			}
+		}
+	}
+#endif
+
 	radeon_connector_free_edid(connector);
 
 	if ((connector->connector_type == DRM_MODE_CONNECTOR_eDP) ||
@@ -1704,8 +1812,18 @@ radeon_dp_detect(struct drm_connector *c
 		radeon_dig_connector->dp_sink_type = radeon_dp_getsinktype(radeon_connector);
 		if (radeon_hpd_sense(rdev, radeon_connector->hpd.hpd)) {
 			ret = connector_status_connected;
-			if (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)
+			if (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {
+#ifdef CONFIG_IGEL_RADEON_FIX_CONNECTOR_STATUS
+				/* lang@igel: if we do not get dpcd, the connector should be disconnected */
+				if (! radeon_dp_getdpcd(radeon_connector)) {
+					msleep(200);
+					if (! radeon_dp_getdpcd(radeon_connector))
+						ret = connector_status_disconnected;
+				}
+#else
 				radeon_dp_getdpcd(radeon_connector);
+#endif
+			}
 		} else {
 			if (radeon_dig_connector->dp_sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT) {
 				if (radeon_dp_getdpcd(radeon_connector))
@@ -1833,7 +1951,12 @@ radeon_add_atom_connector(struct drm_dev
 			  uint32_t igp_lane_info,
 			  uint16_t connector_object_id,
 			  struct radeon_hpd *hpd,
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+			  struct radeon_router *router,
+			  int splitted_dvii)
+#else
 			  struct radeon_router *router)
+#endif
 {
 	struct radeon_device *rdev = dev->dev_private;
 	struct drm_connector *connector;
@@ -1846,6 +1969,12 @@ radeon_add_atom_connector(struct drm_dev
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
 	bool has_aux = false;
+#ifdef CONFIG_IGEL_SAMSUNG_TC2_DVI_VGA_QUIRK
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+#endif
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	bool dvii_shared = false;
+#endif
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
 		return;
@@ -1857,15 +1986,41 @@ radeon_add_atom_connector(struct drm_dev
 	    (radeon_tv == 0))
 		return;
 
+#ifdef CONFIG_IGEL_SAMSUNG_TC2_DVI_VGA_QUIRK
+	if (connector_type == DRM_MODE_CONNECTOR_VGA) {
+		/* gottwald@igel.com Samsung NC241, NC221 and TC2 workaround to not detect DVI monitor also as VGA */
+		if ((pdev->device == 0x9856 || pdev->device == 0x9851) &&
+		    (pdev->subsystem_vendor == 0x1022) &&
+		    (pdev->subsystem_device == 0x1234)) {
+			list_for_each_entry(connector, &dev->mode_config.connector_list, head)
+				if (connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+					dvii_shared = true;
+		} else if (IS_SAMSUNG_TC2) {
+			list_for_each_entry(connector, &dev->mode_config.connector_list, head)
+				if (connector->connector_type == DRM_MODE_CONNECTOR_DVII)
+					dvii_shared = true;
+		}
+	}
+#endif
 	/* see if we already added it */
 	list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
 		radeon_connector = to_radeon_connector(connector);
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+		if ((radeon_connector->connector_id == connector_id) &&
+		     ! splitted_dvii) {
+#else
 		if (radeon_connector->connector_id == connector_id) {
+#endif
 			radeon_connector->devices |= supported_device;
 			return;
 		}
 		if (radeon_connector->ddc_bus && i2c_bus->valid) {
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+			if (((radeon_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) 
+			      || dvii_shared) && ! splitted_dvii) {
+#else
 			if (radeon_connector->ddc_bus->rec.i2c_id == i2c_bus->i2c_id) {
+#endif
 				radeon_connector->shared_ddc = true;
 				shared_ddc = true;
 			}
@@ -1903,6 +2058,9 @@ radeon_add_atom_connector(struct drm_dev
 	radeon_connector->shared_ddc = shared_ddc;
 	radeon_connector->connector_object_id = connector_object_id;
 	radeon_connector->hpd = *hpd;
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	radeon_connector->splitted_dvii = splitted_dvii;
+#endif
 
 	radeon_connector->router = *router;
 	if (router->ddc_valid || router->cd_valid) {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_device.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_device.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_device.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_device.c	2024-08-02 15:41:31.547491394 +0200
@@ -1659,6 +1659,9 @@ int radeon_resume_kms(struct drm_device
 	struct pci_dev *pdev = to_pci_dev(dev->dev);
 	struct drm_crtc *crtc;
 	int r;
+#ifdef CONFIG_IGEL_RADEON_FIX_CURSOR_DISAPPEAR
+	int i;
+#endif
 
 	if (dev->switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
@@ -1735,9 +1738,24 @@ int radeon_resume_kms(struct drm_device
 	/* blat the mode back in */
 	if (fbcon) {
 		drm_helper_resume_force_mode(dev);
+#ifdef CONFIG_IGEL_RADEON_FIX_CURSOR_DISAPPEAR
+		/* lang@igel: reinitialize cursors */
+		for (i = 0; i < rdev->num_crtc; i++) {
+			if (rdev->mode_info.crtcs[i]) {
+				radeon_cursor_reset(&rdev->mode_info.crtcs[i]->base);
+			}
+		}
+#endif
 		/* turn on display hw */
 		drm_modeset_lock_all(dev);
 		list_for_each_entry(connector, &dev->mode_config.connector_list, head) {
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+			/* lang@igel: reset detected_by_load, so the the connector is probed again */
+			struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+
+			if (radeon_connector && radeon_connector->splitted_dvii)
+				radeon_connector->detected_by_load = false;
+#endif
 			drm_helper_connector_dpms(connector, DRM_MODE_DPMS_ON);
 		}
 		drm_modeset_unlock_all(dev);
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_display.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_display.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_display.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_display.c	2024-08-02 15:41:31.547491394 +0200
@@ -713,6 +713,11 @@ static void radeon_crtc_init(struct drm_
 		radeon_atombios_init_crtc(dev, radeon_crtc);
 	else
 		radeon_legacy_init_crtc(dev, radeon_crtc);
+
+#ifdef CONFIG_IGEL_RADEON_FIX_CURSOR_DISAPPEAR
+	/* lang@igel: initialize cursor registers */
+	radeon_crtc_cursor_set2(&radeon_crtc->base, NULL, 0, 0, 0, 0, 0);
+#endif
 }
 
 static const char *encoder_names[38] = {
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.c b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.c	2024-08-02 15:41:31.547491394 +0200
@@ -36,6 +36,9 @@
 #include <linux/vga_switcheroo.h>
 #include <linux/mmu_notifier.h>
 #include <linux/pci.h>
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+#include <linux/dmi.h>
+#endif
 
 #include <drm/drm_aperture.h>
 #include <drm/drm_drv.h>
@@ -124,6 +127,12 @@ int radeon_gart_size = -1; /* auto */
 int radeon_benchmarking;
 int radeon_testing;
 int radeon_connector_table;
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+int radeon_split_dvii = 1;
+#endif
+#ifdef CONFIG_IGEL_RADEON_LVDS_SWITCH
+int radeon_lvds = 1;
+#endif
 int radeon_tv = 1;
 int radeon_audio = -1;
 int radeon_disp_priority;
@@ -146,6 +155,14 @@ int radeon_auxch = -1;
 int radeon_uvd = 1;
 int radeon_vce = 1;
 
+#ifdef CONFIG_IGEL_RADEON_DP_DVI_ADAPTER_PROBE_WORKAROUND
+int radeon_dp_dvi_probe_workaround = 0;
+#endif
+
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+enum igel_platforms igel_platform = NO_IGEL_PLATFORM;
+#endif
+
 MODULE_PARM_DESC(no_wb, "Disable AGP writeback for scratch registers");
 module_param_named(no_wb, radeon_no_wb, int, 0444);
 
@@ -176,6 +193,15 @@ module_param_named(test, radeon_testing,
 MODULE_PARM_DESC(connector_table, "Force connector table");
 module_param_named(connector_table, radeon_connector_table, int, 0444);
 
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+MODULE_PARM_DESC(split_dvii, "Split DVI-I connector in 2 connectors (0 = disable)");
+module_param_named(split_dvii, radeon_split_dvii, int, 0444);
+#endif
+#ifdef CONFIG_IGEL_RADEON_LVDS_SWITCH
+MODULE_PARM_DESC(lvds, "LVDS enable (0 = disable)");
+module_param_named(lvds, radeon_lvds, int, 0444);
+#endif
+
 MODULE_PARM_DESC(tv, "TV enable (0 = disable)");
 module_param_named(tv, radeon_tv, int, 0444);
 
@@ -247,6 +273,11 @@ int radeon_cik_support = 1;
 MODULE_PARM_DESC(cik_support, "CIK support (1 = enabled (default), 0 = disabled)");
 module_param_named(cik_support, radeon_cik_support, int, 0444);
 
+#ifdef CONFIG_IGEL_RADEON_DP_DVI_ADAPTER_PROBE_WORKAROUND
+MODULE_PARM_DESC(dp_dvi_probe_workaround, "DisplayPort DVI adapter probe workaround for DPMS issues (1 = enabled, 0 = disabled (default))");
+module_param_named(dp_dvi_probe_workaround, radeon_dp_dvi_probe_workaround, int, 0644);
+#endif
+
 static struct pci_device_id pciidlist[] = {
 	radeon_PCI_IDS
 };
@@ -600,9 +631,29 @@ static struct pci_driver radeon_kms_pci_
 
 static int __init radeon_module_init(void)
 {
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+	const char *product;
+	const char *vendor;
+#endif
 	if (drm_firmware_drivers_only() && radeon_modeset == -1)
 		radeon_modeset = 0;
 
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+	if (igel_platform == NO_IGEL_PLATFORM) {
+		product = dmi_get_system_info(DMI_PRODUCT_NAME);
+		vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+		if (product != NULL && vendor != NULL) {
+			if (strstr(product, "TC2") && 
+			strstr(vendor, "Samsung Electronics Co., Ltd")) {
+				igel_platform = SAMSUNG_TC2;
+			} else if (strstr(product, "M340C") && 
+			strstr(vendor, "IGEL Technology GmbH")) {
+				igel_platform = IGEL_M340C;
+			}
+		}
+	}
+#endif
+
 	if (radeon_modeset == 0)
 		return -EINVAL;
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.h b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_drv.h	2024-08-02 15:41:31.547491394 +0200
@@ -115,6 +115,19 @@
 #define DRIVER_MINOR		34
 #define DRIVER_PATCHLEVEL	0
 
+#ifdef CONFIG_IGEL_RADEON_DETECTION
+/* gottwald@igel.com: define enum for IGEL platforms,
+ * that require special treatment. Also in radeon.h */
+enum igel_platforms {
+	NO_IGEL_PLATFORM = -1,
+	IGEL_M340C,
+	SAMSUNG_TC2,
+};
+extern enum igel_platforms igel_platform;
+#define IS_IGEL_M340C (igel_platform==IGEL_M340C)
+#define IS_SAMSUNG_TC2 (igel_platform==SAMSUNG_TC2)
+#endif
+
 long radeon_drm_ioctl(struct file *filp,
 		      unsigned int cmd, unsigned long arg);
 
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon.h b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon.h	2024-08-02 15:41:31.543491299 +0200
@@ -98,6 +98,12 @@ extern int radeon_gart_size;
 extern int radeon_benchmarking;
 extern int radeon_testing;
 extern int radeon_connector_table;
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+extern int radeon_split_dvii;
+#endif
+#ifdef CONFIG_IGEL_RADEON_LVDS_SWITCH
+extern int radeon_lvds;
+#endif
 extern int radeon_tv;
 extern int radeon_audio;
 extern int radeon_disp_priority;
@@ -122,6 +128,10 @@ extern int radeon_vce;
 extern int radeon_si_support;
 extern int radeon_cik_support;
 
+#ifdef CONFIG_IGEL_RADEON_DP_DVI_ADAPTER_PROBE_WORKAROUND
+extern int radeon_dp_dvi_probe_workaround;
+#endif
+
 /*
  * Copy from radeon_drv.h so we don't have to include both and have conflicting
  * symbol;
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_mode.h b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_mode.h
--- a/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_mode.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/radeon/radeon_mode.h	2024-08-02 15:41:31.547491394 +0200
@@ -533,6 +533,10 @@ struct radeon_connector {
 	enum radeon_connector_audio audio;
 	enum radeon_connector_dither dither;
 	int pixelclock_for_modeset;
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+	/* lang@igel: split DVI-I connector in analog + digital connector */
+	int splitted_dvii;
+#endif
 };
 
 #define ENCODER_MODE_IS_DP(em) (((em) == ATOM_ENCODER_MODE_DP) || \
@@ -662,7 +666,12 @@ radeon_add_atom_connector(struct drm_dev
 			  uint32_t igp_lane_info,
 			  uint16_t connector_object_id,
 			  struct radeon_hpd *hpd,
+#ifdef CONFIG_IGEL_RADEON_SPLIT_DVII
+			  struct radeon_router *router,
+			  int splitted_dvii);
+#else
 			  struct radeon_router *router);
+#endif
 extern void
 radeon_add_legacy_connector(struct drm_device *dev,
 			    uint32_t connector_id,
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/linux-6.6.38.igel/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c
--- a/linux-6.6.38.igel/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c	2024-08-02 15:41:31.547491394 +0200
@@ -274,6 +274,10 @@ static int vmw_assume_16bpp;
 static int vmw_probe(struct pci_dev *, const struct pci_device_id *);
 static int vmwgfx_pm_notifier(struct notifier_block *nb, unsigned long val,
 			      void *ptr);
+#ifdef CONFIG_IGEL_VMWGFX_FIX
+static int vmw_setup_pci_resources(struct vmw_private *dev,
+				   u32 pci_id);
+#endif
 
 MODULE_PARM_DESC(restrict_iommu, "Try to limit IOMMU usage for TTM pages");
 module_param_named(restrict_iommu, vmw_restrict_iommu, int, 0600);
@@ -720,6 +724,7 @@ static void vmw_vram_manager_fini(struct
 	ttm_range_man_fini(&dev_priv->bdev, TTM_PL_VRAM);
 }
 
+#ifndef CONFIG_IGEL_VMWGFX_FIX
 static int vmw_setup_pci_resources(struct vmw_private *dev,
 				   u32 pci_id)
 {
@@ -793,6 +798,7 @@ static int vmw_setup_pci_resources(struc
 
 	return 0;
 }
+#endif /* ! CONFIG_IGEL_VMWGFX_FIX */
 
 static int vmw_detect_version(struct vmw_private *dev)
 {
@@ -856,6 +862,16 @@ static int vmw_driver_load(struct vmw_pr
 	enum vmw_res_type i;
 	bool refuse_dma = false;
 	struct pci_dev *pdev = to_pci_dev(dev_priv->drm.dev);
+#ifdef CONFIG_IGEL_VMWGFX_FIX
+	uint32_t capabilities = 0;
+
+	capabilities = vmw_read(dev_priv, SVGA_REG_CAPABILITIES);
+	if (!(capabilities & SVGA_CAP_DISPLAY_TOPOLOGY) &&
+	    !(capabilities & SVGA_CAP_PITCHLOCK) &&
+	    !vmw_fifo_have_pitchlock(dev_priv)) {
+		return -ENOSYS;
+	}
+#endif
 
 	dev_priv->drm.dev_private = dev_priv;
 
@@ -1642,14 +1658,97 @@ static struct pci_driver vmw_pci_driver
 	}
 };
 
+#ifdef CONFIG_IGEL_VMWGFX_FIX
+static int vmw_setup_pci_resources(struct vmw_private *dev,
+				   u32 pci_id)
+{
+	resource_size_t rmmio_start;
+	resource_size_t rmmio_size;
+	resource_size_t fifo_start;
+	resource_size_t fifo_size;
+	int ret;
+	struct pci_dev *pdev = to_pci_dev(dev->drm.dev);
+
+	pci_set_master(pdev);
+
+	/* IGEL ensure we tried to release the conflicting framebuffer */
+	ret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &driver);
+
+	ret = pci_request_regions(pdev, "vmwgfx probe");
+	if (ret) {
+		drm_warn(&dev->drm, "PCI request regions failed continue anyways.");
+	}
+
+	dev->pci_id = pci_id;
+	if (pci_id == VMWGFX_PCI_ID_SVGA3) {
+		rmmio_start = pci_resource_start(pdev, 0);
+		rmmio_size = pci_resource_len(pdev, 0);
+		dev->vram_start = pci_resource_start(pdev, 2);
+		dev->vram_size = pci_resource_len(pdev, 2);
+
+		drm_info(&dev->drm,
+			"Register MMIO at 0x%pa size is %llu kiB\n",
+			 &rmmio_start, (uint64_t)rmmio_size / 1024);
+		dev->rmmio = devm_ioremap(dev->drm.dev,
+					  rmmio_start,
+					  rmmio_size);
+		if (!dev->rmmio) {
+			drm_err(&dev->drm,
+				"Failed mapping registers mmio memory.\n");
+			pci_release_regions(pdev);
+			return -ENOMEM;
+		}
+	} else if (pci_id == VMWGFX_PCI_ID_SVGA2) {
+		dev->io_start = pci_resource_start(pdev, 0);
+		dev->vram_start = pci_resource_start(pdev, 1);
+		dev->vram_size = pci_resource_len(pdev, 1);
+		fifo_start = pci_resource_start(pdev, 2);
+		fifo_size = pci_resource_len(pdev, 2);
+
+		drm_info(&dev->drm,
+			 "FIFO at %pa size is %llu kiB\n",
+			 &fifo_start, (uint64_t)fifo_size / 1024);
+		dev->fifo_mem = devm_memremap(dev->drm.dev,
+					      fifo_start,
+					      fifo_size,
+					      MEMREMAP_WB);
+
+		if (IS_ERR(dev->fifo_mem)) {
+			drm_err(&dev->drm,
+				  "Failed mapping FIFO memory.\n");
+			pci_release_regions(pdev);
+			return PTR_ERR(dev->fifo_mem);
+		}
+	} else {
+		pci_release_regions(pdev);
+		return -EINVAL;
+	}
+
+	/*
+	 * This is approximate size of the vram, the exact size will only
+	 * be known after we read SVGA_REG_VRAM_SIZE. The PCI resource
+	 * size will be equal to or bigger than the size reported by
+	 * SVGA_REG_VRAM_SIZE.
+	 */
+	drm_info(&dev->drm,
+		 "VRAM at %pa size is %llu kiB\n",
+		 &dev->vram_start, (uint64_t)dev->vram_size / 1024);
+
+	return 0;
+}
+#endif /* CONFIG_IGEL_VMWGFX_FIX */
+
+
 static int vmw_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	struct vmw_private *vmw;
 	int ret;
 
+#ifndef CONFIG_IGEL_VMWGFX_FIX
 	ret = drm_aperture_remove_conflicting_pci_framebuffers(pdev, &driver);
 	if (ret)
 		goto out_error;
+#endif
 
 	ret = pcim_enable_device(pdev);
 	if (ret)
diff -Naurp a/linux-6.6.38.igel/drivers/gpu/vga/vga_switcheroo.c b/linux-6.6.38.igel/drivers/gpu/vga/vga_switcheroo.c
--- a/linux-6.6.38.igel/drivers/gpu/vga/vga_switcheroo.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/gpu/vga/vga_switcheroo.c	2024-08-02 15:41:31.547491394 +0200
@@ -438,12 +438,16 @@ find_active_client(struct list_head *hea
 bool vga_switcheroo_client_probe_defer(struct pci_dev *pdev)
 {
 	if ((pdev->class >> 16) == PCI_BASE_CLASS_DISPLAY) {
+#ifdef CONFIG_IGEL_APPLE_GMUX
+		if (apple_gmux_present() && !vgasr_priv.handler_flags)
+#else
 		/*
 		 * apple-gmux is needed on pre-retina MacBook Pro
 		 * to probe the panel if pdev is the inactive GPU.
 		 */
 		if (apple_gmux_present() && pdev != vga_default_device() &&
 		    !vgasr_priv.handler_flags)
+#endif
 			return true;
 	}
 
diff -Naurp a/linux-6.6.38.igel/drivers/hid/apple-ibridge.c b/linux-6.6.38.igel/drivers/hid/apple-ibridge.c
--- a/linux-6.6.38.igel/drivers/hid/apple-ibridge.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/hid/apple-ibridge.c	2024-08-02 15:41:31.547491394 +0200
@@ -0,0 +1,610 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Apple iBridge Driver
+ *
+ * Copyright (c) 2018 Ronald Tschalär
+ */
+
+/**
+ * DOC: Overview
+ *
+ * 2016 and 2017 MacBookPro models with a Touch Bar (MacBookPro13,[23] and
+ * MacBookPro14,[23]) have an Apple iBridge chip (also known as T1 chip) which
+ * exposes the touch bar, built-in webcam (iSight), ambient light sensor, and
+ * Secure Enclave Processor (SEP) for TouchID. It shows up in the system as a
+ * USB device with 3 configurations: 'Default iBridge Interfaces', 'Default
+ * iBridge Interfaces(OS X)', and 'Default iBridge Interfaces(Recovery)'.
+ *
+ * In the first (default after boot) configuration, 4 usb interfaces are
+ * exposed: 2 related to the webcam, and 2 USB HID interfaces representing
+ * the touch bar and the ambient light sensor. The webcam interfaces are
+ * already handled by the uvcvideo driver. However, there is a problem with
+ * the other two interfaces: one of them contains functionality (HID reports)
+ * used by both the touch bar and the ALS, which is an issue because the kernel
+ * allows only one driver to be attached to a given device. This driver exists
+ * to solve this issue.
+ *
+ * This driver is implemented as a HID driver that attaches to both HID
+ * interfaces and in turn creates several virtual child HID devices, one for
+ * each top-level collection found in each interfaces report descriptor. The
+ * touch bar and ALS drivers then attach to these virtual HID devices, and this
+ * driver forwards the operations between the real and virtual devices.
+ *
+ * One important aspect of this approach is that resulting (virtual) HID
+ * devices look much like the HID devices found on the later MacBookPro models
+ * which have a T2 chip, where there are separate USB interfaces for the touch
+ * bar and ALS functionality, which means that the touch bar and ALS drivers
+ * work (mostly) the same on both types of models.
+ *
+ * Lastly, this driver also takes care of the power-management for the
+ * iBridge when suspending and resuming.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/acpi.h>
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+
+#include "hid-ids.h"
+#include "../hid/usbhid/usbhid.h"
+#include "apple-ibridge.h"
+
+#define APPLEIB_BASIC_CONFIG	1
+
+static struct hid_device_id appleib_sub_hid_ids[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LINUX_FOUNDATION,
+			 USB_DEVICE_ID_IBRIDGE_TB) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LINUX_FOUNDATION,
+			 USB_DEVICE_ID_IBRIDGE_ALS) },
+};
+
+static struct {
+	unsigned int usage;
+	struct hid_device_id *dev_id;
+} appleib_usage_map[] = {
+	/* Default iBridge configuration, key inputs and mode settings */
+	{ 0x00010006, &appleib_sub_hid_ids[0] },
+	/* OS X iBridge configuration, digitizer inputs */
+	{ 0x000D0005, &appleib_sub_hid_ids[0] },
+	/* All iBridge configurations, display/DFR settings */
+	{ 0xFF120001, &appleib_sub_hid_ids[0] },
+	/* All iBridge configurations, ALS */
+	{ 0x00200041, &appleib_sub_hid_ids[1] },
+};
+
+struct appleib_device {
+	acpi_handle asoc_socw;
+};
+
+struct appleib_hid_dev_info {
+	struct hid_device	*hdev;
+	struct hid_device	*sub_hdevs[ARRAY_SIZE(appleib_sub_hid_ids)];
+	bool			sub_open[ARRAY_SIZE(appleib_sub_hid_ids)];
+};
+
+static int appleib_hid_raw_event(struct hid_device *hdev,
+				 struct hid_report *report, u8 *data, int size)
+{
+	struct appleib_hid_dev_info *hdev_info = hid_get_drvdata(hdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hdev_info->sub_hdevs); i++) {
+		if (READ_ONCE(hdev_info->sub_open[i]))
+			hid_input_report(hdev_info->sub_hdevs[i], report->type,
+					 data, size, 0);
+	}
+
+	return 0;
+}
+
+static __u8 *appleib_report_fixup(struct hid_device *hdev, __u8 *rdesc,
+				  unsigned int *rsize)
+{
+	/* Some fields have a size of 64 bits, which according to HID 1.11
+	 * Section 8.4 is not valid ("An item field cannot span more than 4
+	 * bytes in a report"). Furthermore, hid_field_extract() complains
+	 * when encountering such a field. So turn them into two 32-bit fields
+	 * instead.
+	 */
+
+	if (*rsize == 634 &&
+	    /* Usage Page 0xff12 (vendor defined) */
+	    rdesc[212] == 0x06 && rdesc[213] == 0x12 && rdesc[214] == 0xff &&
+	    /* Usage 0x51 */
+	    rdesc[416] == 0x09 && rdesc[417] == 0x51 &&
+	    /* report size 64 */
+	    rdesc[432] == 0x75 && rdesc[433] == 64 &&
+	    /* report count 1 */
+	    rdesc[434] == 0x95 && rdesc[435] == 1) {
+		rdesc[433] = 32;
+		rdesc[435] = 2;
+		hid_dbg(hdev, "Fixed up first 64-bit field\n");
+	}
+
+	if (*rsize == 634 &&
+	    /* Usage Page 0xff12 (vendor defined) */
+	    rdesc[212] == 0x06 && rdesc[213] == 0x12 && rdesc[214] == 0xff &&
+	    /* Usage 0x51 */
+	    rdesc[611] == 0x09 && rdesc[612] == 0x51 &&
+	    /* report size 64 */
+	    rdesc[627] == 0x75 && rdesc[628] == 64 &&
+	    /* report count 1 */
+	    rdesc[629] == 0x95 && rdesc[630] == 1) {
+		rdesc[628] = 32;
+		rdesc[630] = 2;
+		hid_dbg(hdev, "Fixed up second 64-bit field\n");
+	}
+
+	return rdesc;
+}
+
+#ifdef CONFIG_PM
+/**
+ * appleib_forward_int_op() - Forward a hid-driver callback to all drivers on
+ * all virtual HID devices attached to the given real HID device.
+ * @hdev the real hid-device
+ * @forward a function that calls the callback on the given driver
+ * @args arguments for the forward function
+ *
+ * This is for callbacks that return a status as an int.
+ *
+ * Returns: 0 on success, or the first error returned by the @forward function.
+ */
+static int appleib_forward_int_op(struct hid_device *hdev,
+				  int (*forward)(struct hid_driver *,
+						 struct hid_device *, void *),
+				  void *args)
+{
+	struct appleib_hid_dev_info *hdev_info = hid_get_drvdata(hdev);
+	struct hid_device *sub_hdev;
+	int rc;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hdev_info->sub_hdevs); i++) {
+		sub_hdev = hdev_info->sub_hdevs[i];
+		if (sub_hdev->driver) {
+			rc = forward(sub_hdev->driver, sub_hdev, args);
+			if (rc)
+				return rc;
+		}
+	}
+
+	return 0;
+}
+
+static int appleib_hid_suspend_fwd(struct hid_driver *drv,
+				   struct hid_device *hdev, void *args)
+{
+	int rc = 0;
+
+	if (drv->suspend)
+		rc = drv->suspend(hdev, *(pm_message_t *)args);
+
+	return rc;
+}
+
+static int appleib_hid_suspend(struct hid_device *hdev, pm_message_t message)
+{
+	return appleib_forward_int_op(hdev, appleib_hid_suspend_fwd, &message);
+}
+
+static int appleib_hid_resume_fwd(struct hid_driver *drv,
+				  struct hid_device *hdev, void *args)
+{
+	int rc = 0;
+
+	if (drv->resume)
+		rc = drv->resume(hdev);
+
+	return rc;
+}
+
+static int appleib_hid_resume(struct hid_device *hdev)
+{
+	return appleib_forward_int_op(hdev, appleib_hid_resume_fwd, NULL);
+}
+
+static int appleib_hid_reset_resume_fwd(struct hid_driver *drv,
+					struct hid_device *hdev, void *args)
+{
+	int rc = 0;
+
+	if (drv->reset_resume)
+		rc = drv->reset_resume(hdev);
+
+	return rc;
+}
+
+static int appleib_hid_reset_resume(struct hid_device *hdev)
+{
+	return appleib_forward_int_op(hdev, appleib_hid_reset_resume_fwd, NULL);
+}
+#endif /* CONFIG_PM */
+
+static int appleib_ll_start(struct hid_device *hdev)
+{
+	return 0;
+}
+
+static void appleib_ll_stop(struct hid_device *hdev)
+{
+}
+
+static int appleib_set_open(struct hid_device *hdev, bool open)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hdev_info->sub_hdevs); i++) {
+		/*
+		 * hid_hw_open(), and hence appleib_ll_open(), is called
+		 * from the driver's probe function, which in turn is called
+		 * while adding the sub-hdev; but at this point we haven't yet
+		 * added the sub-hdev to our list. So if we don't find the
+		 * sub-hdev in our list assume it's in the process of being
+		 * added and set the flag on the first unset sub-hdev.
+		 */
+		if (hdev_info->sub_hdevs[i] == hdev ||
+		    !hdev_info->sub_hdevs[i]) {
+			WRITE_ONCE(hdev_info->sub_open[i], open);
+			return 0;
+		}
+	}
+
+	return -ENODEV;
+}
+
+static int appleib_ll_open(struct hid_device *hdev)
+{
+	return appleib_set_open(hdev, true);
+}
+
+static void appleib_ll_close(struct hid_device *hdev)
+{
+	appleib_set_open(hdev, false);
+}
+
+static int appleib_ll_power(struct hid_device *hdev, int level)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+
+	return hid_hw_power(hdev_info->hdev, level);
+}
+
+static int appleib_ll_parse(struct hid_device *hdev)
+{
+	/* we've already called hid_parse_report() */
+	return 0;
+}
+
+static void appleib_ll_request(struct hid_device *hdev,
+			       struct hid_report *report, int reqtype)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+
+	hid_hw_request(hdev_info->hdev, report, reqtype);
+}
+
+static int appleib_ll_wait(struct hid_device *hdev)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+
+	hid_hw_wait(hdev_info->hdev);
+	return 0;
+}
+
+static int appleib_ll_raw_request(struct hid_device *hdev,
+				  unsigned char reportnum, __u8 *buf,
+				  size_t len, unsigned char rtype, int reqtype)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+
+	return hid_hw_raw_request(hdev_info->hdev, reportnum, buf, len, rtype,
+				  reqtype);
+}
+
+static int appleib_ll_output_report(struct hid_device *hdev, __u8 *buf,
+				    size_t len)
+{
+	struct appleib_hid_dev_info *hdev_info = hdev->driver_data;
+
+	return hid_hw_output_report(hdev_info->hdev, buf, len);
+}
+
+static struct hid_ll_driver appleib_ll_driver = {
+	.start = appleib_ll_start,
+	.stop = appleib_ll_stop,
+	.open = appleib_ll_open,
+	.close = appleib_ll_close,
+	.power = appleib_ll_power,
+	.parse = appleib_ll_parse,
+	.request = appleib_ll_request,
+	.wait = appleib_ll_wait,
+	.raw_request = appleib_ll_raw_request,
+	.output_report = appleib_ll_output_report,
+};
+
+static struct hid_device_id *appleib_find_dev_id_for_usage(unsigned int usage)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(appleib_usage_map); i++) {
+		if (appleib_usage_map[i].usage == usage)
+			return appleib_usage_map[i].dev_id;
+	}
+
+	return NULL;
+}
+
+static struct hid_device *
+appleib_add_sub_dev(struct appleib_hid_dev_info *hdev_info,
+		    struct hid_device_id *dev_id)
+{
+	struct hid_device *sub_hdev;
+	int rc;
+
+	sub_hdev = hid_allocate_device();
+	if (IS_ERR(sub_hdev))
+		return sub_hdev;
+
+	sub_hdev->dev.parent = &hdev_info->hdev->dev;
+
+	sub_hdev->bus = dev_id->bus;
+	sub_hdev->group = dev_id->group;
+	sub_hdev->vendor = dev_id->vendor;
+	sub_hdev->product = dev_id->product;
+
+	sub_hdev->ll_driver = &appleib_ll_driver;
+
+	snprintf(sub_hdev->name, sizeof(sub_hdev->name),
+		 "iBridge Virtual HID %s/%04x:%04x",
+		 dev_name(sub_hdev->dev.parent), sub_hdev->vendor,
+		 sub_hdev->product);
+
+	sub_hdev->driver_data = hdev_info;
+
+	rc = hid_add_device(sub_hdev);
+	if (rc) {
+		hid_destroy_device(sub_hdev);
+		return ERR_PTR(rc);
+	}
+
+	return sub_hdev;
+}
+
+static struct appleib_hid_dev_info *appleib_add_device(struct hid_device *hdev)
+{
+	struct appleib_hid_dev_info *hdev_info;
+	struct hid_device_id *dev_id;
+	unsigned int usage;
+	int i;
+
+	hdev_info = devm_kzalloc(&hdev->dev, sizeof(*hdev_info), GFP_KERNEL);
+	if (!hdev_info)
+		return ERR_PTR(-ENOMEM);
+
+	hdev_info->hdev = hdev;
+
+	for (i = 0; i < hdev->maxcollection; i++) {
+		usage = hdev->collection[i].usage;
+		dev_id = appleib_find_dev_id_for_usage(usage);
+
+		if (!dev_id) {
+			hid_warn(hdev, "Unknown collection encountered with usage %x\n",
+				 usage);
+		} else {
+			hdev_info->sub_hdevs[i] = appleib_add_sub_dev(hdev_info, dev_id);
+
+			if (IS_ERR(hdev_info->sub_hdevs[i])) {
+				while (i-- > 0)
+					hid_destroy_device(hdev_info->sub_hdevs[i]);
+				return (void *)hdev_info->sub_hdevs[i];
+			}
+		}
+	}
+
+	return hdev_info;
+}
+
+static void appleib_remove_device(struct hid_device *hdev)
+{
+	struct appleib_hid_dev_info *hdev_info = hid_get_drvdata(hdev);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(hdev_info->sub_hdevs); i++) {
+		if (hdev_info->sub_hdevs[i])
+			hid_destroy_device(hdev_info->sub_hdevs[i]);
+	}
+
+	hid_set_drvdata(hdev, NULL);
+}
+
+static int appleib_hid_probe(struct hid_device *hdev,
+			     const struct hid_device_id *id)
+{
+	struct appleib_hid_dev_info *hdev_info;
+	struct usb_device *udev;
+	int rc;
+
+	/* check and set usb config first */
+	udev = hid_to_usb_dev(hdev);
+
+	if (udev->actconfig->desc.bConfigurationValue != APPLEIB_BASIC_CONFIG) {
+		rc = usb_driver_set_configuration(udev, APPLEIB_BASIC_CONFIG);
+		return rc ? rc : -ENODEV;
+	}
+
+	rc = hid_parse(hdev);
+	if (rc) {
+		hid_err(hdev, "ib: hid parse failed (%d)\n", rc);
+		goto error;
+	}
+
+	rc = hid_hw_start(hdev, HID_CONNECT_DRIVER);
+	if (rc) {
+		hid_err(hdev, "ib: hw start failed (%d)\n", rc);
+		goto error;
+	}
+
+	hdev_info = appleib_add_device(hdev);
+	if (IS_ERR(hdev_info)) {
+		rc = PTR_ERR(hdev_info);
+		goto stop_hw;
+	}
+
+	hid_set_drvdata(hdev, hdev_info);
+
+	rc = hid_hw_open(hdev);
+	if (rc) {
+		hid_err(hdev, "ib: failed to open hid: %d\n", rc);
+		goto remove_dev;
+	}
+
+	return 0;
+
+remove_dev:
+	appleib_remove_device(hdev);
+stop_hw:
+	hid_hw_stop(hdev);
+error:
+	return rc;
+}
+
+static void appleib_hid_remove(struct hid_device *hdev)
+{
+	hid_hw_close(hdev);
+	appleib_remove_device(hdev);
+	hid_hw_stop(hdev);
+}
+
+static const struct hid_device_id appleib_hid_ids[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IBRIDGE) },
+	{ },
+};
+
+static struct hid_driver appleib_hid_driver = {
+	.name = "apple-ibridge-hid",
+	.id_table = appleib_hid_ids,
+	.probe = appleib_hid_probe,
+	.remove = appleib_hid_remove,
+	.raw_event = appleib_hid_raw_event,
+	.report_fixup = appleib_report_fixup,
+#ifdef CONFIG_PM
+	.suspend = appleib_hid_suspend,
+	.resume = appleib_hid_resume,
+	.reset_resume = appleib_hid_reset_resume,
+#endif
+};
+
+static struct appleib_device *appleib_alloc_device(struct platform_device *pdev)
+{
+	struct appleib_device *ib_dev;
+	acpi_status sts;
+
+	ib_dev = devm_kzalloc(&pdev->dev, sizeof(*ib_dev), GFP_KERNEL);
+	if (!ib_dev)
+		return ERR_PTR(-ENOMEM);
+
+	/* get iBridge acpi power control method for suspend/resume */
+	sts = acpi_get_handle(ACPI_HANDLE(&pdev->dev), "SOCW", &ib_dev->asoc_socw);
+	if (ACPI_FAILURE(sts)) {
+		dev_err(&pdev->dev,
+			"Error getting handle for ASOC.SOCW method: %s\n",
+			acpi_format_exception(sts));
+		return ERR_PTR(-ENXIO);
+	}
+
+	/* ensure iBridge is powered on */
+	sts = acpi_execute_simple_method(ib_dev->asoc_socw, NULL, 1);
+	if (ACPI_FAILURE(sts))
+		dev_warn(&pdev->dev, "SOCW(1) failed: %s\n",
+			 acpi_format_exception(sts));
+
+	return ib_dev;
+}
+
+static int appleib_probe(struct platform_device *pdev)
+{
+	struct appleib_device *ib_dev;
+	int ret;
+
+	ib_dev = appleib_alloc_device(pdev);
+	if (IS_ERR(ib_dev))
+		return PTR_ERR(ib_dev);
+
+	ret = hid_register_driver(&appleib_hid_driver);
+	if (ret) {
+		dev_err(&pdev->dev, "Error registering hid driver: %d\n",
+			ret);
+		return ret;
+	}
+
+	platform_set_drvdata(pdev, ib_dev);
+
+	return 0;
+}
+
+static int appleib_remove(struct platform_device *pdev)
+{
+	hid_unregister_driver(&appleib_hid_driver);
+
+	return 0;
+}
+
+static int appleib_suspend(struct platform_device *pdev, pm_message_t message)
+{
+	struct appleib_device *ib_dev;
+	int rc;
+
+	ib_dev = platform_get_drvdata(pdev);
+
+	rc = acpi_execute_simple_method(ib_dev->asoc_socw, NULL, 0);
+	if (ACPI_FAILURE(rc))
+		dev_warn(&pdev->dev, "SOCW(0) failed: %s\n",
+			 acpi_format_exception(rc));
+
+	return 0;
+}
+
+static int appleib_resume(struct platform_device *pdev)
+{
+	struct appleib_device *ib_dev;
+	int rc;
+
+	ib_dev = platform_get_drvdata(pdev);
+
+	rc = acpi_execute_simple_method(ib_dev->asoc_socw, NULL, 1);
+	if (ACPI_FAILURE(rc))
+		dev_warn(&pdev->dev, "SOCW(1) failed: %s\n",
+			 acpi_format_exception(rc));
+
+	return 0;
+}
+
+static const struct acpi_device_id appleib_acpi_match[] = {
+	{ "APP7777", 0 },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(acpi, appleib_acpi_match);
+
+static struct platform_driver appleib_driver = {
+	.probe		= appleib_probe,
+	.remove		= appleib_remove,
+	.suspend	= appleib_suspend,
+	.resume		= appleib_resume,
+	.driver		= {
+		.name		  = "apple-ibridge",
+		.acpi_match_table = appleib_acpi_match,
+	},
+};
+
+module_platform_driver(appleib_driver);
+
+MODULE_AUTHOR("Ronald Tschalär");
+MODULE_DESCRIPTION("Apple iBridge driver");
+MODULE_LICENSE("GPL");
diff -Naurp a/linux-6.6.38.igel/drivers/hid/apple-ibridge.h b/linux-6.6.38.igel/drivers/hid/apple-ibridge.h
--- a/linux-6.6.38.igel/drivers/hid/apple-ibridge.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/hid/apple-ibridge.h	2024-08-02 15:41:31.547491394 +0200
@@ -0,0 +1,15 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Apple iBridge Driver
+ *
+ * Copyright (c) 2018 Ronald Tschalär
+ */
+
+#ifndef __LINUX_APPLE_IBRDIGE_H
+#define __LINUX_APPLE_IBRDIGE_H
+
+#define USB_VENDOR_ID_LINUX_FOUNDATION	0x1d6b
+#define USB_DEVICE_ID_IBRIDGE_TB	0x0301
+#define USB_DEVICE_ID_IBRIDGE_ALS	0x0302
+
+#endif
diff -Naurp a/linux-6.6.38.igel/drivers/hid/apple-touchbar.c b/linux-6.6.38.igel/drivers/hid/apple-touchbar.c
--- a/linux-6.6.38.igel/drivers/hid/apple-touchbar.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/hid/apple-touchbar.c	2024-08-02 15:41:31.547491394 +0200
@@ -0,0 +1,1500 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Apple Touch Bar Driver
+ *
+ * Copyright (c) 2017-2018 Ronald Tschalär
+ */
+
+/*
+ * Recent MacBookPro models (MacBookPro 13,[23] and later) have a touch bar,
+ * which is exposed via several USB interfaces. MacOS supports a fancy mode
+ * where arbitrary buttons can be defined; this driver currently only
+ * supports the simple mode that consists of 3 predefined layouts
+ * (escape-only, esc + special keys, and esc + function keys).
+ *
+ * The first USB HID interface supports two reports, an input report that
+ * is used to report the key presses, and an output report which can be
+ * used to set the touch bar "mode": touch bar off (in which case no touches
+ * are reported at all), escape key only, escape + 12 function keys, and
+ * escape + several special keys (including brightness, audio volume,
+ * etc). The second interface supports several, complex reports, most of
+ * which are unknown at this time, but one of which has been determined to
+ * allow for controlling of the touch bar's brightness: off (though touches
+ * are still reported), dimmed, and full brightness. This driver makes
+ * use of these two reports.
+ */
+
+#define dev_fmt(fmt) "tb: " fmt
+
+#include <linux/device.h>
+#include <linux/hid.h>
+#include <linux/input.h>
+#include <linux/jiffies.h>
+#include <linux/ktime.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb.h>
+#include <linux/workqueue.h>
+
+#include "hid-ids.h"
+#include "apple-ibridge.h"
+
+#define HID_UP_APPLE		0xff120000
+#define HID_USAGE_MODE		(HID_UP_CUSTOM | 0x0004)
+#define HID_USAGE_APPLE_APP	(HID_UP_APPLE  | 0x0001)
+#define HID_USAGE_DISP		(HID_UP_APPLE  | 0x0021)
+#define HID_USAGE_DISP_AUX1	(HID_UP_APPLE  | 0x0020)
+
+#define APPLETB_MAX_TB_KEYS	13	/* ESC, F1-F12 */
+
+#define APPLETB_CMD_MODE_ESC	0
+#define APPLETB_CMD_MODE_FN	1
+#define APPLETB_CMD_MODE_SPCL	2
+#define APPLETB_CMD_MODE_OFF	3
+#define APPLETB_CMD_MODE_UPD	254
+#define APPLETB_CMD_MODE_NONE	255
+
+#define APPLETB_CMD_DISP_ON	1
+#define APPLETB_CMD_DISP_DIM	2
+#define APPLETB_CMD_DISP_OFF	4
+#define APPLETB_CMD_DISP_UPD	254
+#define APPLETB_CMD_DISP_NONE	255
+
+#define APPLETB_FN_MODE_FKEYS	0
+#define APPLETB_FN_MODE_NORM	1
+#define APPLETB_FN_MODE_INV	2
+#define APPLETB_FN_MODE_SPCL	3
+#define APPLETB_FN_MODE_ESC	4
+#define APPLETB_FN_MODE_MAX	APPLETB_FN_MODE_ESC
+
+#define APPLETB_DEVID_KEYBOARD	1
+#define APPLETB_DEVID_TOUCHPAD	2
+
+#define APPLETB_MAX_DIM_TIME	30
+
+#define APPLETB_FEATURE_IS_T1	BIT(0)
+
+static int appletb_tb_def_idle_timeout = 5 * 60;
+module_param_named(idle_timeout, appletb_tb_def_idle_timeout, int, 0444);
+MODULE_PARM_DESC(idle_timeout, "Default touch bar idle timeout:\n"
+			       "    [>0] - turn touch bar display off after no keyboard, trackpad, or touch bar input has been received for this many seconds;\n"
+			       "         the display will be turned back on as soon as new input is received\n"
+			       "     0 - turn touch bar display off (input does not turn it on again)\n"
+			       "    -1 - turn touch bar display on (does not turn off automatically)\n"
+			       "    -2 - disable touch bar completely");
+
+static int appletb_tb_def_dim_timeout = -2;
+module_param_named(dim_timeout, appletb_tb_def_dim_timeout, int, 0444);
+MODULE_PARM_DESC(dim_timeout, "Default touch bar dim timeout:\n"
+			      "    >0 - dim touch bar display after no keyboard, trackpad, or touch bar input has been received for this many seconds\n"
+			      "         the display will be returned to full brightness as soon as new input is received\n"
+			      "     0 - dim touch bar display (input does not return it to full brightness)\n"
+			      "    -1 - disable timeout (touch bar never dimmed)\n"
+			      "    [-2] - calculate timeout based on idle-timeout");
+
+static int appletb_tb_def_fn_mode = APPLETB_FN_MODE_NORM;
+module_param_named(fnmode, appletb_tb_def_fn_mode, int, 0444);
+MODULE_PARM_DESC(fnmode, "Default Fn key mode:\n"
+			 "    0 - function-keys only\n"
+			 "    [1] - fn key switches from special to function-keys\n"
+			 "    2 - inverse of 1\n"
+			 "    3 - special keys only\n"
+			 "    4 - escape key only");
+
+static ssize_t idle_timeout_show(struct device *dev,
+				 struct device_attribute *attr, char *buf);
+static ssize_t idle_timeout_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size);
+static DEVICE_ATTR_RW(idle_timeout);
+
+static ssize_t dim_timeout_show(struct device *dev,
+				struct device_attribute *attr, char *buf);
+static ssize_t dim_timeout_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size);
+static DEVICE_ATTR_RW(dim_timeout);
+
+static ssize_t fnmode_show(struct device *dev, struct device_attribute *attr,
+			   char *buf);
+static ssize_t fnmode_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size);
+static DEVICE_ATTR_RW(fnmode);
+
+static struct attribute *appletb_attrs[] = {
+	&dev_attr_idle_timeout.attr,
+	&dev_attr_dim_timeout.attr,
+	&dev_attr_fnmode.attr,
+	NULL,
+};
+
+static const struct attribute_group appletb_attr_group = {
+	.attrs = appletb_attrs,
+};
+
+struct appletb_device {
+	bool			active;
+	struct device		*log_dev;
+
+	struct hid_field	*mode_field;
+	struct hid_field	*disp_field;
+	struct hid_field	*disp_field_aux1;
+	struct appletb_iface_info {
+		struct hid_device	*hdev;
+		struct usb_interface	*usb_iface;
+		bool			suspended;
+	}			mode_iface, disp_iface;
+
+	struct input_handler	inp_handler;
+	struct input_handle	kbd_handle;
+	struct input_handle	tpd_handle;
+
+	bool			last_tb_keys_pressed[APPLETB_MAX_TB_KEYS];
+	bool			last_tb_keys_translated[APPLETB_MAX_TB_KEYS];
+	bool			last_fn_pressed;
+
+	ktime_t			last_event_time;
+
+	unsigned char		cur_tb_mode;
+	unsigned char		pnd_tb_mode;
+	unsigned char		cur_tb_disp;
+	unsigned char		pnd_tb_disp;
+	bool			tb_autopm_off;
+	bool			restore_autopm;
+	struct delayed_work	tb_work;
+	/* protects most of the above */
+	spinlock_t		tb_lock;
+
+	int			dim_timeout;
+	int			idle_timeout;
+	bool			dim_to_is_calc;
+	int			fn_mode;
+
+	bool			is_t1;
+};
+
+struct appletb_key_translation {
+	u16 from;
+	u16 to;
+};
+
+static const struct appletb_key_translation appletb_fn_codes[] = {
+	{ KEY_F1,  KEY_BRIGHTNESSDOWN },
+	{ KEY_F2,  KEY_BRIGHTNESSUP },
+	{ KEY_F3,  KEY_SCALE },		/* not used */
+	{ KEY_F4,  KEY_DASHBOARD },	/* not used */
+	{ KEY_F5,  KEY_KBDILLUMDOWN },
+	{ KEY_F6,  KEY_KBDILLUMUP },
+	{ KEY_F7,  KEY_PREVIOUSSONG },
+	{ KEY_F8,  KEY_PLAYPAUSE },
+	{ KEY_F9,  KEY_NEXTSONG },
+	{ KEY_F10, KEY_MUTE },
+	{ KEY_F11, KEY_VOLUMEDOWN },
+	{ KEY_F12, KEY_VOLUMEUP },
+};
+
+static struct appletb_device *appletb_dev;
+
+static bool appletb_disable_autopm(struct hid_device *hdev)
+{
+	int rc;
+
+	rc = hid_hw_power(hdev, PM_HINT_FULLON);
+
+	if (rc == 0)
+		return true;
+
+	hid_err(hdev,
+		"Failed to disable auto-pm on touch bar device (%d)\n", rc);
+	return false;
+}
+
+/*
+ * While the mode functionality is listed as a valid hid report in the usb
+ * interface descriptor, on a T1 it's not sent that way. Instead it's sent with
+ * different request-type and without a leading report-id in the data. Hence
+ * we need to send it as a custom usb control message rather via any of the
+ * standard hid_hw_*request() functions. The device might return EPIPE for a
+ * while after setting the display mode on T1 models, so retrying should be
+ * done on those models.
+ */
+static int appletb_set_tb_mode(struct appletb_device *tb_dev,
+			       unsigned char mode)
+{
+	struct hid_report *report;
+	void *buf;
+	bool autopm_off = false;
+	int rc;
+
+	if (!tb_dev->mode_iface.hdev)
+		return -ENOTCONN;
+
+	report = tb_dev->mode_field->report;
+
+	if (tb_dev->is_t1) {
+		buf = kmemdup(&mode, 1, GFP_KERNEL);
+	} else {
+		char data[] = { report->id, mode };
+
+		buf = kmemdup(data, sizeof(data), GFP_KERNEL);
+	}
+	if (!buf)
+		return -ENOMEM;
+
+	autopm_off = appletb_disable_autopm(tb_dev->mode_iface.hdev);
+
+	if (tb_dev->is_t1) {
+		int tries = 0;
+		struct usb_device *dev = interface_to_usbdev(tb_dev->mode_iface.usb_iface);
+		__u8 ifnum = tb_dev->mode_iface.usb_iface->cur_altsetting->desc.bInterfaceNumber;
+
+		do {
+			rc = usb_control_msg(dev, usb_sndctrlpipe(dev, 0), HID_REQ_SET_REPORT,
+					     USB_DIR_OUT | USB_RECIP_INTERFACE | USB_TYPE_VENDOR,
+					     (report->type + 1) << 8 | report->id,
+					     ifnum, buf, 1, 2000);
+
+			if (rc != -EPIPE)
+				break;
+
+			usleep_range(1000 << tries, 3000 << tries);
+		} while (++tries < 5);
+	} else {
+		rc = hid_hw_raw_request(tb_dev->mode_iface.hdev, report->id,
+					(__u8 *) buf, 2, report->type,
+					HID_REQ_SET_REPORT);
+	}
+
+	if (rc < 0)
+		dev_err(tb_dev->log_dev,
+			"Failed to set touch bar mode to %u (%d)\n", mode, rc);
+
+	if (autopm_off)
+		hid_hw_power(tb_dev->mode_iface.hdev, PM_HINT_NORMAL);
+
+	kfree(buf);
+
+	return rc;
+}
+
+static int appletb_set_tb_disp(struct appletb_device *tb_dev,
+			       unsigned char disp)
+{
+	struct hid_report *report;
+	int rc;
+
+	if (!tb_dev->disp_iface.hdev)
+		return -ENOTCONN;
+
+	report = tb_dev->disp_field->report;
+
+	rc = hid_set_field(tb_dev->disp_field_aux1, 0, 1);
+	if (rc) {
+		dev_err(tb_dev->log_dev,
+			"Failed to set display report field (%d)\n", rc);
+		return rc;
+	}
+
+	rc = hid_set_field(tb_dev->disp_field, 0, disp);
+	if (rc) {
+		dev_err(tb_dev->log_dev,
+			"Failed to set display report field (%d)\n", rc);
+		return rc;
+	}
+
+	/*
+	 * Keep the USB interface powered on while the touch bar display is on
+	 * for better responsiveness.
+	 */
+	if (disp != APPLETB_CMD_DISP_OFF && !tb_dev->tb_autopm_off)
+		tb_dev->tb_autopm_off =
+			appletb_disable_autopm(report->device);
+
+	hid_hw_request(tb_dev->disp_iface.hdev, report, HID_REQ_SET_REPORT);
+
+	if (disp == APPLETB_CMD_DISP_OFF && tb_dev->tb_autopm_off) {
+		hid_hw_power(tb_dev->disp_iface.hdev, PM_HINT_NORMAL);
+		tb_dev->tb_autopm_off = false;
+	}
+
+	return rc;
+}
+
+static bool appletb_any_tb_key_pressed(struct appletb_device *tb_dev)
+{
+	return !!memchr_inv(tb_dev->last_tb_keys_pressed, 0,
+			    sizeof(tb_dev->last_tb_keys_pressed));
+}
+
+static void appletb_schedule_tb_update(struct appletb_device *tb_dev, s64 secs)
+{
+	schedule_delayed_work(&tb_dev->tb_work, msecs_to_jiffies(secs * 1000));
+}
+
+static void appletb_set_tb_worker(struct work_struct *work)
+{
+	struct appletb_device *tb_dev =
+		container_of(work, struct appletb_device, tb_work.work);
+	s64 time_left = 0, min_timeout, time_to_off;
+	unsigned char pending_mode;
+	unsigned char pending_disp;
+	unsigned char current_disp;
+	bool restore_autopm;
+	bool any_tb_key_pressed, need_reschedule;
+	int rc1 = 1, rc2 = 1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	/* handle explicit mode-change request */
+	pending_mode = tb_dev->pnd_tb_mode;
+	pending_disp = tb_dev->pnd_tb_disp;
+	restore_autopm = tb_dev->restore_autopm;
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	if (pending_mode != APPLETB_CMD_MODE_NONE)
+		rc1 = appletb_set_tb_mode(tb_dev, pending_mode);
+	if (pending_mode != APPLETB_CMD_MODE_NONE &&
+	    pending_disp != APPLETB_CMD_DISP_NONE)
+		msleep(25);
+	if (pending_disp != APPLETB_CMD_DISP_NONE)
+		rc2 = appletb_set_tb_disp(tb_dev, pending_disp);
+
+	if (restore_autopm && tb_dev->tb_autopm_off)
+		appletb_disable_autopm(tb_dev->disp_field->report->device);
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	need_reschedule = false;
+
+	if (rc1 == 0) {
+		tb_dev->cur_tb_mode = pending_mode;
+
+		if (tb_dev->pnd_tb_mode == pending_mode)
+			tb_dev->pnd_tb_mode = APPLETB_CMD_MODE_NONE;
+		else
+			need_reschedule = true;
+	}
+
+	if (rc2 == 0) {
+		tb_dev->cur_tb_disp = pending_disp;
+
+		if (tb_dev->pnd_tb_disp == pending_disp)
+			tb_dev->pnd_tb_disp = APPLETB_CMD_DISP_NONE;
+		else
+			need_reschedule = true;
+	}
+	current_disp = tb_dev->cur_tb_disp;
+
+	tb_dev->restore_autopm = false;
+
+	/* calculate time left to next timeout */
+	if (tb_dev->idle_timeout == -2 || tb_dev->idle_timeout == 0)
+		min_timeout = -1;
+	else if (tb_dev->idle_timeout == -1)
+		min_timeout = tb_dev->dim_timeout;
+	else if (tb_dev->dim_timeout <= 0)
+		min_timeout = tb_dev->idle_timeout;
+	else
+		min_timeout = min(tb_dev->dim_timeout, tb_dev->idle_timeout);
+
+	if (min_timeout > 0) {
+		s64 idle_time =
+			(ktime_ms_delta(ktime_get(), tb_dev->last_event_time) +
+			 500) / 1000;
+
+		time_left = max(min_timeout - idle_time, 0LL);
+		if (tb_dev->idle_timeout <= 0)
+			time_to_off = -1;
+		else if (idle_time >= tb_dev->idle_timeout)
+			time_to_off = 0;
+		else
+			time_to_off = tb_dev->idle_timeout - idle_time;
+	} else {
+		/* not used - just to appease the compiler */
+		time_to_off = 0;
+	}
+
+	any_tb_key_pressed = appletb_any_tb_key_pressed(tb_dev);
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	dev_dbg(tb_dev->log_dev, "timeout calc: idle_timeout=%d dim_timeout=%d min_timeout=%lld time_left=%lld need_reschedule=%d any_tb_key_pressed=%d\n",
+		tb_dev->idle_timeout, tb_dev->dim_timeout, min_timeout,
+		time_left, need_reschedule, any_tb_key_pressed);
+
+	/* a new command arrived while we were busy - handle it */
+	if (need_reschedule) {
+		appletb_schedule_tb_update(tb_dev, 0);
+		return;
+	}
+
+	/* if no idle/dim timeout, we're done */
+	if (min_timeout <= 0)
+		return;
+
+	/* manage idle/dim timeout */
+	if (time_left > 0) {
+		/* we fired too soon or had a mode-change - re-schedule */
+		appletb_schedule_tb_update(tb_dev, time_left);
+	} else if (any_tb_key_pressed) {
+		/* keys are still pressed - re-schedule */
+		appletb_schedule_tb_update(tb_dev, min_timeout);
+	} else {
+		/* dim or idle timeout reached */
+		int next_disp = (time_to_off == 0) ? APPLETB_CMD_DISP_OFF :
+						     APPLETB_CMD_DISP_DIM;
+		if (next_disp != current_disp &&
+		    appletb_set_tb_disp(tb_dev, next_disp) == 0) {
+			spin_lock_irqsave(&tb_dev->tb_lock, flags);
+			tb_dev->cur_tb_disp = next_disp;
+			spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+		}
+
+		if (time_to_off > 0)
+			appletb_schedule_tb_update(tb_dev, time_to_off);
+	}
+}
+
+static u16 appletb_fn_to_special(u16 code)
+{
+	int idx;
+
+	for (idx = 0; idx < ARRAY_SIZE(appletb_fn_codes); idx++) {
+		if (appletb_fn_codes[idx].from == code)
+			return appletb_fn_codes[idx].to;
+	}
+
+	return 0;
+}
+
+static unsigned char appletb_get_cur_tb_mode(struct appletb_device *tb_dev)
+{
+	return tb_dev->pnd_tb_mode != APPLETB_CMD_MODE_NONE ?
+				tb_dev->pnd_tb_mode : tb_dev->cur_tb_mode;
+}
+
+static unsigned char appletb_get_cur_tb_disp(struct appletb_device *tb_dev)
+{
+	return tb_dev->pnd_tb_disp != APPLETB_CMD_DISP_NONE ?
+				tb_dev->pnd_tb_disp : tb_dev->cur_tb_disp;
+}
+
+static unsigned char appletb_get_fn_tb_mode(struct appletb_device *tb_dev)
+{
+	switch (tb_dev->fn_mode) {
+	case APPLETB_FN_MODE_ESC:
+		return APPLETB_CMD_MODE_ESC;
+
+	case APPLETB_FN_MODE_FKEYS:
+		return APPLETB_CMD_MODE_FN;
+
+	case APPLETB_FN_MODE_SPCL:
+		return APPLETB_CMD_MODE_SPCL;
+
+	case APPLETB_FN_MODE_INV:
+		return (tb_dev->last_fn_pressed) ? APPLETB_CMD_MODE_SPCL :
+						   APPLETB_CMD_MODE_FN;
+
+	case APPLETB_FN_MODE_NORM:
+	default:
+		return (tb_dev->last_fn_pressed) ? APPLETB_CMD_MODE_FN :
+						   APPLETB_CMD_MODE_SPCL;
+	}
+}
+
+/*
+ * Switch touch bar mode and display when mode or display not the desired ones.
+ */
+static void appletb_update_touchbar_no_lock(struct appletb_device *tb_dev,
+					    bool force)
+{
+	unsigned char want_mode;
+	unsigned char want_disp;
+	bool need_update = false;
+
+	/*
+	 * Calculate the new modes:
+	 *   idle_timeout:
+	 *     -2  mode/disp off
+	 *     -1  mode on, disp on/dim
+	 *      0  mode on, disp off
+	 *     >0  mode on, disp off after idle_timeout seconds
+	 *   dim_timeout (only valid if idle_timeout > 0 || idle_timeout == -1):
+	 *     -1  disp never dimmed
+	 *      0  disp always dimmed
+	 *     >0  disp dim after dim_timeout seconds
+	 */
+	if (tb_dev->idle_timeout == -2) {
+		want_mode = APPLETB_CMD_MODE_OFF;
+		want_disp = APPLETB_CMD_DISP_OFF;
+	} else {
+		want_mode = appletb_get_fn_tb_mode(tb_dev);
+		want_disp = tb_dev->idle_timeout ==  0 ? APPLETB_CMD_DISP_OFF :
+			    tb_dev->dim_timeout  ==  0 ? APPLETB_CMD_DISP_DIM :
+							 APPLETB_CMD_DISP_ON;
+	}
+
+	/*
+	 * See if we need to update the touch bar, taking into account that we
+	 * generally don't want to switch modes while a touch bar key is
+	 * pressed.
+	 */
+	if (appletb_get_cur_tb_mode(tb_dev) != want_mode &&
+	    !appletb_any_tb_key_pressed(tb_dev)) {
+		tb_dev->pnd_tb_mode = want_mode;
+		need_update = true;
+	}
+
+	if (appletb_get_cur_tb_disp(tb_dev) != want_disp &&
+	    (!appletb_any_tb_key_pressed(tb_dev) ||
+	     want_disp != APPLETB_CMD_DISP_OFF)) {
+		tb_dev->pnd_tb_disp = want_disp;
+		need_update = true;
+	}
+
+	if (force)
+		need_update = true;
+
+	/* schedule the update if desired */
+	dev_dbg_ratelimited(tb_dev->log_dev,
+			    "update: need_update=%d, want_mode=%d, cur-mode=%d, want_disp=%d, cur-disp=%d\n",
+			    need_update, want_mode, tb_dev->cur_tb_mode,
+			    want_disp, tb_dev->cur_tb_disp);
+
+	if (need_update) {
+		cancel_delayed_work(&tb_dev->tb_work);
+		appletb_schedule_tb_update(tb_dev, 0);
+	}
+}
+
+static void appletb_update_touchbar(struct appletb_device *tb_dev, bool force)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (tb_dev->active)
+		appletb_update_touchbar_no_lock(tb_dev, force);
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+}
+
+static void appletb_set_idle_timeout(struct appletb_device *tb_dev, int new)
+{
+	tb_dev->idle_timeout = new;
+
+	if (tb_dev->dim_to_is_calc && tb_dev->idle_timeout > 0)
+		tb_dev->dim_timeout = new - min(APPLETB_MAX_DIM_TIME, new / 3);
+	else if (tb_dev->dim_to_is_calc)
+		tb_dev->dim_timeout = -1;
+}
+
+static ssize_t idle_timeout_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", tb_dev->idle_timeout);
+}
+
+static ssize_t idle_timeout_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t size)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+	long new;
+	int rc;
+
+	rc = kstrtol(buf, 0, &new);
+	if (rc || new > INT_MAX || new < -2)
+		return -EINVAL;
+
+	appletb_set_idle_timeout(tb_dev, new);
+	appletb_update_touchbar(tb_dev, true);
+
+	return size;
+}
+
+static void appletb_set_dim_timeout(struct appletb_device *tb_dev, int new)
+{
+	if (new == -2) {
+		tb_dev->dim_to_is_calc = true;
+		appletb_set_idle_timeout(tb_dev, tb_dev->idle_timeout);
+	} else {
+		tb_dev->dim_to_is_calc = false;
+		tb_dev->dim_timeout = new;
+	}
+}
+
+static ssize_t dim_timeout_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n",
+			tb_dev->dim_to_is_calc ? -2 : tb_dev->dim_timeout);
+}
+
+static ssize_t dim_timeout_store(struct device *dev,
+				 struct device_attribute *attr,
+				 const char *buf, size_t size)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+	long new;
+	int rc;
+
+	rc = kstrtol(buf, 0, &new);
+	if (rc || new > INT_MAX || new < -2)
+		return -EINVAL;
+
+	appletb_set_dim_timeout(tb_dev, new);
+	appletb_update_touchbar(tb_dev, true);
+
+	return size;
+}
+
+static ssize_t fnmode_show(struct device *dev, struct device_attribute *attr,
+			   char *buf)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+
+	return snprintf(buf, PAGE_SIZE, "%d\n", tb_dev->fn_mode);
+}
+
+static ssize_t fnmode_store(struct device *dev, struct device_attribute *attr,
+			    const char *buf, size_t size)
+{
+	struct appletb_device *tb_dev = dev_get_drvdata(dev);
+	long new;
+	int rc;
+
+	rc = kstrtol(buf, 0, &new);
+	if (rc || new > APPLETB_FN_MODE_MAX || new < 0)
+		return -EINVAL;
+
+	tb_dev->fn_mode = new;
+	appletb_update_touchbar(tb_dev, false);
+
+	return size;
+}
+
+static int appletb_tb_key_to_slot(unsigned int code)
+{
+	switch (code) {
+	case KEY_ESC:
+		return 0;
+	case KEY_F1:
+	case KEY_F2:
+	case KEY_F3:
+	case KEY_F4:
+	case KEY_F5:
+	case KEY_F6:
+	case KEY_F7:
+	case KEY_F8:
+	case KEY_F9:
+	case KEY_F10:
+		return code - KEY_F1 + 1;
+	case KEY_F11:
+	case KEY_F12:
+		return code - KEY_F11 + 11;
+	default:
+		return -1;
+	}
+}
+
+static int appletb_hid_event(struct hid_device *hdev, struct hid_field *field,
+			     struct hid_usage *usage, __s32 value)
+{
+	struct appletb_device *tb_dev = hid_get_drvdata(hdev);
+	unsigned int new_code = 0;
+	unsigned long flags;
+	bool send_dummy = false;
+	bool send_trnsl = false;
+	int slot;
+	int rc = 0;
+
+	if ((usage->hid & HID_USAGE_PAGE) != HID_UP_KEYBOARD ||
+	    usage->type != EV_KEY)
+		return 0;
+
+	/*
+	 * Skip non-touch-bar keys.
+	 *
+	 * Either the touch bar itself or usbhid generate a slew of key-down
+	 * events for all the meta keys. None of which we're at all interested
+	 * in.
+	 */
+	slot = appletb_tb_key_to_slot(usage->code);
+	if (slot < 0)
+		return 0;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (!tb_dev->active) {
+		spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+		return 0;
+	}
+
+	new_code = appletb_fn_to_special(usage->code);
+
+	if (value != 2)
+		tb_dev->last_tb_keys_pressed[slot] = value;
+
+	tb_dev->last_event_time = ktime_get();
+
+	appletb_update_touchbar_no_lock(tb_dev, false);
+
+	/*
+	 * We want to suppress touch bar keys while the touch bar is off, but
+	 * we do want to wake up the screen if it's asleep, so generate a dummy
+	 * event in that case.
+	 */
+	if (tb_dev->cur_tb_mode == APPLETB_CMD_MODE_OFF ||
+	    tb_dev->cur_tb_disp == APPLETB_CMD_DISP_OFF) {
+		send_dummy = true;
+		rc = 1;
+	/* translate special keys */
+	} else if (new_code &&
+		   ((value > 0 &&
+		     appletb_get_cur_tb_mode(tb_dev) == APPLETB_CMD_MODE_SPCL)
+		    ||
+		    (value == 0 && tb_dev->last_tb_keys_translated[slot]))) {
+		tb_dev->last_tb_keys_translated[slot] = true;
+		send_trnsl = true;
+		rc = 1;
+	/* everything else handled normally */
+	} else {
+		tb_dev->last_tb_keys_translated[slot] = false;
+	}
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	/*
+	 * Need to send these input events outside of the lock, as otherwise
+	 * we can run into the following deadlock:
+	 *            Task 1                         Task 2
+	 *     appletb_hid_event()            input_event()
+	 *       acquire tb_lock                acquire dev->event_lock
+	 *       input_event()                  appletb_inp_event()
+	 *         acquire dev->event_lock        acquire tb_lock
+	 */
+	if (send_dummy) {
+		input_event(field->hidinput->input, EV_KEY, KEY_UNKNOWN, 1);
+		input_event(field->hidinput->input, EV_KEY, KEY_UNKNOWN, 0);
+	} else if (send_trnsl) {
+		input_event(field->hidinput->input, usage->type, new_code,
+			    value);
+	}
+
+	return rc;
+}
+
+static void appletb_inp_event(struct input_handle *handle, unsigned int type,
+			      unsigned int code, int value)
+{
+	struct appletb_device *tb_dev = handle->private;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (!tb_dev->active) {
+		spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+		return;
+	}
+
+	if (type == EV_KEY && code == KEY_FN && value != 2)
+		tb_dev->last_fn_pressed = value;
+
+	tb_dev->last_event_time = ktime_get();
+
+	appletb_update_touchbar_no_lock(tb_dev, false);
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+}
+
+/* Find and save the usb-device associated with the touch bar input device */
+static struct usb_interface *appletb_get_usb_iface(struct hid_device *hdev)
+{
+	struct device *dev = &hdev->dev;
+
+	while (dev && !(dev->type && dev->type->name &&
+			!strcmp(dev->type->name, "usb_interface")))
+		dev = dev->parent;
+
+	return dev ? to_usb_interface(dev) : NULL;
+}
+
+static int appletb_inp_connect(struct input_handler *handler,
+			       struct input_dev *dev,
+			       const struct input_device_id *id)
+{
+	struct appletb_device *tb_dev = handler->private;
+	struct input_handle *handle;
+	int rc;
+
+	if (id->driver_info == APPLETB_DEVID_KEYBOARD) {
+		handle = &tb_dev->kbd_handle;
+		handle->name = "tbkbd";
+	} else if (id->driver_info == APPLETB_DEVID_TOUCHPAD) {
+		handle = &tb_dev->tpd_handle;
+		handle->name = "tbtpad";
+	} else {
+		dev_err(tb_dev->log_dev, "Unknown device id (%lu)\n",
+			id->driver_info);
+		return -ENOENT;
+	}
+
+	if (handle->dev) {
+		dev_err(tb_dev->log_dev,
+			"Duplicate connect to %s input device\n", handle->name);
+		return -EEXIST;
+	}
+
+	handle->open = 0;
+	handle->dev = input_get_device(dev);
+	handle->handler = handler;
+	handle->private = tb_dev;
+
+	rc = input_register_handle(handle);
+	if (rc)
+		goto err_free_dev;
+
+	rc = input_open_device(handle);
+	if (rc)
+		goto err_unregister_handle;
+
+	dev_dbg(tb_dev->log_dev, "Connected to %s input device\n",
+		handle == &tb_dev->kbd_handle ? "keyboard" : "touchpad");
+
+	return 0;
+
+ err_unregister_handle:
+	input_unregister_handle(handle);
+ err_free_dev:
+	input_put_device(handle->dev);
+	handle->dev = NULL;
+	return rc;
+}
+
+static void appletb_inp_disconnect(struct input_handle *handle)
+{
+	struct appletb_device *tb_dev = handle->private;
+
+	input_close_device(handle);
+	input_unregister_handle(handle);
+
+	dev_dbg(tb_dev->log_dev, "Disconnected from %s input device\n",
+		handle == &tb_dev->kbd_handle ? "keyboard" : "touchpad");
+
+	input_put_device(handle->dev);
+	handle->dev = NULL;
+}
+
+static int appletb_input_configured(struct hid_device *hdev,
+				    struct hid_input *hidinput)
+{
+	int idx;
+	struct input_dev *input = hidinput->input;
+
+	/*
+	 * Clear various input capabilities that are blindly set by the hid
+	 * driver (usbkbd.c)
+	 */
+	memset(input->evbit, 0, sizeof(input->evbit));
+	memset(input->keybit, 0, sizeof(input->keybit));
+	memset(input->ledbit, 0, sizeof(input->ledbit));
+
+	/* set our actual capabilities */
+	__set_bit(EV_KEY, input->evbit);
+	__set_bit(EV_REP, input->evbit);
+	__set_bit(EV_MSC, input->evbit);  /* hid-input generates MSC_SCAN */
+
+	for (idx = 0; idx < ARRAY_SIZE(appletb_fn_codes); idx++) {
+		input_set_capability(input, EV_KEY, appletb_fn_codes[idx].from);
+		input_set_capability(input, EV_KEY, appletb_fn_codes[idx].to);
+	}
+
+	input_set_capability(input, EV_KEY, KEY_ESC);
+	input_set_capability(input, EV_KEY, KEY_UNKNOWN);
+
+	return 0;
+}
+
+static struct appletb_iface_info *
+appletb_get_iface_info(struct appletb_device *tb_dev, struct hid_device *hdev)
+{
+	if (hdev == tb_dev->mode_iface.hdev)
+		return &tb_dev->mode_iface;
+	if (hdev == tb_dev->disp_iface.hdev)
+		return &tb_dev->disp_iface;
+	return NULL;
+}
+
+/**
+ * appletb_find_report_field() - Find the field in the report with the given
+ * usage.
+ * @report: the report to search
+ * @field_usage: the usage of the field to search for
+ *
+ * Returns: the hid field if found, or NULL if none found.
+ */
+static struct hid_field *appletb_find_report_field(struct hid_report *report,
+						   unsigned int field_usage)
+{
+	int f, u;
+
+	for (f = 0; f < report->maxfield; f++) {
+		struct hid_field *field = report->field[f];
+
+		if (field->logical == field_usage)
+			return field;
+
+		for (u = 0; u < field->maxusage; u++) {
+			if (field->usage[u].hid == field_usage)
+				return field;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * appletb_find_hid_field() - Search all the reports of the device for the
+ * field with the given usage.
+ * @hdev: the device whose reports to search
+ * @application: the usage of application collection that the field must
+ *               belong to
+ * @field_usage: the usage of the field to search for
+ *
+ * Returns: the hid field if found, or NULL if none found.
+ */
+static struct hid_field *appletb_find_hid_field(struct hid_device *hdev,
+						unsigned int application,
+						unsigned int field_usage)
+{
+	static const int report_types[] = { HID_INPUT_REPORT, HID_OUTPUT_REPORT,
+					    HID_FEATURE_REPORT };
+	struct hid_report *report;
+	struct hid_field *field;
+	int t;
+
+	for (t = 0; t < ARRAY_SIZE(report_types); t++) {
+		struct list_head *report_list =
+			    &hdev->report_enum[report_types[t]].report_list;
+		list_for_each_entry(report, report_list, list) {
+			if (report->application != application)
+				continue;
+
+			field = appletb_find_report_field(report, field_usage);
+			if (field)
+				return field;
+		}
+	}
+
+	return NULL;
+}
+
+static int appletb_extract_report_and_iface_info(struct appletb_device *tb_dev,
+						 struct hid_device *hdev,
+						 const struct hid_device_id *id)
+{
+	struct appletb_iface_info *iface_info;
+	struct usb_interface *usb_iface;
+	struct hid_field *field;
+
+	field = appletb_find_hid_field(hdev, HID_GD_KEYBOARD, HID_USAGE_MODE);
+	if (field) {
+		iface_info = &tb_dev->mode_iface;
+		tb_dev->mode_field = field;
+		tb_dev->is_t1 = !!(id->driver_data & APPLETB_FEATURE_IS_T1);
+	} else {
+		field = appletb_find_hid_field(hdev, HID_USAGE_APPLE_APP,
+					       HID_USAGE_DISP);
+		if (!field)
+			return 0;
+
+		iface_info = &tb_dev->disp_iface;
+		tb_dev->disp_field = field;
+		tb_dev->disp_field_aux1 =
+			appletb_find_hid_field(hdev, HID_USAGE_APPLE_APP,
+					       HID_USAGE_DISP_AUX1);
+
+		if (!tb_dev->disp_field_aux1 ||
+		    tb_dev->disp_field_aux1->report !=
+						tb_dev->disp_field->report) {
+			dev_err(tb_dev->log_dev,
+				"Unexpected report structure for report %u in device %s\n",
+				tb_dev->disp_field->report->id,
+				dev_name(&hdev->dev));
+			return -ENODEV;
+		}
+	}
+
+	usb_iface = appletb_get_usb_iface(hdev);
+	if (!usb_iface) {
+		dev_err(tb_dev->log_dev,
+			"Failed to find usb interface for hid device %s\n",
+			dev_name(&hdev->dev));
+		return -ENODEV;
+	}
+
+	iface_info->hdev = hdev;
+	iface_info->usb_iface = usb_get_intf(usb_iface);
+	iface_info->suspended = false;
+
+	return 1;
+}
+
+static void appletb_clear_iface_info(struct appletb_device *tb_dev,
+				     struct hid_device *hdev)
+{
+	struct appletb_iface_info *iface_info;
+
+	iface_info = appletb_get_iface_info(tb_dev, hdev);
+	if (iface_info) {
+		usb_put_intf(iface_info->usb_iface);
+		iface_info->usb_iface = NULL;
+		iface_info->hdev = NULL;
+	}
+}
+
+static bool appletb_test_and_mark_active(struct appletb_device *tb_dev)
+{
+	unsigned long flags;
+	bool activated = false;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (tb_dev->mode_iface.hdev && tb_dev->disp_iface.hdev &&
+	    !tb_dev->active) {
+		tb_dev->active = true;
+		activated = true;
+	}
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	return activated;
+}
+
+static bool appletb_test_and_mark_inactive(struct appletb_device *tb_dev,
+					   struct hid_device *hdev)
+{
+	unsigned long flags;
+	bool deactivated = false;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (tb_dev->mode_iface.hdev && tb_dev->disp_iface.hdev &&
+	    tb_dev->active &&
+	    (hdev == tb_dev->mode_iface.hdev ||
+	     hdev == tb_dev->disp_iface.hdev)) {
+		tb_dev->active = false;
+		deactivated = true;
+	}
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	return deactivated;
+}
+
+static const struct input_device_id appletb_input_devices[] = {
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_BUS |
+			INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.bustype = BUS_SPI,
+		.keybit = { [BIT_WORD(KEY_FN)] = BIT_MASK(KEY_FN) },
+		.driver_info = APPLETB_DEVID_KEYBOARD,
+	},			/* Builtin SPI keyboard device */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_BUS |
+			INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.bustype = BUS_SPI,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.driver_info = APPLETB_DEVID_TOUCHPAD,
+	},			/* Builtin SPI touchpad device */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_BUS |
+			INPUT_DEVICE_ID_MATCH_VENDOR |
+			INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.bustype = BUS_USB,
+		.vendor = 0x05ac /* USB_VENDOR_ID_APPLE */,
+		.keybit = { [BIT_WORD(KEY_FN)] = BIT_MASK(KEY_FN) },
+		.driver_info = APPLETB_DEVID_KEYBOARD,
+	},			/* Builtin USB keyboard device */
+	{
+		.flags = INPUT_DEVICE_ID_MATCH_BUS |
+			INPUT_DEVICE_ID_MATCH_VENDOR |
+			INPUT_DEVICE_ID_MATCH_KEYBIT,
+		.bustype = BUS_USB,
+		.vendor = 0x05ac /* USB_VENDOR_ID_APPLE */,
+		.keybit = { [BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH) },
+		.driver_info = APPLETB_DEVID_TOUCHPAD,
+	},			/* Builtin USB touchpad device */
+	{ },			/* Terminating zero entry */
+};
+
+static bool appletb_match_internal_device(struct input_handler *handler,
+					  struct input_dev *inp_dev)
+{
+	struct device *dev = &inp_dev->dev;
+
+	if (inp_dev->id.bustype == BUS_SPI)
+		return true;
+
+	/* in kernel: dev && !is_usb_device(dev) */
+	while (dev && !(dev->type && dev->type->name &&
+			!strcmp(dev->type->name, "usb_device")))
+		dev = dev->parent;
+
+	/*
+	 * Apple labels all their internal keyboards and trackpads as such,
+	 * instead of maintaining an ever expanding list of product-id's we
+	 * just look at the device's product name.
+	 */
+	if (dev)
+		return !!strstr(to_usb_device(dev)->product, "Internal Keyboard");
+
+	return false;
+}
+
+static int appletb_probe(struct hid_device *hdev,
+			 const struct hid_device_id *id)
+{
+	struct appletb_device *tb_dev = appletb_dev;
+	unsigned long flags;
+	int rc;
+
+	/* initialize the report info */
+	rc = hid_parse(hdev);
+	if (rc) {
+		dev_err(tb_dev->log_dev, "hid parse failed (%d)\n", rc);
+		goto error;
+	}
+
+	/* Ensure this usb endpoint is for the touchbar backlight, not keyboard
+	 * backlight.
+	 */
+	if ((hdev->product == USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT) &&
+			!(hdev->collection && hdev->collection[0].usage ==
+				HID_USAGE_APPLE_APP)) {
+		return -ENODEV;
+	}
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (!tb_dev->log_dev)
+		tb_dev->log_dev = &hdev->dev;
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	hid_set_drvdata(hdev, tb_dev);
+
+	rc = appletb_extract_report_and_iface_info(tb_dev, hdev, id);
+	if (rc < 0)
+		goto error;
+
+	rc = hid_hw_start(hdev, HID_CONNECT_DRIVER | HID_CONNECT_HIDINPUT);
+	if (rc) {
+		dev_err(tb_dev->log_dev, "hw start failed (%d)\n", rc);
+		goto clear_iface_info;
+	}
+
+	rc = hid_hw_open(hdev);
+	if (rc) {
+		dev_err(tb_dev->log_dev, "hw open failed (%d)\n", rc);
+		goto stop_hid;
+	}
+
+	/* do setup if we have both interfaces */
+	if (appletb_test_and_mark_active(tb_dev)) {
+		/* initialize the touch bar */
+		if (appletb_tb_def_fn_mode >= 0 &&
+		    appletb_tb_def_fn_mode <= APPLETB_FN_MODE_MAX)
+			tb_dev->fn_mode = appletb_tb_def_fn_mode;
+		else
+			tb_dev->fn_mode = APPLETB_FN_MODE_NORM;
+		appletb_set_idle_timeout(tb_dev, appletb_tb_def_idle_timeout);
+		appletb_set_dim_timeout(tb_dev, appletb_tb_def_dim_timeout);
+		tb_dev->last_event_time = ktime_get();
+
+		tb_dev->pnd_tb_mode = APPLETB_CMD_MODE_UPD;
+		tb_dev->pnd_tb_disp = APPLETB_CMD_DISP_UPD;
+
+		appletb_update_touchbar(tb_dev, false);
+
+		/* set up the input handler */
+		tb_dev->inp_handler.event = appletb_inp_event;
+		tb_dev->inp_handler.connect = appletb_inp_connect;
+		tb_dev->inp_handler.disconnect = appletb_inp_disconnect;
+		tb_dev->inp_handler.name = "appletb";
+		tb_dev->inp_handler.id_table = appletb_input_devices;
+		tb_dev->inp_handler.match = appletb_match_internal_device;
+		tb_dev->inp_handler.private = tb_dev;
+
+		rc = input_register_handler(&tb_dev->inp_handler);
+		if (rc) {
+			dev_err(tb_dev->log_dev,
+				"Unable to register keyboard handler (%d)\n",
+				rc);
+			goto mark_inactive;
+		}
+
+		/* initialize sysfs attributes */
+		rc = sysfs_create_group(&tb_dev->mode_iface.hdev->dev.kobj,
+					&appletb_attr_group);
+		if (rc) {
+			dev_err(tb_dev->log_dev,
+				"Failed to create sysfs attributes (%d)\n", rc);
+			goto unreg_handler;
+		}
+
+		dev_dbg(tb_dev->log_dev, "Touchbar activated\n");
+	}
+
+	return 0;
+
+unreg_handler:
+	input_unregister_handler(&tb_dev->inp_handler);
+mark_inactive:
+	appletb_test_and_mark_inactive(tb_dev, hdev);
+	cancel_delayed_work_sync(&tb_dev->tb_work);
+	hid_hw_close(hdev);
+stop_hid:
+	hid_hw_stop(hdev);
+clear_iface_info:
+	appletb_clear_iface_info(tb_dev, hdev);
+error:
+	return rc;
+}
+
+static void appletb_remove(struct hid_device *hdev)
+{
+	struct appletb_device *tb_dev = hid_get_drvdata(hdev);
+	unsigned long flags;
+
+	if (appletb_test_and_mark_inactive(tb_dev, hdev)) {
+		sysfs_remove_group(&tb_dev->mode_iface.hdev->dev.kobj,
+				   &appletb_attr_group);
+
+		input_unregister_handler(&tb_dev->inp_handler);
+
+		cancel_delayed_work_sync(&tb_dev->tb_work);
+		appletb_set_tb_mode(tb_dev, APPLETB_CMD_MODE_OFF);
+		appletb_set_tb_disp(tb_dev, APPLETB_CMD_DISP_ON);
+
+		if (tb_dev->tb_autopm_off)
+			hid_hw_power(tb_dev->disp_iface.hdev, PM_HINT_NORMAL);
+
+		dev_info(tb_dev->log_dev, "Touchbar deactivated\n");
+	}
+
+	hid_hw_close(hdev);
+	hid_hw_stop(hdev);
+	appletb_clear_iface_info(tb_dev, hdev);
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	if (tb_dev->log_dev == &hdev->dev) {
+		if (tb_dev->mode_iface.hdev)
+			tb_dev->log_dev = &tb_dev->mode_iface.hdev->dev;
+		else if (tb_dev->disp_iface.hdev)
+			tb_dev->log_dev = &tb_dev->disp_iface.hdev->dev;
+		else
+			tb_dev->log_dev = NULL;
+	}
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+}
+
+#ifdef CONFIG_PM
+static int appletb_suspend(struct hid_device *hdev, pm_message_t message)
+{
+	struct appletb_device *tb_dev = hid_get_drvdata(hdev);
+	struct appletb_iface_info *iface_info;
+	unsigned long flags;
+	bool all_suspended = false;
+
+	if (message.event != PM_EVENT_SUSPEND &&
+	    message.event != PM_EVENT_FREEZE)
+		return 0;
+
+	if (tb_dev->is_t1) {
+
+		/*
+		 * Wait for both interfaces to be suspended and no more async work
+		 * in progress.
+		 */
+
+		spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+		if (!tb_dev->mode_iface.suspended && !tb_dev->disp_iface.suspended) {
+			tb_dev->active = false;
+			cancel_delayed_work(&tb_dev->tb_work);
+		}
+
+		iface_info = appletb_get_iface_info(tb_dev, hdev);
+		if (iface_info)
+			iface_info->suspended = true;
+
+		if ((!tb_dev->mode_iface.hdev || tb_dev->mode_iface.suspended) &&
+		    (!tb_dev->disp_iface.hdev || tb_dev->disp_iface.suspended))
+			all_suspended = true;
+
+		spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+		flush_delayed_work(&tb_dev->tb_work);
+
+		if (!all_suspended)
+			return 0;
+
+		/*
+		 * The touch bar device itself remembers the last state when suspended
+		 * in some cases, but in others (e.g. when mode != off and disp == off)
+		 * it resumes with a different state; furthermore it may be only
+		 * partially responsive in that state. By turning both mode and disp
+		 * off we ensure it is in a good state when resuming (and this happens
+		 * to be the same state after booting/resuming-from-hibernate, so less
+		 * special casing between the two).
+		 */
+		if (message.event == PM_EVENT_SUSPEND) {
+			appletb_set_tb_mode(tb_dev, APPLETB_CMD_MODE_OFF);
+			appletb_set_tb_disp(tb_dev, APPLETB_CMD_DISP_OFF);
+		}
+
+		spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+		tb_dev->cur_tb_mode = APPLETB_CMD_MODE_OFF;
+		tb_dev->cur_tb_disp = APPLETB_CMD_DISP_OFF;
+
+		spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+		dev_info(tb_dev->log_dev, "Touchbar suspended.\n");
+	} else {
+		dev_info(tb_dev->log_dev, "T2 Mac detected, not handling suspend.\n");
+	}
+
+	return 0;
+}
+
+static int appletb_reset_resume(struct hid_device *hdev)
+{
+	struct appletb_device *tb_dev = hid_get_drvdata(hdev);
+	struct appletb_iface_info *iface_info;
+	unsigned long flags;
+
+	spin_lock_irqsave(&tb_dev->tb_lock, flags);
+
+	iface_info = appletb_get_iface_info(tb_dev, hdev);
+	if (iface_info)
+		iface_info->suspended = false;
+
+	if ((tb_dev->mode_iface.hdev && !tb_dev->mode_iface.suspended) &&
+	    (tb_dev->disp_iface.hdev && !tb_dev->disp_iface.suspended)) {
+		/*
+		 * Restore touch bar state. Note that autopm state is not
+		 * preserved, so need explicitly restore that here.
+		 */
+		tb_dev->active = true;
+		tb_dev->restore_autopm = true;
+		tb_dev->last_event_time = ktime_get();
+
+		appletb_update_touchbar_no_lock(tb_dev, true);
+
+		dev_info(tb_dev->log_dev, "Touchbar resumed.\n");
+	}
+
+	spin_unlock_irqrestore(&tb_dev->tb_lock, flags);
+
+	return 0;
+}
+#endif
+
+static struct appletb_device *appletb_alloc_device(void)
+{
+	struct appletb_device *tb_dev;
+
+	tb_dev = kzalloc(sizeof(*tb_dev), GFP_KERNEL);
+	if (!tb_dev)
+		return NULL;
+
+	spin_lock_init(&tb_dev->tb_lock);
+	INIT_DELAYED_WORK(&tb_dev->tb_work, appletb_set_tb_worker);
+
+	return tb_dev;
+}
+
+static void appletb_free_device(struct appletb_device *tb_dev)
+{
+	cancel_delayed_work_sync(&tb_dev->tb_work);
+	kfree(tb_dev);
+}
+
+static const struct hid_device_id appletb_hid_ids[] = {
+	/* MacBook Pro's 2016, 2017, with T1 chip */
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LINUX_FOUNDATION,
+			 USB_DEVICE_ID_IBRIDGE_TB),
+	  .driver_data = APPLETB_FEATURE_IS_T1 },
+	/* MacBook Pro's 2018, 2019, with T2 chip: iBridge DFR brightness */
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
+			USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT) },
+	/* MacBook Pro's 2018, 2019, with T2 chip: iBridge Display */
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE,
+			USB_DEVICE_ID_APPLE_TOUCHBAR_DISPLAY) },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(hid, appletb_hid_ids);
+
+static struct hid_driver appletb_hid_driver = {
+	.name = "apple-touchbar",
+	.id_table = appletb_hid_ids,
+	.probe = appletb_probe,
+	.remove = appletb_remove,
+	.event = appletb_hid_event,
+	.input_configured = appletb_input_configured,
+#ifdef CONFIG_PM
+	.suspend = appletb_suspend,
+	.reset_resume = appletb_reset_resume,
+#endif
+};
+
+static int __init appletb_init(void)
+{
+	struct appletb_device *tb_dev;
+	int rc;
+
+	tb_dev = appletb_alloc_device();
+	if (!tb_dev)
+		return -ENOMEM;
+
+	appletb_dev = tb_dev;
+
+	rc = hid_register_driver(&appletb_hid_driver);
+	if (rc)
+		goto error;
+
+	return 0;
+
+error:
+	appletb_free_device(tb_dev);
+	return rc;
+}
+
+static void __exit appletb_exit(void)
+{
+	hid_unregister_driver(&appletb_hid_driver);
+	appletb_free_device(appletb_dev);
+}
+
+module_init(appletb_init);
+module_exit(appletb_exit);
+
+MODULE_AUTHOR("Ronald Tschalär");
+MODULE_DESCRIPTION("MacBookPro Touch Bar driver");
+MODULE_LICENSE("GPL");
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-apple-magic-backlight.c b/linux-6.6.38.igel/drivers/hid/hid-apple-magic-backlight.c
--- a/linux-6.6.38.igel/drivers/hid/hid-apple-magic-backlight.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/hid/hid-apple-magic-backlight.c	2024-08-02 15:41:31.547491394 +0200
@@ -0,0 +1,120 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Apple Magic Keyboard Backlight Driver
+ *
+ * For Intel Macs with internal Magic Keyboard (MacBookPro16,1-4 and MacBookAir9,1)
+ *
+ * Copyright (c) 2022 Kerem Karabay <kekrby@gmail.com>
+ * Copyright (c) 2023 Orlando Chamberlain <orlandoch.dev@gmail.com>
+ */
+
+#include <linux/hid.h>
+#include <linux/leds.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <dt-bindings/leds/common.h>
+
+#include "hid-ids.h"
+
+#define HID_USAGE_MAGIC_BL	0xff00000f
+
+#define APPLE_MAGIC_REPORT_ID_POWER 3
+#define APPLE_MAGIC_REPORT_ID_BRIGHTNESS 1
+
+struct apple_magic_backlight {
+	struct led_classdev cdev;
+	struct hid_report *brightness;
+	struct hid_report *power;
+};
+
+static void apple_magic_backlight_report_set(struct hid_report *rep, s32 value, u8 rate)
+{
+	rep->field[0]->value[0] = value;
+	rep->field[1]->value[0] = 0x5e; /* Mimic Windows */
+	rep->field[1]->value[0] |= rate << 8;
+
+	hid_hw_request(rep->device, rep, HID_REQ_SET_REPORT);
+}
+
+static void apple_magic_backlight_set(struct apple_magic_backlight *backlight,
+				     int brightness, char rate)
+{
+	apple_magic_backlight_report_set(backlight->power, brightness ? 1 : 0, rate);
+	if (brightness)
+		apple_magic_backlight_report_set(backlight->brightness, brightness, rate);
+}
+
+static int apple_magic_backlight_led_set(struct led_classdev *led_cdev,
+					 enum led_brightness brightness)
+{
+	struct apple_magic_backlight *backlight = container_of(led_cdev,
+			struct apple_magic_backlight, cdev);
+
+	apple_magic_backlight_set(backlight, brightness, 1);
+	return 0;
+}
+
+static int apple_magic_backlight_probe(struct hid_device *hdev,
+				       const struct hid_device_id *id)
+{
+	struct apple_magic_backlight *backlight;
+	int rc;
+
+	rc = hid_parse(hdev);
+	if (rc)
+		return rc;
+
+	/*
+	 * Ensure this usb endpoint is for the keyboard backlight, not touchbar
+	 * backlight.
+	 */
+	if (hdev->collection[0].usage != HID_USAGE_MAGIC_BL)
+		return -ENODEV;
+
+	backlight = devm_kzalloc(&hdev->dev, sizeof(*backlight), GFP_KERNEL);
+	if (!backlight)
+		return -ENOMEM;
+
+	rc = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+	if (rc)
+		return rc;
+
+	backlight->brightness = hid_register_report(hdev, HID_FEATURE_REPORT,
+			APPLE_MAGIC_REPORT_ID_BRIGHTNESS, 0);
+	backlight->power = hid_register_report(hdev, HID_FEATURE_REPORT,
+			APPLE_MAGIC_REPORT_ID_POWER, 0);
+
+	if (!backlight->brightness || !backlight->power) {
+		rc = -ENODEV;
+		goto hw_stop;
+	}
+
+	backlight->cdev.name = ":white:" LED_FUNCTION_KBD_BACKLIGHT;
+	backlight->cdev.max_brightness = backlight->brightness->field[0]->logical_maximum;
+	backlight->cdev.brightness_set_blocking = apple_magic_backlight_led_set;
+
+	apple_magic_backlight_set(backlight, 0, 0);
+
+	return devm_led_classdev_register(&hdev->dev, &backlight->cdev);
+
+hw_stop:
+	hid_hw_stop(hdev);
+	return rc;
+}
+
+static const struct hid_device_id apple_magic_backlight_hid_ids[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT) },
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, apple_magic_backlight_hid_ids);
+
+static struct hid_driver apple_magic_backlight_hid_driver = {
+	.name = "hid-apple-magic-backlight",
+	.id_table = apple_magic_backlight_hid_ids,
+	.probe = apple_magic_backlight_probe,
+};
+module_hid_driver(apple_magic_backlight_hid_driver);
+
+MODULE_DESCRIPTION("MacBook Magic Keyboard Backlight");
+MODULE_AUTHOR("Orlando Chamberlain <orlandoch.dev@gmail.com>");
+MODULE_LICENSE("GPL");
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-ids.h b/linux-6.6.38.igel/drivers/hid/hid-ids.h
--- a/linux-6.6.38.igel/drivers/hid/hid-ids.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/hid-ids.h	2024-08-02 15:41:31.547491394 +0200
@@ -17,6 +17,12 @@
 #define USB_VENDOR_ID_258A		0x258a
 #define USB_DEVICE_ID_258A_6A88		0x6a88
 
+#ifdef CONFIG_IGEL_3DCONNEXION_BATTERY_QUIRK
+#define USB_VENDOR_ID_3DCONNEXION	0x256f
+#define USB_DEVICE_ID_3DCONNEXION_SM_W	0xc62e
+#define USB_DEVIDE_ID_3DCONNEXION_SM_PRO_W	0xc631
+#endif
+
 #define USB_VENDOR_ID_3M		0x0596
 #define USB_DEVICE_ID_3M1968		0x0500
 #define USB_DEVICE_ID_3M2256		0x0502
@@ -187,6 +193,9 @@
 #define USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_NUMPAD_2021   0x029f
 #define USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT 0x8102
 #define USB_DEVICE_ID_APPLE_TOUCHBAR_DISPLAY 0x8302
+#ifdef CONFIG_IGEL_APPLE_HID_CHANGES
+#define USB_DEVICE_ID_APPLE_IBRIDGE	0x8600
+#endif
 
 #define USB_VENDOR_ID_ASUS		0x0486
 #define USB_DEVICE_ID_ASUS_T91MT	0x0185
@@ -1363,6 +1372,10 @@
 #define USB_VENDOR_ID_WACOM		0x056a
 #define USB_DEVICE_ID_WACOM_GRAPHIRE_BLUETOOTH	0x81
 #define USB_DEVICE_ID_WACOM_INTUOS4_BLUETOOTH   0x00BD
+#ifdef CONFIG_IGEL_WACOM_BAMBOO_QUIRK
+#define USB_DEVICE_ID_WACOM_BAMBOO_PAD_CTH301   0x0318
+#define USB_DEVICE_ID_WACOM_BAMBOO_PAD_CTH300   0x0319
+#endif
 
 #define USB_VENDOR_ID_WALTOP				0x172f
 #define USB_DEVICE_ID_WALTOP_SLIM_TABLET_5_8_INCH	0x0032
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-input.c b/linux-6.6.38.igel/drivers/hid/hid-input.c
--- a/linux-6.6.38.igel/drivers/hid/hid-input.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/hid-input.c	2024-08-02 15:41:31.547491394 +0200
@@ -413,6 +413,12 @@ static const struct hid_device_id hid_ba
 	  HID_BATTERY_QUIRK_IGNORE },
 	{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, I2C_DEVICE_ID_CHROMEBOOK_TROGDOR_POMPOM),
 	  HID_BATTERY_QUIRK_AVOID_QUERY },
+#ifdef CONFIG_IGEL_3DCONNEXION_BATTERY_QUIRK
+	{ HID_USB_DEVICE(USB_VENDOR_ID_3DCONNEXION, USB_DEVICE_ID_3DCONNEXION_SM_W),
+	  HID_BATTERY_QUIRK_IGNORE },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_3DCONNEXION, USB_DEVIDE_ID_3DCONNEXION_SM_PRO_W),
+	  HID_BATTERY_QUIRK_IGNORE },
+#endif
 	{}
 };
 
@@ -1730,7 +1736,16 @@ void hidinput_hid_event(struct hid_devic
 	    (!test_bit(usage->code, input->key)) == value)
 		input_event(input, EV_MSC, MSC_SCAN, usage->hid);
 
+#ifdef CONFIG_IGEL_TC236_TOUCH_QUIRK
+	/* freund@igel: fix TC236 touch with hid-core driver */
+	if (hid->vendor==USB_VENDOR_ID_XAT && hid->product==USB_DEVICE_ID_XAT_CSR
+	    && usage->type==EV_ABS && value==0)
+		dbg_hid("suppress EV_ABS with zero values on HID-TR-V1\n");
+	else
+		input_event(input, usage->type, usage->code, value);
+#else
 	input_event(input, usage->type, usage->code, value);
+#endif
 
 	if ((field->flags & HID_MAIN_ITEM_RELATIVE) &&
 	    usage->type == EV_KEY && value) {
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-multitouch.c b/linux-6.6.38.igel/drivers/hid/hid-multitouch.c
--- a/linux-6.6.38.igel/drivers/hid/hid-multitouch.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/hid-multitouch.c	2024-08-02 15:41:31.547491394 +0200
@@ -34,7 +34,14 @@
 #include <linux/device.h>
 #include <linux/hid.h>
 #include <linux/module.h>
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#include <linux/pm_runtime.h>
+#endif
 #include <linux/slab.h>
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#include <linux/suspend.h>
+#include <linux/usb.h>
+#endif
 #include <linux/input/mt.h>
 #include <linux/jiffies.h>
 #include <linux/string.h>
@@ -47,6 +54,9 @@ MODULE_DESCRIPTION("HID multitouch panel
 MODULE_LICENSE("GPL");
 
 #include "hid-ids.h"
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#include "usbhid/usbhid.h"
+#endif
 
 /* quirks to control the device */
 #define MT_QUIRK_NOT_SEEN_MEANS_UP	BIT(0)
@@ -72,12 +82,22 @@ MODULE_LICENSE("GPL");
 #define MT_QUIRK_FORCE_MULTI_INPUT	BIT(20)
 #define MT_QUIRK_DISABLE_WAKEUP		BIT(21)
 #define MT_QUIRK_ORIENTATION_INVERT	BIT(22)
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#define MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT	BIT(23)
+#define MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH	BIT(24)
+#endif
 
 #define MT_INPUTMODE_TOUCHSCREEN	0x02
 #define MT_INPUTMODE_TOUCHPAD		0x03
 
 #define MT_BUTTONTYPE_CLICKPAD		0
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#define MS_TYPE_COVER_FEATURE_REPORT_USAGE	0xff050086
+#define MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE	0xff050072
+#define MS_TYPE_COVER_APPLICATION	0xff050050
+#endif
+
 enum latency_mode {
 	HID_LATENCY_NORMAL = 0,
 	HID_LATENCY_HIGH = 1,
@@ -169,6 +189,10 @@ struct mt_device {
 
 	struct list_head applications;
 	struct list_head reports;
+
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct notifier_block pm_notifier;
+#endif
 };
 
 static void mt_post_parse_default_settings(struct mt_device *td,
@@ -213,6 +237,9 @@ static void mt_post_parse(struct mt_devi
 #define MT_CLS_GOOGLE				0x0111
 #define MT_CLS_RAZER_BLADE_STEALTH		0x0112
 #define MT_CLS_SMART_TECH			0x0113
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+#define MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER	0x0114
+#endif
 
 #define MT_DEFAULT_MAXCONTACT	10
 #define MT_MAX_MAXCONTACT	250
@@ -397,6 +424,19 @@ static const struct mt_class mt_classes[
 			MT_QUIRK_CONTACT_CNT_ACCURATE |
 			MT_QUIRK_SEPARATE_APP_REPORT,
 	},
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	{ .name = MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER,
+		.quirks = MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT |
+			MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH |
+			MT_QUIRK_ALWAYS_VALID |
+			MT_QUIRK_IGNORE_DUPLICATES |
+			MT_QUIRK_HOVERING |
+			MT_QUIRK_CONTACT_CNT_ACCURATE |
+			MT_QUIRK_STICKY_FINGERS |
+			MT_QUIRK_WIN8_PTP_BUTTONS,
+		.export_all_inputs = true
+	},
+#endif
 	{ }
 };
 
@@ -1370,6 +1410,11 @@ static int mt_input_mapping(struct hid_d
 	    field->application != HID_CP_CONSUMER_CONTROL &&
 	    field->application != HID_GD_WIRELESS_RADIO_CTLS &&
 	    field->application != HID_GD_SYSTEM_MULTIAXIS &&
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	    !(field->application == MS_TYPE_COVER_APPLICATION &&
+	      application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	      usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) &&
+#endif
 	    !(field->application == HID_VD_ASUS_CUSTOM_MEDIA_KEYS &&
 	      application->quirks & MT_QUIRK_ASUS_CUSTOM_UP))
 		return -1;
@@ -1397,6 +1442,23 @@ static int mt_input_mapping(struct hid_d
 		return 1;
 	}
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	/*
+	 * The Microsoft Surface Pro Typecover has a non-standard HID
+	 * tablet mode switch on a vendor specific usage page with vendor
+	 * specific usage.
+	 */
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		usage->type = EV_SW;
+		usage->code = SW_TABLET_MODE;
+		*max = SW_MAX;
+		*bit = hi->input->swbit;
+		return 1;
+	}
+#endif
+
 	if (rdata->is_mt_collection)
 		return mt_touch_input_mapping(hdev, hi, field, usage, bit, max,
 					      application);
@@ -1418,6 +1480,9 @@ static int mt_input_mapped(struct hid_de
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
 	struct mt_report_data *rdata;
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct input_dev *input;
+#endif
 
 	rdata = mt_find_report_data(td, field->report);
 	if (rdata && rdata->is_mt_collection) {
@@ -1425,6 +1490,21 @@ static int mt_input_mapped(struct hid_de
 		return -1;
 	}
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	/*
+	 * We own an input device which acts as a tablet mode switch for
+	 * the Surface Pro Typecover.
+	 */
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    rdata->application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		input = hi->input;
+		input_set_capability(input, EV_SW, SW_TABLET_MODE);
+		input_report_switch(input, SW_TABLET_MODE, 0);
+		return -1;
+	}
+#endif
+
 	/* let hid-core decide for the others */
 	return 0;
 }
@@ -1434,11 +1514,25 @@ static int mt_event(struct hid_device *h
 {
 	struct mt_device *td = hid_get_drvdata(hid);
 	struct mt_report_data *rdata;
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct input_dev *input;
+#endif
 
 	rdata = mt_find_report_data(td, field->report);
 	if (rdata && rdata->is_mt_collection)
 		return mt_touch_event(hid, field, usage, value);
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	if (field->application == MS_TYPE_COVER_APPLICATION &&
+	    rdata->application->quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH &&
+	    usage->hid == MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE) {
+		input = field->hidinput->input;
+		input_report_switch(input, SW_TABLET_MODE, (value & 0xFF) != 0x22);
+		input_sync(input);
+		return 1;
+	}
+#endif
+
 	return 0;
 }
 
@@ -1591,6 +1685,44 @@ static void mt_post_parse(struct mt_devi
 		app->quirks &= ~MT_QUIRK_CONTACT_CNT_ACCURATE;
 }
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+static int get_type_cover_field(struct hid_report_enum *rep_enum,
+				struct hid_field **field, int usage)
+{
+	struct hid_report *rep;
+	struct hid_field *cur_field;
+	int i, j;
+
+	list_for_each_entry(rep, &rep_enum->report_list, list) {
+		for (i = 0; i < rep->maxfield; i++) {
+			cur_field = rep->field[i];
+			if (cur_field->application != MS_TYPE_COVER_APPLICATION)
+				continue;
+			for (j = 0; j < cur_field->maxusage; j++) {
+				if (cur_field->usage[j].hid == usage) {
+					*field = cur_field;
+					return true;
+				}
+			}
+		}
+	}
+	return false;
+}
+
+static void request_type_cover_tablet_mode_switch(struct hid_device *hdev)
+{
+	struct hid_field *field;
+
+	if (get_type_cover_field(&hdev->report_enum[HID_INPUT_REPORT],
+				 &field,
+				 MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE)) {
+		hid_hw_request(hdev, field->report, HID_REQ_GET_REPORT);
+	} else {
+		hid_err(hdev, "couldn't find tablet mode field\n");
+	}
+}
+#endif
+
 static int mt_input_configured(struct hid_device *hdev, struct hid_input *hi)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
@@ -1639,6 +1771,15 @@ static int mt_input_configured(struct hi
 		/* force BTN_STYLUS to allow tablet matching in udev */
 		__set_bit(BTN_STYLUS, hi->input->keybit);
 		break;
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	case MS_TYPE_COVER_APPLICATION:
+		if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH) {
+			suffix = "Tablet Mode Switch";
+			request_type_cover_tablet_mode_switch(hdev);
+			break;
+		}
+		fallthrough;
+#endif
 	default:
 		suffix = "UNKNOWN";
 		break;
@@ -1721,6 +1862,48 @@ static void mt_expired_timeout(struct ti
 	clear_bit_unlock(MT_IO_FLAGS_RUNNING, &td->mt_io_flags);
 }
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+static void update_keyboard_backlight(struct hid_device *hdev, bool enabled)
+{
+	struct usb_device *udev = hid_to_usb_dev(hdev);
+	struct hid_field *field = NULL;
+
+	/* Wake up the device in case it's already suspended */
+	pm_runtime_get_sync(&udev->dev);
+
+	if (!get_type_cover_field(&hdev->report_enum[HID_FEATURE_REPORT],
+				  &field,
+				  MS_TYPE_COVER_FEATURE_REPORT_USAGE)) {
+		hid_err(hdev, "couldn't find backlight field\n");
+		goto out;
+	}
+
+	field->value[field->index] = enabled ? 0x01ff00ff : 0x00ff00ff;
+	hid_hw_request(hdev, field->report, HID_REQ_SET_REPORT);
+
+out:
+	pm_runtime_put_sync(&udev->dev);
+}
+
+static int mt_pm_notifier(struct notifier_block *notifier,
+			  unsigned long pm_event,
+			  void *unused)
+{
+	struct mt_device *td =
+		container_of(notifier, struct mt_device, pm_notifier);
+	struct hid_device *hdev = td->hdev;
+
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_BACKLIGHT) {
+		if (pm_event == PM_SUSPEND_PREPARE)
+			update_keyboard_backlight(hdev, 0);
+		else if (pm_event == PM_POST_SUSPEND)
+			update_keyboard_backlight(hdev, 1);
+	}
+
+	return NOTIFY_DONE;
+}
+#endif
+
 static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)
 {
 	int ret, i;
@@ -1744,6 +1927,11 @@ static int mt_probe(struct hid_device *h
 	td->inputmode_value = MT_INPUTMODE_TOUCHSCREEN;
 	hid_set_drvdata(hdev, td);
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	td->pm_notifier.notifier_call = mt_pm_notifier;
+	register_pm_notifier(&td->pm_notifier);
+#endif
+
 	INIT_LIST_HEAD(&td->applications);
 	INIT_LIST_HEAD(&td->reports);
 
@@ -1782,15 +1970,29 @@ static int mt_probe(struct hid_device *h
 	timer_setup(&td->release_timer, mt_expired_timeout, 0);
 
 	ret = hid_parse(hdev);
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	if (ret != 0) {
+		unregister_pm_notifier(&td->pm_notifier);
+		return ret;
+	}
+#else
 	if (ret != 0)
 		return ret;
+#endif
 
 	if (mtclass->quirks & MT_QUIRK_FIX_CONST_CONTACT_ID)
 		mt_fix_const_fields(hdev, HID_DG_CONTACTID);
 
 	ret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	if (ret) {
+		unregister_pm_notifier(&td->pm_notifier);
+		return ret;
+	}
+#else
 	if (ret)
 		return ret;
+#endif
 
 	ret = sysfs_create_group(&hdev->dev.kobj, &mt_attribute_group);
 	if (ret)
@@ -1819,13 +2021,30 @@ static int mt_suspend(struct hid_device
 
 static int mt_reset_resume(struct hid_device *hdev)
 {
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct mt_device *td = hid_get_drvdata(hdev);
+#endif
+
 	mt_release_contacts(hdev);
 	mt_set_modes(hdev, HID_LATENCY_NORMAL, true, true);
+
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	/* Request an update on the typecover folding state on resume
+	 * after reset.
+	 */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH)
+		request_type_cover_tablet_mode_switch(hdev);
+#endif
+
 	return 0;
 }
 
 static int mt_resume(struct hid_device *hdev)
 {
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct mt_device *td = hid_get_drvdata(hdev);
+#endif
+
 	/* Some Elan legacy devices require SET_IDLE to be set on resume.
 	 * It should be safe to send it to other devices too.
 	 * Tested on 3M, Stantum, Cypress, Zytronic, eGalax, and Elan panels. */
@@ -1834,6 +2053,12 @@ static int mt_resume(struct hid_device *
 
 	mt_set_modes(hdev, HID_LATENCY_NORMAL, true, true);
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	/* Request an update on the typecover folding state on resume. */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH)
+		request_type_cover_tablet_mode_switch(hdev);
+#endif
+
 	return 0;
 }
 #endif
@@ -1841,7 +2066,25 @@ static int mt_resume(struct hid_device *
 static void mt_remove(struct hid_device *hdev)
 {
 	struct mt_device *td = hid_get_drvdata(hdev);
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	struct hid_field *field;
+	struct input_dev *input;
 
+	/* Reset tablet mode switch on disconnect. */
+	if (td->mtclass.quirks & MT_QUIRK_HAS_TYPE_COVER_TABLET_MODE_SWITCH) {
+		if (get_type_cover_field(&hdev->report_enum[HID_INPUT_REPORT],
+					 &field,
+					 MS_TYPE_COVER_TABLET_MODE_SWITCH_USAGE)) {
+			input = field->hidinput->input;
+			input_report_switch(input, SW_TABLET_MODE, 0);
+			input_sync(input);
+		} else {
+			hid_err(hdev, "couldn't find tablet mode field\n");
+		}
+	}
+
+	unregister_pm_notifier(&td->pm_notifier);
+#endif
 	del_timer_sync(&td->release_timer);
 
 	sysfs_remove_group(&hdev->dev.kobj, &mt_attribute_group);
@@ -2238,6 +2481,13 @@ static const struct hid_device_id mt_dev
 		MT_USB_DEVICE(USB_VENDOR_ID_XIROKU,
 			USB_DEVICE_ID_XIROKU_CSR2) },
 
+#ifdef CONFIG_IGEL_SURFACE_COVER_QUIRK
+	/* Microsoft Surface type cover */
+	{ .driver_data = MT_CLS_WIN_8_MS_SURFACE_TYPE_COVER,
+		HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY,
+			USB_VENDOR_ID_MICROSOFT, 0x09c0) },
+#endif
+
 	/* Google MT devices */
 	{ .driver_data = MT_CLS_GOOGLE,
 		HID_DEVICE(HID_BUS_ANY, HID_GROUP_ANY, USB_VENDOR_ID_GOOGLE,
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-quirks.c b/linux-6.6.38.igel/drivers/hid/hid-quirks.c
--- a/linux-6.6.38.igel/drivers/hid/hid-quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/hid-quirks.c	2024-08-02 15:41:31.547491394 +0200
@@ -226,6 +226,10 @@ static const struct hid_device_id hid_qu
  * used as a driver. See hid_scan_report().
  */
 static const struct hid_device_id hid_have_special_driver[] = {
+#ifdef CONFIG_IGEL_3DCONNEXION_BATTERY_QUIRK
+	{ HID_USB_DEVICE(USB_VENDOR_ID_3DCONNEXION, USB_DEVICE_ID_3DCONNEXION_SM_W) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_3DCONNEXION, USB_DEVIDE_ID_3DCONNEXION_SM_PRO_W) },
+#endif
 #if IS_ENABLED(CONFIG_HID_A4TECH)
 	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },
@@ -328,6 +332,11 @@ static const struct hid_device_id hid_ha
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER1_TP_ONLY) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_2021) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MAGIC_KEYBOARD_FINGERPRINT_2021) },
+#endif
+#if IS_ENABLED(CONFIG_HID_APPLE_IBRIDGE)
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IBRIDGE) },
+#endif
+#if IS_ENABLED(CONFIG_HID_APPLE_TOUCHBAR)
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_TOUCHBAR_BACKLIGHT) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_TOUCHBAR_DISPLAY) },
 #endif
@@ -979,6 +988,14 @@ bool hid_ignore(struct hid_device *hdev)
 		return true;
 
 	switch (hdev->vendor) {
+#ifdef CONFIG_IGEL_WACOM_BAMBOO_QUIRK
+	/* gottwald@igel.com Better to use standard HID for this WACOM devices */
+	case USB_VENDOR_ID_WACOM:
+		if (hdev->product == USB_DEVICE_ID_WACOM_BAMBOO_PAD_CTH301 ||
+			hdev->product == USB_DEVICE_ID_WACOM_BAMBOO_PAD_CTH300)
+			return false;
+		break;
+#endif
 	case USB_VENDOR_ID_CODEMERCS:
 		/* ignore all Code Mercenaries IOWarrior devices */
 		if (hdev->product >= USB_DEVICE_ID_CODEMERCS_IOW_FIRST &&
diff -Naurp a/linux-6.6.38.igel/drivers/hid/hid-sensor-hub.c b/linux-6.6.38.igel/drivers/hid/hid-sensor-hub.c
--- a/linux-6.6.38.igel/drivers/hid/hid-sensor-hub.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/hid-sensor-hub.c	2024-08-02 15:41:31.547491394 +0200
@@ -506,11 +506,19 @@ static int sensor_hub_raw_event(struct h
 		hid_dbg(hdev, "collection->usage %x\n",
 					collection->usage);
 
+#ifdef IGEL_APPLE_HID_CHANGES
+		callback = sensor_hub_get_callback(hdev,
+				report->field[i]->physical ?:
+					report->field[i]->application,
+				report->field[i]->usage[0].collection_index,
+				&hsdev, &priv);
+#else
 		callback = sensor_hub_get_callback(hdev,
 				report->field[i]->physical ? report->field[i]->physical :
 							     report->field[i]->application,
 				report->field[i]->usage[0].collection_index,
 				&hsdev, &priv);
+#endif
 		if (!callback) {
 			ptr += sz;
 			continue;
diff -Naurp a/linux-6.6.38.igel/drivers/hid/Kconfig b/linux-6.6.38.igel/drivers/hid/Kconfig
--- a/linux-6.6.38.igel/drivers/hid/Kconfig	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/Kconfig	2024-08-02 15:41:31.547491394 +0200
@@ -137,6 +137,45 @@ config HID_APPLE
 	Say Y here if you want support for keyboards of	Apple iBooks, PowerBooks,
 	MacBooks, MacBook Pros and Apple Aluminum.
 
+config HID_APPLE_IBRIDGE
+	tristate "Apple iBridge"
+	depends on USB_HID
+	depends on (X86 && ACPI) || COMPILE_TEST
+	imply HID_APPLE_TOUCHBAR
+	imply HID_SENSOR_HUB
+	imply HID_SENSOR_ALS
+	help
+	This module provides the core support for the Apple T1 chip found
+	on 2016 and 2017 MacBookPro's, also known as the iBridge. The drivers
+	for the Touch Bar (apple-touchbar) and light sensor (hid-sensor-hub
+	and hid-sensor-als) need to be enabled separately.
+
+	To compile this driver as a module, choose M here: the
+	module will be called apple-ibridge.
+
+config HID_APPLE_TOUCHBAR
+	tristate "Apple Touch Bar"
+	depends on USB_HID
+	help
+	Say Y here if you want support for the Touch Bar on x86
+	MacBook Pros.
+
+	To compile this driver as a module, choose M here: the
+	module will be called apple-touchbar.
+
+config HID_APPLE_MAGIC_BACKLIGHT
+	tristate "Apple Magic Keyboard Backlight"
+	depends on USB_HID
+	depends on LEDS_CLASS
+	depends on NEW_LEDS
+	help
+	Say Y here if you want support for the keyboard backlight on Macs with
+	the magic keyboard (MacBookPro16,x and MacBookAir9,1). Note that this
+	driver is not for external magic keyboards.
+
+	To compile this driver as a module, choose M here: the
+	module will be called hid-apple-magic-backlight.
+
 config HID_APPLEIR
 	tristate "Apple infrared receiver"
 	depends on (USB_HID)
diff -Naurp a/linux-6.6.38.igel/drivers/hid/Makefile b/linux-6.6.38.igel/drivers/hid/Makefile
--- a/linux-6.6.38.igel/drivers/hid/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hid/Makefile	2024-08-02 15:41:31.547491394 +0200
@@ -28,6 +28,9 @@ obj-$(CONFIG_HID_ACCUTOUCH)	+= hid-accut
 obj-$(CONFIG_HID_ALPS)		+= hid-alps.o
 obj-$(CONFIG_HID_ACRUX)		+= hid-axff.o
 obj-$(CONFIG_HID_APPLE)		+= hid-apple.o
+obj-$(CONFIG_HID_APPLE_IBRIDGE)	+= apple-ibridge.o
+obj-$(CONFIG_HID_APPLE_TOUCHBAR)	+= apple-touchbar.o
+obj-$(CONFIG_HID_APPLE_MAGIC_BACKLIGHT)	+= hid-apple-magic-backlight.o
 obj-$(CONFIG_HID_APPLEIR)	+= hid-appleir.o
 obj-$(CONFIG_HID_CREATIVE_SB0540)	+= hid-creative-sb0540.o
 obj-$(CONFIG_HID_ASUS)		+= hid-asus.o
diff -Naurp a/linux-6.6.38.igel/drivers/hwmon/applesmc.c b/linux-6.6.38.igel/drivers/hwmon/applesmc.c
--- a/linux-6.6.38.igel/drivers/hwmon/applesmc.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hwmon/applesmc.c	2024-08-02 15:41:31.547491394 +0200
@@ -1,3 +1,1967 @@
+#ifdef CONFIG_IGEL_USE_PATCHED_APPLESMC
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * drivers/hwmon/applesmc.c - driver for Apple's SMC (accelerometer, temperature
+ * sensors, fan control, keyboard backlight control) used in Intel-based Apple
+ * computers.
+ *
+ * Copyright (C) 2007 Nicolas Boichat <nicolas@boichat.ch>
+ * Copyright (C) 2010 Henrik Rydberg <rydberg@euromail.se>
+ * Copyright (C) 2019 Paul Pawlowski <paul@mrarm.io>
+ *
+ * Based on hdaps.c driver:
+ * Copyright (C) 2005 Robert Love <rml@novell.com>
+ * Copyright (C) 2005 Jesper Juhl <jj@chaosbits.net>
+ *
+ * Fan control based on smcFanControl:
+ * Copyright (C) 2006 Hendrik Holtmann <holtmann@mac.com>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/dmi.h>
+#include <linux/mutex.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/hwmon.h>
+#include <linux/workqueue.h>
+#include <linux/err.h>
+#include <linux/bits.h>
+
+/* data port used by Apple SMC */
+#define APPLESMC_DATA_PORT	0
+/* command/status port used by Apple SMC */
+#define APPLESMC_CMD_PORT	4
+
+#define APPLESMC_NR_PORTS	32 /* 0x300-0x31f */
+
+#define APPLESMC_IOMEM_KEY_DATA	0
+#define APPLESMC_IOMEM_KEY_STATUS	0x4005
+#define APPLESMC_IOMEM_KEY_NAME	0x78
+#define APPLESMC_IOMEM_KEY_DATA_LEN	0x7D
+#define APPLESMC_IOMEM_KEY_SMC_ID	0x7E
+#define APPLESMC_IOMEM_KEY_CMD		0x7F
+#define APPLESMC_IOMEM_MIN_SIZE	0x4006
+
+#define APPLESMC_IOMEM_KEY_TYPE_CODE		0
+#define APPLESMC_IOMEM_KEY_TYPE_DATA_LEN	5
+#define APPLESMC_IOMEM_KEY_TYPE_FLAGS		6
+
+#define APPLESMC_MAX_DATA_LENGTH 32
+
+/* Apple SMC status bits */
+#define SMC_STATUS_AWAITING_DATA  BIT(0) /* SMC has data waiting to be read */
+#define SMC_STATUS_IB_CLOSED      BIT(1) /* Will ignore any input */
+#define SMC_STATUS_BUSY           BIT(2) /* Command in progress */
+
+/* Initial wait is 8us */
+#define APPLESMC_MIN_WAIT      0x0008
+
+#define APPLESMC_READ_CMD	0x10
+#define APPLESMC_WRITE_CMD	0x11
+#define APPLESMC_GET_KEY_BY_INDEX_CMD	0x12
+#define APPLESMC_GET_KEY_TYPE_CMD	0x13
+
+#define KEY_COUNT_KEY		"#KEY" /* r-o ui32 */
+
+#define LIGHT_SENSOR_LEFT_KEY	"ALV0" /* r-o {alv (6-10 bytes) */
+#define LIGHT_SENSOR_RIGHT_KEY	"ALV1" /* r-o {alv (6-10 bytes) */
+#define BACKLIGHT_KEY		"LKSB" /* w-o {lkb (2 bytes) */
+
+#define CLAMSHELL_KEY		"MSLD" /* r-o ui8 (unused) */
+
+#define MOTION_SENSOR_X_KEY	"MO_X" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_Y_KEY	"MO_Y" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_Z_KEY	"MO_Z" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_KEY	"MOCN" /* r/w ui16 */
+
+#define FANS_COUNT		"FNum" /* r-o ui8 */
+#define FANS_MANUAL		"FS! " /* r-w ui16 */
+#define FAN_ID_FMT		"F%dID" /* r-o char[16] */
+
+#define TEMP_SENSOR_TYPE	"sp78"
+#define FLOAT_TYPE		"flt "
+
+/* List of keys used to read/write fan speeds */
+static const char *const fan_speed_fmt[] = {
+	"F%dAc",		/* actual speed */
+	"F%dMn",		/* minimum speed (rw) */
+	"F%dMx",		/* maximum speed */
+	"F%dSf",		/* safe speed - not all models */
+	"F%dTg",		/* target speed (manual: rw) */
+};
+#define FAN_MANUAL_FMT "F%dMd"
+
+#define INIT_TIMEOUT_MSECS	5000	/* wait up to 5s for device init ... */
+#define INIT_WAIT_MSECS		50	/* ... in 50ms increments */
+
+#define APPLESMC_POLL_INTERVAL	50	/* msecs */
+#define APPLESMC_INPUT_FUZZ	4	/* input event threshold */
+#define APPLESMC_INPUT_FLAT	4
+
+#define to_index(attr) (to_sensor_dev_attr(attr)->index & 0xffff)
+#define to_option(attr) (to_sensor_dev_attr(attr)->index >> 16)
+
+/* Dynamic device node attributes */
+struct applesmc_dev_attr {
+	struct sensor_device_attribute sda;	/* hwmon attributes */
+	char name[32];				/* room for node file name */
+};
+
+/* Dynamic device node group */
+struct applesmc_node_group {
+	char *format;				/* format string */
+	void *show;				/* show function */
+	void *store;				/* store function */
+	int option;				/* function argument */
+	struct applesmc_dev_attr *nodes;	/* dynamic node array */
+};
+
+/* AppleSMC entry - cached register information */
+struct applesmc_entry {
+	char key[5];		/* four-letter key code */
+	u8 valid;		/* set when entry is successfully read once */
+	u8 len;			/* bounded by APPLESMC_MAX_DATA_LENGTH */
+	char type[5];		/* four-letter type code */
+	u8 flags;		/* 0x10: func; 0x40: write; 0x80: read */
+};
+
+/* Register lookup and registers common to all SMCs */
+struct applesmc_registers {
+	struct mutex mutex;		/* register read/write mutex */
+	unsigned int key_count;		/* number of SMC registers */
+	unsigned int fan_count;		/* number of fans */
+	unsigned int temp_count;	/* number of temperature registers */
+	unsigned int temp_begin;	/* temperature lower index bound */
+	unsigned int temp_end;		/* temperature upper index bound */
+	unsigned int index_count;	/* size of temperature index array */
+	int num_light_sensors;		/* number of light sensors */
+	bool has_accelerometer;		/* has motion sensor */
+	bool has_key_backlight;		/* has keyboard backlight */
+	bool init_complete;		/* true when fully initialized */
+	struct applesmc_entry *cache;	/* cached key entries */
+	const char **index;		/* temperature key index */
+};
+
+struct applesmc_device {
+	struct acpi_device *dev;
+	struct device *ldev;
+	struct applesmc_registers reg;
+
+	bool port_base_set, iomem_base_set;
+	u16 port_base;
+	u8 *__iomem iomem_base;
+	u32 iomem_base_addr, iomem_base_size;
+
+	s16 rest_x;
+	s16 rest_y;
+
+	u8 backlight_state[2];
+
+	struct device *hwmon_dev;
+	struct input_dev *idev;
+
+	/*
+	 * Last index written to key_at_index sysfs file, and value to use for all other
+	 * key_at_index_* sysfs files.
+	 */
+	unsigned int key_at_index;
+
+	struct workqueue_struct *backlight_wq;
+	struct work_struct backlight_work;
+	struct led_classdev backlight_dev;
+};
+
+static const int debug;
+
+/*
+ * Wait for specific status bits with a mask on the SMC.
+ * Used before all transactions.
+ * This does 10 fast loops of 8us then exponentially backs off for a
+ * minimum total wait of 262ms. Depending on usleep_range this could
+ * run out past 500ms.
+ */
+
+static int port_wait_status(struct applesmc_device *smc, u8 val, u8 mask)
+{
+	u8 status;
+	int us;
+	int i;
+
+	us = APPLESMC_MIN_WAIT;
+	for (i = 0; i < 24 ; i++) {
+		status = inb(smc->port_base + APPLESMC_CMD_PORT);
+		if ((status & mask) == val)
+			return 0;
+		usleep_range(us, us * 2);
+		if (i > 9)
+			us <<= 1;
+	}
+	return -EIO;
+}
+
+/* port_send_byte - Write to SMC data port. Callers must hold applesmc_lock. */
+
+static int port_send_byte(struct applesmc_device *smc, u8 cmd, u16 port)
+{
+	int status;
+
+	status = port_wait_status(smc, 0, SMC_STATUS_IB_CLOSED);
+	if (status)
+		return status;
+	/*
+	 * This needs to be a separate read looking for bit 0x04
+	 * after bit 0x02 falls. If consolidated with the wait above
+	 * this extra read may not happen if status returns both
+	 * simultaneously and this would appear to be required.
+	 */
+	status = port_wait_status(smc, SMC_STATUS_BUSY, SMC_STATUS_BUSY);
+	if (status)
+		return status;
+
+	outb(cmd, smc->port_base + port);
+	return 0;
+}
+
+/* port_send_command - Write a command to the SMC. Callers must hold applesmc_lock. */
+
+static int port_send_command(struct applesmc_device *smc, u8 cmd)
+{
+	int ret;
+
+	ret = port_wait_status(smc, 0, SMC_STATUS_IB_CLOSED);
+	if (ret)
+		return ret;
+
+	outb(cmd, smc->port_base + APPLESMC_CMD_PORT);
+	return 0;
+}
+
+/*
+ * Based on logic from the Apple driver. This is issued before any interaction
+ * If busy is stuck high, issue a read command to reset the SMC state machine.
+ * If busy is stuck high after the command then the SMC is jammed.
+ */
+
+static int port_smc_sane(struct applesmc_device *smc)
+{
+	int ret;
+
+	ret = port_wait_status(smc, 0, SMC_STATUS_BUSY);
+	if (!ret)
+		return ret;
+	ret = port_send_command(smc, APPLESMC_READ_CMD);
+	if (ret)
+		return ret;
+	return port_wait_status(smc, 0, SMC_STATUS_BUSY);
+}
+
+static int port_send_argument(struct applesmc_device *smc, const char *key)
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		if (port_send_byte(smc, key[i], APPLESMC_DATA_PORT))
+			return -EIO;
+	return 0;
+}
+
+static int port_read_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	u8 *buffer, u8 len)
+{
+	u8 status, data = 0;
+	int i;
+	int ret;
+
+	ret = port_smc_sane(smc);
+	if (ret)
+		return ret;
+
+	if (port_send_command(smc, cmd) || port_send_argument(smc, key)) {
+		pr_warn("%.4s: read arg fail\n", key);
+		return -EIO;
+	}
+
+	/* This has no effect on newer (2012) SMCs */
+	if (port_send_byte(smc, len, APPLESMC_DATA_PORT)) {
+		pr_warn("%.4s: read len fail\n", key);
+		return -EIO;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (port_wait_status(smc,
+				SMC_STATUS_AWAITING_DATA | SMC_STATUS_BUSY,
+				SMC_STATUS_AWAITING_DATA | SMC_STATUS_BUSY)) {
+			pr_warn("%.4s: read data[%d] fail\n", key, i);
+			return -EIO;
+		}
+		buffer[i] = inb(smc->port_base + APPLESMC_DATA_PORT);
+	}
+
+	/* Read the data port until bit0 is cleared */
+	for (i = 0; i < 16; i++) {
+		udelay(APPLESMC_MIN_WAIT);
+		status = inb(smc->port_base + APPLESMC_CMD_PORT);
+		if (!(status & SMC_STATUS_AWAITING_DATA))
+			break;
+		data = inb(smc->port_base + APPLESMC_DATA_PORT);
+	}
+	if (i)
+		pr_warn("flushed %d bytes, last value is: %d\n", i, data);
+
+	return port_wait_status(smc, 0, SMC_STATUS_BUSY);
+}
+
+static int port_write_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	const u8 *buffer, u8 len)
+{
+	int i;
+	int ret;
+
+	ret = port_smc_sane(smc);
+	if (ret)
+		return ret;
+
+	if (port_send_command(smc, cmd) || port_send_argument(smc, key)) {
+		pr_warn("%s: write arg fail\n", key);
+		return -EIO;
+	}
+
+	if (port_send_byte(smc, len, APPLESMC_DATA_PORT)) {
+		pr_warn("%.4s: write len fail\n", key);
+		return -EIO;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (port_send_byte(smc, buffer[i], APPLESMC_DATA_PORT)) {
+			pr_warn("%s: write data fail\n", key);
+			return -EIO;
+		}
+	}
+
+	return port_wait_status(smc, 0, SMC_STATUS_BUSY);
+}
+
+static int port_get_smc_key_info(struct applesmc_device *smc,
+	const char *key, struct applesmc_entry *info)
+{
+	int ret;
+	u8 raw[6];
+
+	ret = port_read_smc(smc, APPLESMC_GET_KEY_TYPE_CMD, key, raw, 6);
+	if (ret)
+		return ret;
+	info->len = raw[0];
+	memcpy(info->type, &raw[1], 4);
+	info->flags = raw[5];
+	return 0;
+}
+
+
+/*
+ * MMIO based communication.
+ * TODO: Use updated mechanism for cmd timeout/retry
+ */
+
+static void iomem_clear_status(struct applesmc_device *smc)
+{
+	if (ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS))
+		iowrite8(0, smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+}
+
+static int iomem_wait_read(struct applesmc_device *smc)
+{
+	u8 status;
+	int us;
+	int i;
+
+	us = APPLESMC_MIN_WAIT;
+	for (i = 0; i < 24 ; i++) {
+		status = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+		if (status & 0x20)
+			return 0;
+		usleep_range(us, us * 2);
+		if (i > 9)
+			us <<= 1;
+	}
+
+	dev_warn(smc->ldev, "%s... timeout\n", __func__);
+	return -EIO;
+}
+
+static int iomem_read_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	u8 *buffer, u8 len)
+{
+	u8 err, remote_len;
+	u32 key_int = *((u32 *) key);
+
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd, smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+
+	if (iomem_wait_read(smc))
+		return -EIO;
+
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "read_smc_mmio(%x %8x/%.4s) failed: %u\n",
+				cmd, key_int, key, err);
+		return -EIO;
+	}
+
+	if (cmd == APPLESMC_READ_CMD) {
+		remote_len = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_DATA_LEN);
+		if (remote_len != len) {
+			dev_warn(smc->ldev,
+				 "read_smc_mmio(%x %8x/%.4s) failed: buffer length mismatch (remote = %u, requested = %u)\n",
+				 cmd, key_int, key, remote_len, len);
+			return -EINVAL;
+		}
+	} else {
+		remote_len = len;
+	}
+
+	memcpy_fromio(buffer, smc->iomem_base + APPLESMC_IOMEM_KEY_DATA,
+			remote_len);
+
+	dev_dbg(smc->ldev, "read_smc_mmio(%x %8x/%.4s): buflen=%u reslen=%u\n",
+			cmd, key_int, key, len, remote_len);
+	print_hex_dump_bytes("read_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, remote_len);
+	return 0;
+}
+
+static int iomem_get_smc_key_type(struct applesmc_device *smc, const char *key,
+	struct applesmc_entry *e)
+{
+	u8 err;
+	u8 cmd = APPLESMC_GET_KEY_TYPE_CMD;
+	u32 key_int = *((u32 *) key);
+
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd, smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+
+	if (iomem_wait_read(smc))
+		return -EIO;
+
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "get_smc_key_type_mmio(%.4s) failed: %u\n", key, err);
+		return -EIO;
+	}
+
+	e->len = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_DATA_LEN);
+	*((uint32_t *) e->type) = ioread32(
+			smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_CODE);
+	e->flags = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_FLAGS);
+
+	dev_dbg(smc->ldev, "get_smc_key_type_mmio(%.4s): len=%u type=%.4s flags=%x\n",
+		key, e->len, e->type, e->flags);
+	return 0;
+}
+
+static int iomem_write_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	const u8 *buffer, u8 len)
+{
+	u8 err;
+	u32 key_int = *((u32 *) key);
+
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	memcpy_toio(smc->iomem_base + APPLESMC_IOMEM_KEY_DATA, buffer, len);
+	iowrite32(len, smc->iomem_base + APPLESMC_IOMEM_KEY_DATA_LEN);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd, smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+
+	if (iomem_wait_read(smc))
+		return -EIO;
+
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "write_smc_mmio(%x %.4s) failed: %u\n", cmd, key, err);
+		print_hex_dump_bytes("write_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, len);
+		return -EIO;
+	}
+
+	dev_dbg(smc->ldev, "write_smc_mmio(%x %.4s): buflen=%u\n", cmd, key, len);
+	print_hex_dump_bytes("write_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, len);
+	return 0;
+}
+
+
+static int read_smc(struct applesmc_device *smc, const char *key,
+	u8 *buffer, u8 len)
+{
+	if (smc->iomem_base_set)
+		return iomem_read_smc(smc, APPLESMC_READ_CMD, key, buffer, len);
+	else
+		return port_read_smc(smc, APPLESMC_READ_CMD, key, buffer, len);
+}
+
+static int write_smc(struct applesmc_device *smc, const char *key,
+	const u8 *buffer, u8 len)
+{
+	if (smc->iomem_base_set)
+		return iomem_write_smc(smc, APPLESMC_WRITE_CMD, key, buffer, len);
+	else
+		return port_write_smc(smc, APPLESMC_WRITE_CMD, key, buffer, len);
+}
+
+static int get_smc_key_by_index(struct applesmc_device *smc,
+	unsigned int index, char *key)
+{
+	__be32 be;
+
+	be = cpu_to_be32(index);
+	if (smc->iomem_base_set)
+		return iomem_read_smc(smc, APPLESMC_GET_KEY_BY_INDEX_CMD,
+							  (const char *) &be, (u8 *) key, 4);
+	else
+		return port_read_smc(smc, APPLESMC_GET_KEY_BY_INDEX_CMD,
+							 (const char *) &be, (u8 *) key, 4);
+}
+
+static int get_smc_key_info(struct applesmc_device *smc, const char *key,
+	struct applesmc_entry *info)
+{
+	if (smc->iomem_base_set)
+		return iomem_get_smc_key_type(smc, key, info);
+	else
+		return port_get_smc_key_info(smc, key, info);
+}
+
+static int read_register_count(struct applesmc_device *smc,
+	unsigned int *count)
+{
+	__be32 be;
+	int ret;
+
+	ret = read_smc(smc, KEY_COUNT_KEY, (u8 *)&be, 4);
+	if (ret < 0)
+		return ret;
+
+	*count = be32_to_cpu(be);
+	return 0;
+}
+
+/*
+ * Serialized I/O
+ *
+ * Returns zero on success or a negative error on failure.
+ * All functions below are concurrency safe - callers should NOT hold lock.
+ */
+
+static int applesmc_read_entry(struct applesmc_device *smc,
+	const struct applesmc_entry *entry, u8 *buf, u8 len)
+{
+	int ret;
+
+	if (entry->len != len)
+		return -EINVAL;
+	mutex_lock(&smc->reg.mutex);
+	ret = read_smc(smc, entry->key, buf, len);
+	mutex_unlock(&smc->reg.mutex);
+
+	return ret;
+}
+
+static int applesmc_write_entry(struct applesmc_device *smc,
+	const struct applesmc_entry *entry, const u8 *buf, u8 len)
+{
+	int ret;
+
+	if (entry->len != len)
+		return -EINVAL;
+	mutex_lock(&smc->reg.mutex);
+	ret = write_smc(smc, entry->key, buf, len);
+	mutex_unlock(&smc->reg.mutex);
+	return ret;
+}
+
+static const struct applesmc_entry *applesmc_get_entry_by_index(
+	struct applesmc_device *smc, int index)
+{
+	struct applesmc_entry *cache = &smc->reg.cache[index];
+	char key[4];
+	int ret = 0;
+
+	if (cache->valid)
+		return cache;
+
+	mutex_lock(&smc->reg.mutex);
+
+	if (cache->valid)
+		goto out;
+	ret = get_smc_key_by_index(smc, index, key);
+	if (ret)
+		goto out;
+	memcpy(cache->key, key, 4);
+
+	ret = get_smc_key_info(smc, key, cache);
+	if (ret)
+		goto out;
+	cache->valid = true;
+
+out:
+	mutex_unlock(&smc->reg.mutex);
+	if (ret)
+		return ERR_PTR(ret);
+	return cache;
+}
+
+static int applesmc_get_lower_bound(struct applesmc_device *smc,
+	unsigned int *lo, const char *key)
+{
+	int begin = 0, end = smc->reg.key_count;
+	const struct applesmc_entry *entry;
+
+	while (begin != end) {
+		int middle = begin + (end - begin) / 2;
+		entry = applesmc_get_entry_by_index(smc, middle);
+		if (IS_ERR(entry)) {
+			*lo = 0;
+			return PTR_ERR(entry);
+		}
+		if (strcmp(entry->key, key) < 0)
+			begin = middle + 1;
+		else
+			end = middle;
+	}
+
+	*lo = begin;
+	return 0;
+}
+
+static int applesmc_get_upper_bound(struct applesmc_device *smc,
+	unsigned int *hi, const char *key)
+{
+	int begin = 0, end = smc->reg.key_count;
+	const struct applesmc_entry *entry;
+
+	while (begin != end) {
+		int middle = begin + (end - begin) / 2;
+		entry = applesmc_get_entry_by_index(smc, middle);
+		if (IS_ERR(entry)) {
+			*hi = smc->reg.key_count;
+			return PTR_ERR(entry);
+		}
+		if (strcmp(key, entry->key) < 0)
+			end = middle;
+		else
+			begin = middle + 1;
+	}
+
+	*hi = begin;
+	return 0;
+}
+
+static const struct applesmc_entry *applesmc_get_entry_by_key(
+	struct applesmc_device *smc, const char *key)
+{
+	int begin, end;
+	int ret;
+
+	ret = applesmc_get_lower_bound(smc, &begin, key);
+	if (ret)
+		return ERR_PTR(ret);
+	ret = applesmc_get_upper_bound(smc, &end, key);
+	if (ret)
+		return ERR_PTR(ret);
+	if (end - begin != 1)
+		return ERR_PTR(-EINVAL);
+
+	return applesmc_get_entry_by_index(smc, begin);
+}
+
+static int applesmc_read_key(struct applesmc_device *smc,
+	const char *key, u8 *buffer, u8 len)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return applesmc_read_entry(smc, entry, buffer, len);
+}
+
+static int applesmc_write_key(struct applesmc_device *smc,
+	const char *key, const u8 *buffer, u8 len)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return applesmc_write_entry(smc, entry, buffer, len);
+}
+
+static int applesmc_has_key(struct applesmc_device *smc,
+	const char *key, bool *value)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry) && PTR_ERR(entry) != -EINVAL)
+		return PTR_ERR(entry);
+
+	*value = !IS_ERR(entry);
+	return 0;
+}
+
+/*
+ * applesmc_read_s16 - Read 16-bit signed big endian register
+ */
+static int applesmc_read_s16(struct applesmc_device *smc,
+	const char *key, s16 *value)
+{
+	u8 buffer[2];
+	int ret;
+
+	ret = applesmc_read_key(smc, key, buffer, 2);
+	if (ret)
+		return ret;
+
+	*value = ((s16)buffer[0] << 8) | buffer[1];
+	return 0;
+}
+
+/**
+ * applesmc_float_to_u32 - Retrieve the integral part of a float.
+ * This is needed because Apple made fans use float values in the T2.
+ * The fractional point is not significantly useful though, and the integral
+ * part can be easily extracted.
+ */
+static inline u32 applesmc_float_to_u32(u32 d)
+{
+	u8 sign = (u8) ((d >> 31) & 1);
+	s32 exp = (s32) ((d >> 23) & 0xff) - 0x7f;
+	u32 fr = d & ((1u << 23) - 1);
+
+	if (sign || exp < 0)
+		return 0;
+
+	return (u32) ((1u << exp) + (fr >> (23 - exp)));
+}
+
+/**
+ * applesmc_u32_to_float - Convert an u32 into a float.
+ * See applesmc_float_to_u32 for a rationale.
+ */
+static inline u32 applesmc_u32_to_float(u32 d)
+{
+	u32 dc = d, bc = 0, exp;
+
+	if (!d)
+		return 0;
+
+	while (dc >>= 1)
+		++bc;
+	exp = 0x7f + bc;
+
+	return (u32) ((exp << 23) |
+		((d << (23 - (exp - 0x7f))) & ((1u << 23) - 1)));
+}
+/*
+ * applesmc_device_init - initialize the accelerometer.  Can sleep.
+ */
+static void applesmc_device_init(struct applesmc_device *smc)
+{
+	int total;
+	u8 buffer[2];
+
+	if (!smc->reg.has_accelerometer)
+		return;
+
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		if (!applesmc_read_key(smc, MOTION_SENSOR_KEY, buffer, 2) &&
+				(buffer[0] != 0x00 || buffer[1] != 0x00))
+			return;
+		buffer[0] = 0xe0;
+		buffer[1] = 0x00;
+		applesmc_write_key(smc, MOTION_SENSOR_KEY, buffer, 2);
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	pr_warn("failed to init the device\n");
+}
+
+static int applesmc_init_index(struct applesmc_device *smc,
+	struct applesmc_registers *s)
+{
+	const struct applesmc_entry *entry;
+	unsigned int i;
+
+	if (s->index)
+		return 0;
+
+	s->index = kcalloc(s->temp_count, sizeof(s->index[0]), GFP_KERNEL);
+	if (!s->index)
+		return -ENOMEM;
+
+	for (i = s->temp_begin; i < s->temp_end; i++) {
+		entry = applesmc_get_entry_by_index(smc, i);
+		if (IS_ERR(entry))
+			continue;
+		if (strcmp(entry->type, TEMP_SENSOR_TYPE))
+			continue;
+		s->index[s->index_count++] = entry->key;
+	}
+
+	return 0;
+}
+
+/*
+ * applesmc_init_smcreg_try - Try to initialize register cache. Idempotent.
+ */
+static int applesmc_init_smcreg_try(struct applesmc_device *smc)
+{
+	struct applesmc_registers *s = &smc->reg;
+	bool left_light_sensor = false, right_light_sensor = false;
+	unsigned int count;
+	u8 tmp[1];
+	int ret;
+
+	if (s->init_complete)
+		return 0;
+
+	ret = read_register_count(smc, &count);
+	if (ret)
+		return ret;
+
+	if (s->cache && s->key_count != count) {
+		pr_warn("key count changed from %d to %d\n",
+			s->key_count, count);
+		kfree(s->cache);
+		s->cache = NULL;
+	}
+	s->key_count = count;
+
+	if (!s->cache)
+		s->cache = kcalloc(s->key_count, sizeof(*s->cache), GFP_KERNEL);
+	if (!s->cache)
+		return -ENOMEM;
+
+	ret = applesmc_read_key(smc, FANS_COUNT, tmp, 1);
+	if (ret)
+		return ret;
+	s->fan_count = tmp[0];
+	if (s->fan_count > 10)
+		s->fan_count = 10;
+
+	ret = applesmc_get_lower_bound(smc, &s->temp_begin, "T");
+	if (ret)
+		return ret;
+	ret = applesmc_get_lower_bound(smc, &s->temp_end, "U");
+	if (ret)
+		return ret;
+	s->temp_count = s->temp_end - s->temp_begin;
+
+	ret = applesmc_init_index(smc, s);
+	if (ret)
+		return ret;
+
+	ret = applesmc_has_key(smc, LIGHT_SENSOR_LEFT_KEY, &left_light_sensor);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, LIGHT_SENSOR_RIGHT_KEY, &right_light_sensor);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, MOTION_SENSOR_KEY, &s->has_accelerometer);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, BACKLIGHT_KEY, &s->has_key_backlight);
+	if (ret)
+		return ret;
+
+	s->num_light_sensors = left_light_sensor + right_light_sensor;
+	s->init_complete = true;
+
+	pr_info("key=%d fan=%d temp=%d index=%d acc=%d lux=%d kbd=%d\n",
+	       s->key_count, s->fan_count, s->temp_count, s->index_count,
+	       s->has_accelerometer,
+	       s->num_light_sensors,
+	       s->has_key_backlight);
+
+	return 0;
+}
+
+static void applesmc_destroy_smcreg(struct applesmc_device *smc)
+{
+	kfree(smc->reg.index);
+	smc->reg.index = NULL;
+	kfree(smc->reg.cache);
+	smc->reg.cache = NULL;
+	smc->reg.init_complete = false;
+}
+
+/*
+ * applesmc_init_smcreg - Initialize register cache.
+ *
+ * Retries until initialization is successful, or the operation times out.
+ *
+ */
+static int applesmc_init_smcreg(struct applesmc_device *smc)
+{
+	int ms, ret;
+
+	for (ms = 0; ms < INIT_TIMEOUT_MSECS; ms += INIT_WAIT_MSECS) {
+		ret = applesmc_init_smcreg_try(smc);
+		if (!ret) {
+			if (ms)
+				pr_info("init_smcreg() took %d ms\n", ms);
+			return 0;
+		}
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	applesmc_destroy_smcreg(smc);
+
+	return ret;
+}
+
+/* Device model stuff */
+
+static int applesmc_init_resources(struct applesmc_device *smc);
+static void applesmc_free_resources(struct applesmc_device *smc);
+static int applesmc_create_modules(struct applesmc_device *smc);
+static void applesmc_destroy_modules(struct applesmc_device *smc);
+
+static int applesmc_add(struct acpi_device *dev)
+{
+	struct applesmc_device *smc;
+	int ret;
+
+	smc = kzalloc(sizeof(struct applesmc_device), GFP_KERNEL);
+	if (!smc)
+		return -ENOMEM;
+	smc->dev = dev;
+	smc->ldev = &dev->dev;
+	mutex_init(&smc->reg.mutex);
+
+	dev_set_drvdata(&dev->dev, smc);
+
+	ret = applesmc_init_resources(smc);
+	if (ret)
+		goto out_mem;
+
+	ret = applesmc_init_smcreg(smc);
+	if (ret)
+		goto out_res;
+
+	applesmc_device_init(smc);
+
+	ret = applesmc_create_modules(smc);
+	if (ret)
+		goto out_reg;
+
+	return 0;
+
+out_reg:
+	applesmc_destroy_smcreg(smc);
+out_res:
+	applesmc_free_resources(smc);
+out_mem:
+	dev_set_drvdata(&dev->dev, NULL);
+	mutex_destroy(&smc->reg.mutex);
+	kfree(smc);
+
+	return ret;
+}
+
+static void applesmc_remove(struct acpi_device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(&dev->dev);
+
+	applesmc_destroy_modules(smc);
+	applesmc_destroy_smcreg(smc);
+	applesmc_free_resources(smc);
+
+	mutex_destroy(&smc->reg.mutex);
+	kfree(smc);
+
+	return;
+}
+
+static acpi_status applesmc_walk_resources(struct acpi_resource *res,
+	void *data)
+{
+	struct applesmc_device *smc = data;
+
+	switch (res->type) {
+	case ACPI_RESOURCE_TYPE_IO:
+		if (!smc->port_base_set) {
+			if (res->data.io.address_length < APPLESMC_NR_PORTS)
+				return AE_ERROR;
+			smc->port_base = res->data.io.minimum;
+			smc->port_base_set = true;
+		}
+		return AE_OK;
+
+	case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
+		if (!smc->iomem_base_set) {
+			if (res->data.fixed_memory32.address_length <
+					APPLESMC_IOMEM_MIN_SIZE) {
+				dev_warn(smc->ldev, "found iomem but it's too small: %u\n",
+						 res->data.fixed_memory32.address_length);
+				return AE_OK;
+			}
+			smc->iomem_base_addr = res->data.fixed_memory32.address;
+			smc->iomem_base_size = res->data.fixed_memory32.address_length;
+			smc->iomem_base_set = true;
+		}
+		return AE_OK;
+
+	case ACPI_RESOURCE_TYPE_END_TAG:
+		if (smc->port_base_set)
+			return AE_OK;
+		else
+			return AE_NOT_FOUND;
+
+	default:
+		return AE_OK;
+	}
+}
+
+static int applesmc_try_enable_iomem(struct applesmc_device *smc);
+
+static int applesmc_init_resources(struct applesmc_device *smc)
+{
+	int ret;
+
+	ret = acpi_walk_resources(smc->dev->handle, METHOD_NAME__CRS,
+			applesmc_walk_resources, smc);
+	if (ACPI_FAILURE(ret))
+		return -ENXIO;
+
+	if (!request_region(smc->port_base, APPLESMC_NR_PORTS, "applesmc"))
+		return -ENXIO;
+
+	if (smc->iomem_base_set) {
+		if (applesmc_try_enable_iomem(smc))
+			smc->iomem_base_set = false;
+	}
+
+	return 0;
+}
+
+static int applesmc_try_enable_iomem(struct applesmc_device *smc)
+{
+	u8 test_val, ldkn_version;
+
+	dev_dbg(smc->ldev, "Trying to enable iomem based communication\n");
+	smc->iomem_base = ioremap(smc->iomem_base_addr, smc->iomem_base_size);
+	if (!smc->iomem_base)
+		goto out;
+
+	/* Apple's driver does this check for some reason */
+	test_val = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+	if (test_val == 0xff) {
+		dev_warn(smc->ldev,
+			 "iomem enable failed: initial status is 0xff (is %x)\n",
+			 test_val);
+		goto out_iomem;
+	}
+
+	if (read_smc(smc, "LDKN", &ldkn_version, 1)) {
+		dev_warn(smc->ldev, "iomem enable failed: ldkn read failed\n");
+		goto out_iomem;
+	}
+
+	if (ldkn_version < 2) {
+		dev_warn(smc->ldev,
+			 "iomem enable failed: ldkn version %u is less than minimum (2)\n",
+			 ldkn_version);
+		goto out_iomem;
+	}
+
+	return 0;
+
+out_iomem:
+	iounmap(smc->iomem_base);
+
+out:
+	return -ENXIO;
+}
+
+static void applesmc_free_resources(struct applesmc_device *smc)
+{
+	if (smc->iomem_base_set)
+		iounmap(smc->iomem_base);
+	release_region(smc->port_base, APPLESMC_NR_PORTS);
+}
+
+/* Synchronize device with memorized backlight state */
+static int applesmc_pm_resume(struct device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	if (smc->reg.has_key_backlight)
+		applesmc_write_key(smc, BACKLIGHT_KEY, smc->backlight_state, 2);
+
+	return 0;
+}
+
+/* Reinitialize device on resume from hibernation */
+static int applesmc_pm_restore(struct device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	applesmc_device_init(smc);
+
+	return applesmc_pm_resume(dev);
+}
+
+static const struct acpi_device_id applesmc_ids[] = {
+	{"APP0001", 0},
+	{"", 0},
+};
+
+static const struct dev_pm_ops applesmc_pm_ops = {
+	.resume = applesmc_pm_resume,
+	.restore = applesmc_pm_restore,
+};
+
+static struct acpi_driver applesmc_driver = {
+	.name = "applesmc",
+	.class = "applesmc",
+	.ids = applesmc_ids,
+	.ops = {
+		.add = applesmc_add,
+		.remove = applesmc_remove
+	},
+	.drv = {
+		.pm = &applesmc_pm_ops
+	},
+	.owner = THIS_MODULE
+};
+
+/*
+ * applesmc_calibrate - Set our "resting" values.  Callers must
+ * hold applesmc_lock.
+ */
+static void applesmc_calibrate(struct applesmc_device *smc)
+{
+	applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &smc->rest_x);
+	applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &smc->rest_y);
+	smc->rest_x = -smc->rest_x;
+}
+
+static void applesmc_idev_poll(struct input_dev *idev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(&idev->dev);
+	s16 x, y;
+
+	if (applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &x))
+		return;
+	if (applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &y))
+		return;
+
+	x = -x;
+	input_report_abs(idev, ABS_X, x - smc->rest_x);
+	input_report_abs(idev, ABS_Y, y - smc->rest_y);
+	input_sync(idev);
+}
+
+/* Sysfs Files */
+
+static ssize_t applesmc_name_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return sysfs_emit(buf, "applesmc\n");
+}
+
+static ssize_t applesmc_position_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	s16 x, y, z;
+
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &x);
+	if (ret)
+		goto out;
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &y);
+	if (ret)
+		goto out;
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_Z_KEY, &z);
+	if (ret)
+		goto out;
+
+out:
+	if (ret)
+		return ret;
+
+	return sysfs_emit(buf, "(%d,%d,%d)\n", x, y, z);
+}
+
+static ssize_t applesmc_light_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	static int data_length;
+	int ret;
+	u8 left = 0, right = 0;
+	u8 buffer[10];
+
+	if (!data_length) {
+		entry = applesmc_get_entry_by_key(smc, LIGHT_SENSOR_LEFT_KEY);
+		if (IS_ERR(entry))
+			return PTR_ERR(entry);
+		if (entry->len > 10)
+			return -ENXIO;
+		data_length = entry->len;
+		pr_info("light sensor data length set to %d\n", data_length);
+	}
+
+	ret = applesmc_read_key(smc, LIGHT_SENSOR_LEFT_KEY, buffer, data_length);
+	if (ret)
+		goto out;
+	/* newer macbooks report a single 10-bit bigendian value */
+	if (data_length == 10) {
+		left = be16_to_cpu(*(__be16 *)(buffer + 6)) >> 2;
+		goto out;
+	}
+	left = buffer[2];
+
+	ret = applesmc_read_key(smc, LIGHT_SENSOR_RIGHT_KEY, buffer, data_length);
+	if (ret)
+		goto out;
+	right = buffer[2];
+
+out:
+	if (ret)
+		return ret;
+
+	return sysfs_emit(sysfsbuf, "(%d,%d)\n", left, right);
+}
+
+/* Displays sensor key as label */
+static ssize_t applesmc_show_sensor_label(struct device *dev,
+			struct device_attribute *devattr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const char *key = smc->reg.index[to_index(devattr)];
+
+	return sysfs_emit(sysfsbuf, "%s\n", key);
+}
+
+/* Displays degree Celsius * 1000 */
+static ssize_t applesmc_show_temperature(struct device *dev,
+			struct device_attribute *devattr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const char *key = smc->reg.index[to_index(devattr)];
+	int ret;
+	s16 value;
+	int temp;
+
+	ret = applesmc_read_s16(smc, key, &value);
+	if (ret)
+		return ret;
+
+	temp = 250 * (value >> 6);
+
+	return sysfs_emit(sysfsbuf, "%d\n", temp);
+}
+
+static ssize_t applesmc_show_fan_speed(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	int ret;
+	unsigned int speed = 0;
+	char newkey[5];
+	u8 buffer[2];
+
+	scnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],
+		  to_index(attr));
+
+	entry = applesmc_get_entry_by_key(smc, newkey);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	if (!strcmp(entry->type, FLOAT_TYPE)) {
+		ret = applesmc_read_entry(smc, entry, (u8 *) &speed, 4);
+		speed = applesmc_float_to_u32(speed);
+	} else {
+		ret = applesmc_read_entry(smc, entry, buffer, 2);
+		speed = ((buffer[0] << 8 | buffer[1]) >> 2);
+	}
+
+	if (ret)
+		return ret;
+
+	return sysfs_emit(sysfsbuf, "%u\n", speed);
+}
+
+static ssize_t applesmc_store_fan_speed(struct device *dev,
+					struct device_attribute *attr,
+					const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	int ret;
+	unsigned long speed;
+	char newkey[5];
+	u8 buffer[2];
+
+	if (kstrtoul(sysfsbuf, 10, &speed) < 0 || speed >= 0x4000)
+		return -EINVAL;		/* Bigger than a 14-bit value */
+
+	scnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],
+		  to_index(attr));
+
+	entry = applesmc_get_entry_by_key(smc, newkey);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	if (!strcmp(entry->type, FLOAT_TYPE)) {
+		speed = applesmc_u32_to_float(speed);
+		ret = applesmc_write_entry(smc, entry, (u8 *) &speed, 4);
+	} else {
+		buffer[0] = (speed >> 6) & 0xff;
+		buffer[1] = (speed << 2) & 0xff;
+		ret = applesmc_write_key(smc, newkey, buffer, 2);
+	}
+
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_show_fan_manual(struct device *dev,
+			struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u16 manual = 0;
+	u8 buffer[2];
+	char newkey[5];
+	bool has_newkey = false;
+
+	scnprintf(newkey, sizeof(newkey), FAN_MANUAL_FMT, to_index(attr));
+
+	ret = applesmc_has_key(smc, newkey, &has_newkey);
+	if (ret)
+		return ret;
+
+	if (has_newkey) {
+		ret = applesmc_read_key(smc, newkey, buffer, 1);
+		manual = buffer[0];
+	} else {
+		ret = applesmc_read_key(smc, FANS_MANUAL, buffer, 2);
+		manual = ((buffer[0] << 8 | buffer[1]) >> to_index(attr)) & 0x01;
+	}
+
+	if (ret)
+		return ret;
+
+	return sysfs_emit(sysfsbuf, "%d\n", manual);
+}
+
+static ssize_t applesmc_store_fan_manual(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u8 buffer[2];
+	char newkey[5];
+	bool has_newkey = false;
+	unsigned long input;
+	u16 val;
+
+	if (kstrtoul(sysfsbuf, 10, &input) < 0)
+		return -EINVAL;
+
+	scnprintf(newkey, sizeof(newkey), FAN_MANUAL_FMT, to_index(attr));
+
+	ret = applesmc_has_key(smc, newkey, &has_newkey);
+	if (ret)
+		return ret;
+
+	if (has_newkey) {
+		buffer[0] = input & 1;
+		ret = applesmc_write_key(smc, newkey, buffer, 1);
+	} else {
+		ret = applesmc_read_key(smc, FANS_MANUAL, buffer, 2);
+		val = (buffer[0] << 8 | buffer[1]);
+		if (ret)
+			goto out;
+
+		if (input)
+			val = val | (0x01 << to_index(attr));
+		else
+			val = val & ~(0x01 << to_index(attr));
+
+		buffer[0] = (val >> 8) & 0xFF;
+		buffer[1] = val & 0xFF;
+
+		ret = applesmc_write_key(smc, FANS_MANUAL, buffer, 2);
+	}
+
+out:
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_show_fan_position(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	char newkey[5];
+	u8 buffer[17];
+
+	scnprintf(newkey, sizeof(newkey), FAN_ID_FMT, to_index(attr));
+
+	ret = applesmc_read_key(smc, newkey, buffer, 16);
+	buffer[16] = 0;
+
+	if (ret)
+		return ret;
+
+	return sysfs_emit(sysfsbuf, "%s\n", buffer + 4);
+}
+
+static ssize_t applesmc_calibrate_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	return sysfs_emit(sysfsbuf, "(%d,%d)\n", smc->rest_x, smc->rest_y);
+}
+
+static ssize_t applesmc_calibrate_store(struct device *dev,
+	struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	applesmc_calibrate(smc);
+
+	return count;
+}
+
+static void applesmc_backlight_set(struct work_struct *work)
+{
+	struct applesmc_device *smc = container_of(work, struct applesmc_device, backlight_work);
+
+	applesmc_write_key(smc, BACKLIGHT_KEY, smc->backlight_state, 2);
+}
+
+static void applesmc_brightness_set(struct led_classdev *led_cdev,
+						enum led_brightness value)
+{
+	struct applesmc_device *smc = dev_get_drvdata(led_cdev->dev);
+	int ret;
+
+	smc->backlight_state[0] = value;
+	ret = queue_work(smc->backlight_wq, &smc->backlight_work);
+
+	if (debug && (!ret))
+		dev_dbg(led_cdev->dev, "work was already on the queue.\n");
+}
+
+static ssize_t applesmc_BCLM_store(struct device *dev,
+		struct device_attribute *attr, char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	u8 val;
+
+	if (kstrtou8(sysfsbuf, 10, &val) < 0)
+		return -EINVAL;
+
+	if (val < 0 || val > 100)
+		return -EINVAL;
+
+	if (applesmc_write_key(smc, "BCLM", &val, 1))
+		return -ENODEV;
+	return count;
+}
+
+static ssize_t applesmc_BCLM_show(struct device *dev,
+		struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	u8 val;
+
+	if (applesmc_read_key(smc, "BCLM", &val, 1))
+		return -ENODEV;
+
+	return sysfs_emit(sysfsbuf, "%d\n", val);
+}
+
+static ssize_t applesmc_key_count_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u8 buffer[4];
+	u32 count;
+
+	ret = applesmc_read_key(smc, KEY_COUNT_KEY, buffer, 4);
+	if (ret)
+		return ret;
+
+	count = ((u32)buffer[0]<<24) + ((u32)buffer[1]<<16) +
+						((u32)buffer[2]<<8) + buffer[3];
+	return sysfs_emit(sysfsbuf, "%d\n", count);
+}
+
+static ssize_t applesmc_key_at_index_read_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	int ret;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+	ret = applesmc_read_entry(smc, entry, sysfsbuf, entry->len);
+	if (ret)
+		return ret;
+
+	return entry->len;
+}
+
+static ssize_t applesmc_key_at_index_data_length_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return sysfs_emit(sysfsbuf, "%d\n", entry->len);
+}
+
+static ssize_t applesmc_key_at_index_type_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return sysfs_emit(sysfsbuf, "%s\n", entry->type);
+}
+
+static ssize_t applesmc_key_at_index_name_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return sysfs_emit(sysfsbuf, "%s\n", entry->key);
+}
+
+static ssize_t applesmc_key_at_index_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	return sysfs_emit(sysfsbuf, "%d\n", smc->key_at_index);
+}
+
+static ssize_t applesmc_key_at_index_store(struct device *dev,
+	struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	unsigned long newkey;
+
+	if (kstrtoul(sysfsbuf, 10, &newkey) < 0
+	    || newkey >= smc->reg.key_count)
+		return -EINVAL;
+
+	smc->key_at_index = newkey;
+	return count;
+}
+
+static struct applesmc_node_group info_group[] = {
+	{ "name", applesmc_name_show },
+	{ "key_count", applesmc_key_count_show },
+	{ "key_at_index", applesmc_key_at_index_show, applesmc_key_at_index_store },
+	{ "key_at_index_name", applesmc_key_at_index_name_show },
+	{ "key_at_index_type", applesmc_key_at_index_type_show },
+	{ "key_at_index_data_length", applesmc_key_at_index_data_length_show },
+	{ "key_at_index_data", applesmc_key_at_index_read_show },
+	{ }
+};
+
+static struct applesmc_node_group accelerometer_group[] = {
+	{ "position", applesmc_position_show },
+	{ "calibrate", applesmc_calibrate_show, applesmc_calibrate_store },
+	{ }
+};
+
+static struct applesmc_node_group light_sensor_group[] = {
+	{ "light", applesmc_light_show },
+	{ }
+};
+
+static struct applesmc_node_group fan_group[] = {
+	{ "fan%d_label", applesmc_show_fan_position },
+	{ "fan%d_input", applesmc_show_fan_speed, NULL, 0 },
+	{ "fan%d_min", applesmc_show_fan_speed, applesmc_store_fan_speed, 1 },
+	{ "fan%d_max", applesmc_show_fan_speed, NULL, 2 },
+	{ "fan%d_safe", applesmc_show_fan_speed, NULL, 3 },
+	{ "fan%d_output", applesmc_show_fan_speed, applesmc_store_fan_speed, 4 },
+	{ "fan%d_manual", applesmc_show_fan_manual, applesmc_store_fan_manual },
+	{ }
+};
+
+static struct applesmc_node_group temp_group[] = {
+	{ "temp%d_label", applesmc_show_sensor_label },
+	{ "temp%d_input", applesmc_show_temperature },
+	{ }
+};
+
+static struct applesmc_node_group BCLM_group[] = {
+	{ "battery_charge_limit", applesmc_BCLM_show, applesmc_BCLM_store },
+	{ }
+};
+
+/* Module stuff */
+
+/*
+ * applesmc_destroy_nodes - remove files and free associated memory
+ */
+static void applesmc_destroy_nodes(struct applesmc_device *smc,
+	struct applesmc_node_group *groups)
+{
+	struct applesmc_node_group *grp;
+	struct applesmc_dev_attr *node;
+
+	for (grp = groups; grp->nodes; grp++) {
+		for (node = grp->nodes; node->sda.dev_attr.attr.name; node++)
+			sysfs_remove_file(&smc->dev->dev.kobj,
+					  &node->sda.dev_attr.attr);
+		kfree(grp->nodes);
+		grp->nodes = NULL;
+	}
+}
+
+/*
+ * applesmc_create_nodes - create a two-dimensional group of sysfs files
+ */
+static int applesmc_create_nodes(struct applesmc_device *smc,
+	struct applesmc_node_group *groups, int num)
+{
+	struct applesmc_node_group *grp;
+	struct applesmc_dev_attr *node;
+	struct attribute *attr;
+	int ret, i;
+
+	for (grp = groups; grp->format; grp++) {
+		grp->nodes = kcalloc(num + 1, sizeof(*node), GFP_KERNEL);
+		if (!grp->nodes) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		for (i = 0; i < num; i++) {
+			node = &grp->nodes[i];
+			scnprintf(node->name, sizeof(node->name), grp->format,
+				  i + 1);
+			node->sda.index = (grp->option << 16) | (i & 0xffff);
+			node->sda.dev_attr.show = grp->show;
+			node->sda.dev_attr.store = grp->store;
+			attr = &node->sda.dev_attr.attr;
+			sysfs_attr_init(attr);
+			attr->name = node->name;
+			attr->mode = 0444 | (grp->store ? 0200 : 0);
+			ret = sysfs_create_file(&smc->dev->dev.kobj, attr);
+			if (ret) {
+				attr->name = NULL;
+				goto out;
+			}
+		}
+	}
+
+	return 0;
+out:
+	applesmc_destroy_nodes(smc, groups);
+	return ret;
+}
+
+/* Create accelerometer resources */
+static int applesmc_create_accelerometer(struct applesmc_device *smc)
+{
+	int ret;
+	if (!smc->reg.has_accelerometer)
+		return 0;
+
+	ret = applesmc_create_nodes(smc, accelerometer_group, 1);
+	if (ret)
+		goto out;
+
+	smc->idev = input_allocate_device();
+	if (!smc->idev) {
+		ret = -ENOMEM;
+		goto out_sysfs;
+	}
+
+	/* initial calibrate for the input device */
+	applesmc_calibrate(smc);
+
+	/* initialize the input device */
+	smc->idev->name = "applesmc";
+	smc->idev->id.bustype = BUS_HOST;
+	smc->idev->dev.parent = &smc->dev->dev;
+	input_set_abs_params(smc->idev, ABS_X,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+	input_set_abs_params(smc->idev, ABS_Y,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+
+	ret = input_setup_polling(smc->idev, applesmc_idev_poll);
+	if (ret)
+		goto out_idev;
+
+	input_set_poll_interval(smc->idev, APPLESMC_POLL_INTERVAL);
+
+	ret = input_register_device(smc->idev);
+	if (ret)
+		goto out_idev;
+
+	return 0;
+
+out_idev:
+	input_free_device(smc->idev);
+
+out_sysfs:
+	applesmc_destroy_nodes(smc, accelerometer_group);
+
+out:
+	pr_warn("driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+/* Release all resources used by the accelerometer */
+static void applesmc_release_accelerometer(struct applesmc_device *smc)
+{
+	if (!smc->reg.has_accelerometer)
+		return;
+	input_unregister_device(smc->idev);
+	applesmc_destroy_nodes(smc, accelerometer_group);
+}
+
+static int applesmc_create_light_sensor(struct applesmc_device *smc)
+{
+	if (!smc->reg.num_light_sensors)
+		return 0;
+	return applesmc_create_nodes(smc, light_sensor_group, 1);
+}
+
+static void applesmc_release_light_sensor(struct applesmc_device *smc)
+{
+	if (!smc->reg.num_light_sensors)
+		return;
+	applesmc_destroy_nodes(smc, light_sensor_group);
+}
+
+static int applesmc_create_key_backlight(struct applesmc_device *smc)
+{
+	int ret;
+
+	if (!smc->reg.has_key_backlight)
+		return 0;
+	smc->backlight_wq = create_singlethread_workqueue("applesmc-led");
+	if (!smc->backlight_wq)
+		return -ENOMEM;
+
+	INIT_WORK(&smc->backlight_work, applesmc_backlight_set);
+	smc->backlight_dev.name = "smc::kbd_backlight";
+	smc->backlight_dev.default_trigger = "nand-disk";
+	smc->backlight_dev.brightness_set = applesmc_brightness_set;
+	ret = led_classdev_register(&smc->dev->dev, &smc->backlight_dev);
+	if (ret)
+		destroy_workqueue(smc->backlight_wq);
+
+	return ret;
+}
+
+static void applesmc_release_key_backlight(struct applesmc_device *smc)
+{
+	if (!smc->reg.has_key_backlight)
+		return;
+	led_classdev_unregister(&smc->backlight_dev);
+	destroy_workqueue(smc->backlight_wq);
+}
+
+static int applesmc_dmi_match(const struct dmi_system_id *id)
+{
+	return 1;
+}
+
+/*
+ * Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
+ * So we need to put "Apple MacBook Pro" before "Apple MacBook".
+ */
+static const struct dmi_system_id applesmc_whitelist[] __initconst = {
+	{ applesmc_dmi_match, "Apple MacBook Air", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBookAir") },
+	},
+	{ applesmc_dmi_match, "Apple MacBook Pro", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro") },
+	},
+	{ applesmc_dmi_match, "Apple MacBook", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBook") },
+	},
+	{ applesmc_dmi_match, "Apple Macmini", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "Macmini") },
+	},
+	{ applesmc_dmi_match, "Apple iMacPro", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "iMacPro") },
+	},
+	{ applesmc_dmi_match, "Apple MacPro", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacPro") },
+	},
+	{ applesmc_dmi_match, "Apple iMac", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "iMac") },
+	},
+	{ applesmc_dmi_match, "Apple Xserve", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "Xserve") },
+	},
+	{ .ident = NULL }
+};
+
+static int applesmc_create_modules(struct applesmc_device *smc)
+{
+	int ret;
+
+	ret = applesmc_create_nodes(smc, info_group, 1);
+	if (ret)
+		goto out;
+	ret = applesmc_create_nodes(smc, BCLM_group, 1);
+	if (ret)
+		goto out_info;
+
+	ret = applesmc_create_nodes(smc, fan_group, smc->reg.fan_count);
+	if (ret)
+		goto out_bclm;
+
+	ret = applesmc_create_nodes(smc, temp_group, smc->reg.index_count);
+	if (ret)
+		goto out_fans;
+
+	ret = applesmc_create_accelerometer(smc);
+	if (ret)
+		goto out_temperature;
+
+	ret = applesmc_create_light_sensor(smc);
+	if (ret)
+		goto out_accelerometer;
+
+	ret = applesmc_create_key_backlight(smc);
+	if (ret)
+		goto out_light_sysfs;
+
+	smc->hwmon_dev = hwmon_device_register(&smc->dev->dev);
+	if (IS_ERR(smc->hwmon_dev)) {
+		ret = PTR_ERR(smc->hwmon_dev);
+		goto out_light_ledclass;
+	}
+
+	return 0;
+
+out_light_ledclass:
+	applesmc_release_key_backlight(smc);
+out_light_sysfs:
+	applesmc_release_light_sensor(smc);
+out_accelerometer:
+	applesmc_release_accelerometer(smc);
+out_temperature:
+	applesmc_destroy_nodes(smc, temp_group);
+out_fans:
+	applesmc_destroy_nodes(smc, fan_group);
+out_bclm:
+	applesmc_destroy_nodes(smc, BCLM_group);
+out_info:
+	applesmc_destroy_nodes(smc, info_group);
+out:
+	return ret;
+}
+
+static void applesmc_destroy_modules(struct applesmc_device *smc)
+{
+	hwmon_device_unregister(smc->hwmon_dev);
+	applesmc_release_key_backlight(smc);
+	applesmc_release_light_sensor(smc);
+	applesmc_release_accelerometer(smc);
+	applesmc_destroy_nodes(smc, temp_group);
+	applesmc_destroy_nodes(smc, fan_group);
+	applesmc_destroy_nodes(smc, BCLM_group);
+	applesmc_destroy_nodes(smc, info_group);
+}
+
+static int __init applesmc_init(void)
+{
+	int ret;
+
+	if (!dmi_check_system(applesmc_whitelist)) {
+		pr_warn("supported laptop not found!\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = acpi_bus_register_driver(&applesmc_driver);
+	if (ret)
+		goto out;
+
+	return 0;
+
+out:
+	pr_warn("driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+static void __exit applesmc_exit(void)
+{
+	acpi_bus_unregister_driver(&applesmc_driver);
+}
+
+module_init(applesmc_init);
+module_exit(applesmc_exit);
+
+MODULE_AUTHOR("Nicolas Boichat");
+MODULE_AUTHOR("Paul Pawlowski");
+MODULE_DESCRIPTION("Apple SMC");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(dmi, applesmc_whitelist);
+#else
 // SPDX-License-Identifier: GPL-2.0-only
 /*
  * drivers/hwmon/applesmc.c - driver for Apple's SMC (accelerometer, temperature
@@ -1417,3 +3381,4 @@ MODULE_AUTHOR("Nicolas Boichat");
 MODULE_DESCRIPTION("Apple SMC");
 MODULE_LICENSE("GPL v2");
 MODULE_DEVICE_TABLE(dmi, applesmc_whitelist);
+#endif
diff -Naurp a/linux-6.6.38.igel/drivers/hwmon/igel/applesmc.c b/linux-6.6.38.igel/drivers/hwmon/igel/applesmc.c
--- a/linux-6.6.38.igel/drivers/hwmon/igel/applesmc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/hwmon/igel/applesmc.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,1856 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * drivers/hwmon/applesmc.c - driver for Apple's SMC (accelerometer, temperature
+ * sensors, fan control, keyboard backlight control) used in Intel-based Apple
+ * computers.
+ *
+ * Copyright (C) 2007 Nicolas Boichat <nicolas@boichat.ch>
+ * Copyright (C) 2010 Henrik Rydberg <rydberg@euromail.se>
+ * Copyright (C) 2019 Paul Pawlowski <paul@mrarm.io>
+ *
+ * Based on hdaps.c driver:
+ * Copyright (C) 2005 Robert Love <rml@novell.com>
+ * Copyright (C) 2005 Jesper Juhl <jj@chaosbits.net>
+ *
+ * Fan control based on smcFanControl:
+ * Copyright (C) 2006 Hendrik Holtmann <holtmann@mac.com>
+ */
+
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+
+#include <linux/delay.h>
+#include <linux/acpi.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/timer.h>
+#include <linux/dmi.h>
+#include <linux/mutex.h>
+#include <linux/hwmon-sysfs.h>
+#include <linux/io.h>
+#include <linux/leds.h>
+#include <linux/hwmon.h>
+#include <linux/workqueue.h>
+#include <linux/err.h>
+
+/* data port used by Apple SMC */
+#define APPLESMC_DATA_PORT	0
+/* command/status port used by Apple SMC */
+#define APPLESMC_CMD_PORT	4
+
+#define APPLESMC_NR_PORTS	32 /* 0x300-0x31f */
+
+#define APPLESMC_IOMEM_KEY_DATA		0
+#define APPLESMC_IOMEM_KEY_STATUS	0x4005
+#define APPLESMC_IOMEM_KEY_NAME		0x78
+#define APPLESMC_IOMEM_KEY_DATA_LEN	0x7D
+#define APPLESMC_IOMEM_KEY_SMC_ID	0x7E
+#define APPLESMC_IOMEM_KEY_CMD		0x7F
+#define APPLESMC_IOMEM_MIN_SIZE		0x4006
+
+#define APPLESMC_IOMEM_KEY_TYPE_CODE		0
+#define APPLESMC_IOMEM_KEY_TYPE_DATA_LEN	5
+#define APPLESMC_IOMEM_KEY_TYPE_FLAGS		6
+
+#define APPLESMC_MAX_DATA_LENGTH 32
+
+/* wait up to 128 ms for a status change. */
+#define APPLESMC_MIN_WAIT	0x0010
+#define APPLESMC_RETRY_WAIT	0x0100
+#define APPLESMC_MAX_WAIT	0x20000
+
+#define APPLESMC_READ_CMD	0x10
+#define APPLESMC_WRITE_CMD	0x11
+#define APPLESMC_GET_KEY_BY_INDEX_CMD	0x12
+#define APPLESMC_GET_KEY_TYPE_CMD	0x13
+
+#define KEY_COUNT_KEY		"#KEY" /* r-o ui32 */
+
+#define LIGHT_SENSOR_LEFT_KEY	"ALV0" /* r-o {alv (6-10 bytes) */
+#define LIGHT_SENSOR_RIGHT_KEY	"ALV1" /* r-o {alv (6-10 bytes) */
+#define BACKLIGHT_KEY		"LKSB" /* w-o {lkb (2 bytes) */
+
+#define CLAMSHELL_KEY		"MSLD" /* r-o ui8 (unused) */
+
+#define MOTION_SENSOR_X_KEY	"MO_X" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_Y_KEY	"MO_Y" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_Z_KEY	"MO_Z" /* r-o sp78 (2 bytes) */
+#define MOTION_SENSOR_KEY	"MOCN" /* r/w ui16 */
+
+#define FANS_COUNT		"FNum" /* r-o ui8 */
+#define FANS_MANUAL		"FS! " /* r-w ui16 */
+#define FAN_ID_FMT		"F%dID" /* r-o char[16] */
+
+#define TEMP_SENSOR_TYPE	"sp78"
+#define FLOAT_TYPE	"flt "
+
+/* List of keys used to read/write fan speeds */
+static const char *const fan_speed_fmt[] = {
+	"F%dAc",		/* actual speed */
+	"F%dMn",		/* minimum speed (rw) */
+	"F%dMx",		/* maximum speed */
+	"F%dSf",		/* safe speed - not all models */
+	"F%dTg",		/* target speed (manual: rw) */
+};
+#define FAN_MANUAL_FMT "F%dMd"
+
+#define INIT_TIMEOUT_MSECS	5000	/* wait up to 5s for device init ... */
+#define INIT_WAIT_MSECS		50	/* ... in 50ms increments */
+
+#define APPLESMC_POLL_INTERVAL	50	/* msecs */
+#define APPLESMC_INPUT_FUZZ	4	/* input event threshold */
+#define APPLESMC_INPUT_FLAT	4
+
+#define to_index(attr) (to_sensor_dev_attr(attr)->index & 0xffff)
+#define to_option(attr) (to_sensor_dev_attr(attr)->index >> 16)
+
+/* Dynamic device node attributes */
+struct applesmc_dev_attr {
+	struct sensor_device_attribute sda;	/* hwmon attributes */
+	char name[32];				/* room for node file name */
+};
+
+/* Dynamic device node group */
+struct applesmc_node_group {
+	char *format;				/* format string */
+	void *show;				/* show function */
+	void *store;				/* store function */
+	int option;				/* function argument */
+	struct applesmc_dev_attr *nodes;	/* dynamic node array */
+};
+
+/* AppleSMC entry - cached register information */
+struct applesmc_entry {
+	char key[5];		/* four-letter key code */
+	u8 valid;		/* set when entry is successfully read once */
+	u8 len;			/* bounded by APPLESMC_MAX_DATA_LENGTH */
+	char type[5];		/* four-letter type code */
+	u8 flags;		/* 0x10: func; 0x40: write; 0x80: read */
+};
+
+/* Register lookup and registers common to all SMCs */
+struct applesmc_registers {
+	struct mutex mutex;		/* register read/write mutex */
+	unsigned int key_count;		/* number of SMC registers */
+	unsigned int fan_count;		/* number of fans */
+	unsigned int temp_count;	/* number of temperature registers */
+	unsigned int temp_begin;	/* temperature lower index bound */
+	unsigned int temp_end;		/* temperature upper index bound */
+	unsigned int index_count;	/* size of temperature index array */
+	int num_light_sensors;		/* number of light sensors */
+	bool has_accelerometer;		/* has motion sensor */
+	bool has_key_backlight;		/* has keyboard backlight */
+	bool init_complete;		/* true when fully initialized */
+	struct applesmc_entry *cache;	/* cached key entries */
+	const char **index;		/* temperature key index */
+};
+
+struct applesmc_device {
+	struct acpi_device *dev;
+	struct device *ldev;
+	struct applesmc_registers reg;
+
+	bool port_base_set, iomem_base_set;
+	u16 port_base;
+	u8 *__iomem iomem_base;
+	u32 iomem_base_addr, iomem_base_size;
+
+	s16 rest_x;
+	s16 rest_y;
+
+	u8 backlight_state[2];
+
+	struct device *hwmon_dev;
+	struct input_dev *idev;
+
+	/*
+	 * Last index written to key_at_index sysfs file, and value to use for all other
+	 * key_at_index_* sysfs files.
+	 */
+	unsigned int key_at_index;
+
+	struct workqueue_struct *backlight_wq;
+	struct work_struct backlight_work;
+	struct led_classdev backlight_dev;
+};
+
+static const int debug;
+
+/*
+ * wait_read - Wait for a byte to appear on SMC port. Callers must
+ * hold applesmc_lock.
+ */
+static int port_wait_read(struct applesmc_device *smc)
+{
+	unsigned long end = jiffies + (APPLESMC_MAX_WAIT * HZ) / USEC_PER_SEC;
+	u8 status;
+	int us;
+
+	for (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {
+		usleep_range(us, us * 16);
+		status = inb(smc->port_base + APPLESMC_CMD_PORT);
+		/* read: wait for smc to settle */
+		if (status & 0x01)
+			return 0;
+		/* timeout: give up */
+		if (time_after(jiffies, end))
+			break;
+	}
+
+	pr_warn("wait_read() fail: 0x%02x\n", status);
+	return -EIO;
+}
+
+/*
+ * send_byte - Write to SMC port, retrying when necessary. Callers
+ * must hold applesmc_lock.
+ */
+static int port_send_byte(struct applesmc_device *smc, u8 cmd, u16 port)
+{
+	u8 status;
+	int us;
+	unsigned long end = jiffies + (APPLESMC_MAX_WAIT * HZ) / USEC_PER_SEC;
+
+	outb(cmd, smc->port_base + port);
+	for (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {
+		usleep_range(us, us * 16);
+		status = inb(smc->port_base + APPLESMC_CMD_PORT);
+		/* write: wait for smc to settle */
+		if (status & 0x02)
+			continue;
+		/* ready: cmd accepted, return */
+		if (status & 0x04)
+			return 0;
+		/* timeout: give up */
+		if (time_after(jiffies, end))
+			break;
+		/* busy: long wait and resend */
+		udelay(APPLESMC_RETRY_WAIT);
+		outb(cmd, smc->port_base + port);
+	}
+
+	pr_warn("send_byte(0x%02x, 0x%04x) fail: 0x%02x\n", cmd, port, status);
+	return -EIO;
+}
+
+static int port_send_command(struct applesmc_device *smc, u8 cmd)
+{
+	return port_send_byte(smc, cmd, APPLESMC_CMD_PORT);
+}
+
+static int port_send_argument(struct applesmc_device *smc, const char *key)
+{
+	int i;
+
+	for (i = 0; i < 4; i++)
+		if (port_send_byte(smc, key[i], APPLESMC_DATA_PORT))
+			return -EIO;
+	return 0;
+}
+
+static int port_read_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	u8 *buffer, u8 len)
+{
+	u8 status, data = 0;
+	int i;
+
+	if (port_send_command(smc, cmd) || port_send_argument(smc, key)) {
+		pr_warn("%.4s: read arg fail\n", key);
+		return -EIO;
+	}
+
+	/* This has no effect on newer (2012) SMCs */
+	if (port_send_byte(smc, len, APPLESMC_DATA_PORT)) {
+		pr_warn("%.4s: read len fail\n", key);
+		return -EIO;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (port_wait_read(smc)) {
+			pr_warn("%.4s: read data[%d] fail\n", key, i);
+			return -EIO;
+		}
+		buffer[i] = inb(smc->port_base + APPLESMC_DATA_PORT);
+	}
+
+	/* Read the data port until bit0 is cleared */
+	for (i = 0; i < 16; i++) {
+		udelay(APPLESMC_MIN_WAIT);
+		status = inb(smc->port_base + APPLESMC_CMD_PORT);
+		if (!(status & 0x01))
+			break;
+		data = inb(smc->port_base + APPLESMC_DATA_PORT);
+	}
+	if (i)
+		pr_warn("flushed %d bytes, last value is: %d\n", i, data);
+
+	return 0;
+}
+
+static int port_write_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	const u8 *buffer, u8 len)
+{
+	int i;
+
+	if (port_send_command(smc, cmd) || port_send_argument(smc, key)) {
+		pr_warn("%s: write arg fail\n", key);
+		return -EIO;
+	}
+
+	if (port_send_byte(smc, len, APPLESMC_DATA_PORT)) {
+		pr_warn("%.4s: write len fail\n", key);
+		return -EIO;
+	}
+
+	for (i = 0; i < len; i++) {
+		if (port_send_byte(smc, buffer[i], APPLESMC_DATA_PORT)) {
+			pr_warn("%s: write data fail\n", key);
+			return -EIO;
+		}
+	}
+
+	return 0;
+}
+
+static int port_get_smc_key_info(struct applesmc_device *smc,
+	const char *key, struct applesmc_entry *info)
+{
+	int ret;
+	u8 raw[6];
+
+	ret = port_read_smc(smc, APPLESMC_GET_KEY_TYPE_CMD, key, raw, 6);
+	if (ret)
+		return ret;
+	info->len = raw[0];
+	memcpy(info->type, &raw[1], 4);
+	info->flags = raw[5];
+	return 0;
+}
+
+
+/*
+ * MMIO based communication.
+ */
+
+static void iomem_clear_status(struct applesmc_device *smc)
+{
+	if (ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS)) {
+		iowrite8(0, smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+	}
+}
+
+static int iomem_wait_read(struct applesmc_device *smc)
+{
+	u8 status;
+	int us;
+	for (us = APPLESMC_MIN_WAIT; us < APPLESMC_MAX_WAIT; us <<= 1) {
+		udelay(us);
+		status = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+		if (status & 0x20)
+			return 0;
+		udelay(APPLESMC_RETRY_WAIT);
+	}
+	dev_warn(smc->ldev, "iomem_wait_read() timeout\n");
+	return -EIO;
+}
+
+static int iomem_read_smc(struct applesmc_device *smc, u8 cmd, const char *key,
+	u8 *buffer, u8 len)
+{
+	u8 err, remote_len;
+	u32 key_int = *((u32 *) key);
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd, smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (iomem_wait_read(smc)) {
+		return -EIO;
+	}
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "read_smc_mmio(%x %8x/%.4s) failed: %u\n",
+				cmd, key_int, key, err);
+		return -EIO;
+	}
+	if (cmd == APPLESMC_READ_CMD) {
+		remote_len = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_DATA_LEN);
+		if (remote_len != len) {
+			dev_warn(smc->ldev, "read_smc_mmio(%x %8x/%.4s) failed: "
+					"buffer length mismatch (remote = %u, requested = %u)\n",
+					 cmd, key_int, key, remote_len, len);
+			return -EINVAL;
+		}
+	} else {
+		remote_len = len;
+	}
+	memcpy_fromio(buffer, smc->iomem_base + APPLESMC_IOMEM_KEY_DATA,
+			remote_len);
+	dev_dbg(smc->ldev, "read_smc_mmio(%x %8x/%.4s): buflen=%u reslen=%u\n",
+			cmd, key_int, key, len, remote_len);
+	print_hex_dump_bytes("read_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, remote_len);
+	return 0;
+}
+
+static int iomem_get_smc_key_type(struct applesmc_device *smc, const char *key,
+	struct applesmc_entry *e)
+{
+	u8 err;
+	u8 cmd = APPLESMC_GET_KEY_TYPE_CMD;
+	u32 key_int = *((u32 *) key);
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd, smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (iomem_wait_read(smc)) {
+		return -EIO;
+	}
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "get_smc_key_type_mmio(%.4s) failed: %u\n", key, err);
+		return -EIO;
+	}
+	e->len = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_DATA_LEN);
+	*((uint32_t *) e->type) = ioread32(
+			smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_CODE);
+	e->flags = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_TYPE_FLAGS);
+	dev_dbg(smc->ldev, "get_smc_key_type_mmio(%.4s): "
+			"len=%u type=%.4s flags=%x\n", key, e->len, e->type, e->flags);
+	return 0;
+}
+
+static int iomem_write_smc(struct applesmc_device *smc, u8 cmd, const char *key, const u8 *buffer, u8 len)
+{
+	u8 err;
+	u32 key_int = *((u32 *) key);
+	iomem_clear_status(smc);
+	iowrite32(key_int, smc->iomem_base + APPLESMC_IOMEM_KEY_NAME);
+	memcpy_toio(smc->iomem_base + APPLESMC_IOMEM_KEY_DATA, buffer, len);
+	iowrite32(len, smc->iomem_base + APPLESMC_IOMEM_KEY_DATA_LEN);
+	iowrite32(0, smc->iomem_base + APPLESMC_IOMEM_KEY_SMC_ID);
+	iowrite32(cmd , smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (iomem_wait_read(smc)) {
+		return -EIO;
+	}
+	err = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_CMD);
+	if (err != 0) {
+		dev_warn(smc->ldev, "write_smc_mmio(%x %.4s) failed: %u\n", cmd, key, err);
+		print_hex_dump_bytes("write_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, len);
+		return -EIO;
+	}
+	dev_dbg(smc->ldev, "write_smc_mmio(%x %.4s): buflen=%u\n",
+			cmd, key, len);
+	print_hex_dump_bytes("write_smc_mmio(): ", DUMP_PREFIX_NONE, buffer, len);
+	return 0;
+}
+
+
+static int read_smc(struct applesmc_device *smc, const char *key,
+	u8 *buffer, u8 len)
+{
+	if (smc->iomem_base_set) {
+		return iomem_read_smc(smc, APPLESMC_READ_CMD, key, buffer, len);
+	} else {
+		return port_read_smc(smc, APPLESMC_READ_CMD, key, buffer, len);
+	}
+}
+
+static int write_smc(struct applesmc_device *smc, const char *key,
+	const u8 *buffer, u8 len)
+{
+	if (smc->iomem_base_set) {
+		return iomem_write_smc(smc, APPLESMC_WRITE_CMD, key, buffer, len);
+	} else {
+		return port_write_smc(smc, APPLESMC_WRITE_CMD, key, buffer, len);
+	}
+}
+
+static int get_smc_key_by_index(struct applesmc_device *smc,
+	unsigned int index, char *key)
+{
+	__be32 be;
+	be = cpu_to_be32(index);
+	if (smc->iomem_base_set) {
+		return iomem_read_smc(smc, APPLESMC_GET_KEY_BY_INDEX_CMD,
+							  (const char *) &be, (u8 *) key, 4);
+	} else {
+		return port_read_smc(smc, APPLESMC_GET_KEY_BY_INDEX_CMD,
+							 (const char *) &be, (u8 *) key, 4);
+	}
+}
+
+static int get_smc_key_info(struct applesmc_device *smc, const char *key,
+	struct applesmc_entry *info)
+{
+	if (smc->iomem_base_set) {
+		return iomem_get_smc_key_type(smc, key, info);
+	} else {
+		return port_get_smc_key_info(smc, key, info);
+	}
+}
+
+static int read_register_count(struct applesmc_device *smc,
+	unsigned int *count)
+{
+	__be32 be;
+	int ret;
+
+	ret = read_smc(smc, KEY_COUNT_KEY, (u8 *)&be, 4);
+	if (ret < 0)
+		return ret;
+
+	*count = be32_to_cpu(be);
+	return 0;
+}
+
+/*
+ * Serialized I/O
+ *
+ * Returns zero on success or a negative error on failure.
+ * All functions below are concurrency safe - callers should NOT hold lock.
+ */
+
+static int applesmc_read_entry(struct applesmc_device *smc,
+	const struct applesmc_entry *entry, u8 *buf, u8 len)
+{
+	int ret;
+
+	if (entry->len != len)
+		return -EINVAL;
+	mutex_lock(&smc->reg.mutex);
+	ret = read_smc(smc, entry->key, buf, len);
+	mutex_unlock(&smc->reg.mutex);
+
+	return ret;
+}
+
+static int applesmc_write_entry(struct applesmc_device *smc,
+	const struct applesmc_entry *entry, const u8 *buf, u8 len)
+{
+	int ret;
+
+	if (entry->len != len)
+		return -EINVAL;
+	mutex_lock(&smc->reg.mutex);
+	ret = write_smc(smc, entry->key, buf, len);
+	mutex_unlock(&smc->reg.mutex);
+	return ret;
+}
+
+static const struct applesmc_entry *applesmc_get_entry_by_index(
+	struct applesmc_device *smc, int index)
+{
+	struct applesmc_entry *cache = &smc->reg.cache[index];
+	char key[4];
+	int ret = 0;
+
+	if (cache->valid)
+		return cache;
+
+	mutex_lock(&smc->reg.mutex);
+
+	if (cache->valid)
+		goto out;
+	ret = get_smc_key_by_index(smc, index, key);
+	if (ret)
+		goto out;
+	memcpy(cache->key, key, 4);
+
+	ret = get_smc_key_info(smc, key, cache);
+	if (ret)
+		goto out;
+	cache->valid = 1;
+
+out:
+	mutex_unlock(&smc->reg.mutex);
+	if (ret)
+		return ERR_PTR(ret);
+	return cache;
+}
+
+static int applesmc_get_lower_bound(struct applesmc_device *smc,
+	unsigned int *lo, const char *key)
+{
+	int begin = 0, end = smc->reg.key_count;
+	const struct applesmc_entry *entry;
+
+	while (begin != end) {
+		int middle = begin + (end - begin) / 2;
+		entry = applesmc_get_entry_by_index(smc, middle);
+		if (IS_ERR(entry)) {
+			*lo = 0;
+			return PTR_ERR(entry);
+		}
+		if (strcmp(entry->key, key) < 0)
+			begin = middle + 1;
+		else
+			end = middle;
+	}
+
+	*lo = begin;
+	return 0;
+}
+
+static int applesmc_get_upper_bound(struct applesmc_device *smc,
+	unsigned int *hi, const char *key)
+{
+	int begin = 0, end = smc->reg.key_count;
+	const struct applesmc_entry *entry;
+
+	while (begin != end) {
+		int middle = begin + (end - begin) / 2;
+		entry = applesmc_get_entry_by_index(smc, middle);
+		if (IS_ERR(entry)) {
+			*hi = smc->reg.key_count;
+			return PTR_ERR(entry);
+		}
+		if (strcmp(key, entry->key) < 0)
+			end = middle;
+		else
+			begin = middle + 1;
+	}
+
+	*hi = begin;
+	return 0;
+}
+
+static const struct applesmc_entry *applesmc_get_entry_by_key(
+	struct applesmc_device *smc, const char *key)
+{
+	int begin, end;
+	int ret;
+
+	ret = applesmc_get_lower_bound(smc, &begin, key);
+	if (ret)
+		return ERR_PTR(ret);
+	ret = applesmc_get_upper_bound(smc, &end, key);
+	if (ret)
+		return ERR_PTR(ret);
+	if (end - begin != 1)
+		return ERR_PTR(-EINVAL);
+
+	return applesmc_get_entry_by_index(smc, begin);
+}
+
+static int applesmc_read_key(struct applesmc_device *smc,
+	const char *key, u8 *buffer, u8 len)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return applesmc_read_entry(smc, entry, buffer, len);
+}
+
+static int applesmc_write_key(struct applesmc_device *smc,
+	const char *key, const u8 *buffer, u8 len)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return applesmc_write_entry(smc, entry, buffer, len);
+}
+
+static int applesmc_has_key(struct applesmc_device *smc,
+	const char *key, bool *value)
+{
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_key(smc, key);
+	if (IS_ERR(entry) && PTR_ERR(entry) != -EINVAL)
+		return PTR_ERR(entry);
+
+	*value = !IS_ERR(entry);
+	return 0;
+}
+
+/*
+ * applesmc_read_s16 - Read 16-bit signed big endian register
+ */
+static int applesmc_read_s16(struct applesmc_device *smc,
+	const char *key, s16 *value)
+{
+	u8 buffer[2];
+	int ret;
+
+	ret = applesmc_read_key(smc, key, buffer, 2);
+	if (ret)
+		return ret;
+
+	*value = ((s16)buffer[0] << 8) | buffer[1];
+	return 0;
+}
+
+/**
+ * applesmc_float_to_u32 - Retrieve the integral part of a float.
+ * This is needed because Apple made fans use float values in the T2.
+ * The fractional point is not significantly useful though, and the integral
+ * part can be easily extracted.
+ */
+static inline u32 applesmc_float_to_u32(u32 d)
+{
+	u8 sign = (u8) ((d >> 31) & 1);
+	s32 exp = (s32) ((d >> 23) & 0xff) - 0x7f;
+	u32 fr = d & ((1u << 23) - 1);
+	if (sign || exp < 0)
+		return 0;
+	return (u32) ((1u << exp) + (fr >> (23 - exp)));
+}
+
+/**
+ * applesmc_u32_to_float - Convert an u32 into a float.
+ * See applesmc_float_to_u32 for a rationale.
+ */
+static inline u32 applesmc_u32_to_float(u32 d)
+{
+	u32 dc = d, bc = 0, exp;
+	if (!d)
+		return 0;
+	while (dc >>= 1)
+		++bc;
+	exp = 0x7f + bc;
+	return (u32) ((exp << 23) |
+		((d << (23 - (exp - 0x7f))) & ((1u << 23) - 1)));
+}
+/*
+ * applesmc_device_init - initialize the accelerometer.  Can sleep.
+ */
+static void applesmc_device_init(struct applesmc_device *smc)
+{
+	int total;
+	u8 buffer[2];
+
+	if (!smc->reg.has_accelerometer)
+		return;
+
+	for (total = INIT_TIMEOUT_MSECS; total > 0; total -= INIT_WAIT_MSECS) {
+		if (!applesmc_read_key(smc, MOTION_SENSOR_KEY, buffer, 2) &&
+				(buffer[0] != 0x00 || buffer[1] != 0x00))
+			return;
+		buffer[0] = 0xe0;
+		buffer[1] = 0x00;
+		applesmc_write_key(smc, MOTION_SENSOR_KEY, buffer, 2);
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	pr_warn("failed to init the device\n");
+}
+
+static int applesmc_init_index(struct applesmc_device *smc,
+	struct applesmc_registers *s)
+{
+	const struct applesmc_entry *entry;
+	unsigned int i;
+
+	if (s->index)
+		return 0;
+
+	s->index = kcalloc(s->temp_count, sizeof(s->index[0]), GFP_KERNEL);
+	if (!s->index)
+		return -ENOMEM;
+
+	for (i = s->temp_begin; i < s->temp_end; i++) {
+		entry = applesmc_get_entry_by_index(smc, i);
+		if (IS_ERR(entry))
+			continue;
+		if (strcmp(entry->type, TEMP_SENSOR_TYPE))
+			continue;
+		s->index[s->index_count++] = entry->key;
+	}
+
+	return 0;
+}
+
+/*
+ * applesmc_init_smcreg_try - Try to initialize register cache. Idempotent.
+ */
+static int applesmc_init_smcreg_try(struct applesmc_device *smc)
+{
+	struct applesmc_registers *s = &smc->reg;
+	bool left_light_sensor = 0, right_light_sensor = 0;
+	unsigned int count;
+	u8 tmp[1];
+	int ret;
+
+	if (s->init_complete)
+		return 0;
+
+	ret = read_register_count(smc, &count);
+	if (ret)
+		return ret;
+
+	if (s->cache && s->key_count != count) {
+		pr_warn("key count changed from %d to %d\n",
+			s->key_count, count);
+		kfree(s->cache);
+		s->cache = NULL;
+	}
+	s->key_count = count;
+
+	if (!s->cache)
+		s->cache = kcalloc(s->key_count, sizeof(*s->cache), GFP_KERNEL);
+	if (!s->cache)
+		return -ENOMEM;
+
+	ret = applesmc_read_key(smc, FANS_COUNT, tmp, 1);
+	if (ret)
+		return ret;
+	s->fan_count = tmp[0];
+	if (s->fan_count > 10)
+		s->fan_count = 10;
+
+	ret = applesmc_get_lower_bound(smc, &s->temp_begin, "T");
+	if (ret)
+		return ret;
+	ret = applesmc_get_lower_bound(smc, &s->temp_end, "U");
+	if (ret)
+		return ret;
+	s->temp_count = s->temp_end - s->temp_begin;
+
+	ret = applesmc_init_index(smc, s);
+	if (ret)
+		return ret;
+
+	ret = applesmc_has_key(smc, LIGHT_SENSOR_LEFT_KEY, &left_light_sensor);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, LIGHT_SENSOR_RIGHT_KEY, &right_light_sensor);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, MOTION_SENSOR_KEY, &s->has_accelerometer);
+	if (ret)
+		return ret;
+	ret = applesmc_has_key(smc, BACKLIGHT_KEY, &s->has_key_backlight);
+	if (ret)
+		return ret;
+
+	s->num_light_sensors = left_light_sensor + right_light_sensor;
+	s->init_complete = true;
+
+	pr_info("key=%d fan=%d temp=%d index=%d acc=%d lux=%d kbd=%d\n",
+	       s->key_count, s->fan_count, s->temp_count, s->index_count,
+	       s->has_accelerometer,
+	       s->num_light_sensors,
+	       s->has_key_backlight);
+
+	return 0;
+}
+
+static void applesmc_destroy_smcreg(struct applesmc_device *smc)
+{
+	kfree(smc->reg.index);
+	smc->reg.index = NULL;
+	kfree(smc->reg.cache);
+	smc->reg.cache = NULL;
+	smc->reg.init_complete = false;
+}
+
+/*
+ * applesmc_init_smcreg - Initialize register cache.
+ *
+ * Retries until initialization is successful, or the operation times out.
+ *
+ */
+static int applesmc_init_smcreg(struct applesmc_device *smc)
+{
+	int ms, ret;
+
+	for (ms = 0; ms < INIT_TIMEOUT_MSECS; ms += INIT_WAIT_MSECS) {
+		ret = applesmc_init_smcreg_try(smc);
+		if (!ret) {
+			if (ms)
+				pr_info("init_smcreg() took %d ms\n", ms);
+			return 0;
+		}
+		msleep(INIT_WAIT_MSECS);
+	}
+
+	applesmc_destroy_smcreg(smc);
+
+	return ret;
+}
+
+/* Device model stuff */
+
+static int applesmc_init_resources(struct applesmc_device *smc);
+static void applesmc_free_resources(struct applesmc_device *smc);
+static int applesmc_create_modules(struct applesmc_device *smc);
+static void applesmc_destroy_modules(struct applesmc_device *smc);
+
+static int applesmc_add(struct acpi_device *dev)
+{
+	struct applesmc_device *smc;
+	int ret;
+
+	smc = kzalloc(sizeof(struct applesmc_device), GFP_KERNEL);
+	if (!smc)
+		return -ENOMEM;
+	smc->dev = dev;
+	smc->ldev = &dev->dev;
+	mutex_init(&smc->reg.mutex);
+
+	dev_set_drvdata(&dev->dev, smc);
+
+	ret = applesmc_init_resources(smc);
+	if (ret)
+		goto out_mem;
+
+	ret = applesmc_init_smcreg(smc);
+	if (ret)
+		goto out_res;
+
+	applesmc_device_init(smc);
+
+	ret = applesmc_create_modules(smc);
+	if (ret)
+		goto out_reg;
+
+	return 0;
+
+out_reg:
+	applesmc_destroy_smcreg(smc);
+out_res:
+	applesmc_free_resources(smc);
+out_mem:
+	dev_set_drvdata(&dev->dev, NULL);
+	mutex_destroy(&smc->reg.mutex);
+	kfree(smc);
+
+	return ret;
+}
+
+static void applesmc_remove(struct acpi_device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(&dev->dev);
+
+	applesmc_destroy_modules(smc);
+	applesmc_destroy_smcreg(smc);
+	applesmc_free_resources(smc);
+
+	mutex_destroy(&smc->reg.mutex);
+	kfree(smc);
+}
+
+static acpi_status applesmc_walk_resources(struct acpi_resource *res,
+	void *data)
+{
+	struct applesmc_device *smc = data;
+
+	switch (res->type) {
+		case ACPI_RESOURCE_TYPE_IO:
+			if (!smc->port_base_set) {
+				if (res->data.io.address_length < APPLESMC_NR_PORTS)
+					return AE_ERROR;
+				smc->port_base = res->data.io.minimum;
+				smc->port_base_set = true;
+			}
+			return AE_OK;
+
+		case ACPI_RESOURCE_TYPE_FIXED_MEMORY32:
+			if (!smc->iomem_base_set) {
+				if (res->data.fixed_memory32.address_length <
+						APPLESMC_IOMEM_MIN_SIZE) {
+					dev_warn(smc->ldev, "found iomem but it's too small: %u\n",
+							 res->data.fixed_memory32.address_length);
+					return AE_OK;
+				}
+				smc->iomem_base_addr = res->data.fixed_memory32.address;
+				smc->iomem_base_size = res->data.fixed_memory32.address_length;
+				smc->iomem_base_set = true;
+			}
+			return AE_OK;
+
+		case ACPI_RESOURCE_TYPE_END_TAG:
+			if (smc->port_base_set)
+				return AE_OK;
+			else
+				return AE_NOT_FOUND;
+
+		default:
+			return AE_OK;
+	}
+}
+
+static int applesmc_try_enable_iomem(struct applesmc_device *smc);
+
+static int applesmc_init_resources(struct applesmc_device *smc)
+{
+	int ret;
+
+	ret = acpi_walk_resources(smc->dev->handle, METHOD_NAME__CRS,
+			applesmc_walk_resources, smc);
+	if (ACPI_FAILURE(ret))
+		return -ENXIO;
+
+	if (!request_region(smc->port_base, APPLESMC_NR_PORTS, "applesmc"))
+		return -ENXIO;
+
+	if (smc->iomem_base_set) {
+		if (applesmc_try_enable_iomem(smc))
+			smc->iomem_base_set = false;
+	}
+
+	return 0;
+}
+
+static int applesmc_try_enable_iomem(struct applesmc_device *smc)
+{
+	u8 test_val, ldkn_version;
+
+	dev_dbg(smc->ldev, "Trying to enable iomem based communication\n");
+	smc->iomem_base = ioremap(smc->iomem_base_addr, smc->iomem_base_size);
+	if (!smc->iomem_base)
+		goto out;
+
+	/* Apple's driver does this check for some reason */
+	test_val = ioread8(smc->iomem_base + APPLESMC_IOMEM_KEY_STATUS);
+	if (test_val == 0xff) {
+		dev_warn(smc->ldev, "iomem enable failed: "
+				"initial status is 0xff (is %x)\n", test_val);
+		goto out_iomem;
+	}
+
+	if (read_smc(smc, "LDKN", &ldkn_version, 1)) {
+		dev_warn(smc->ldev, "iomem enable failed: ldkn read failed\n");
+		goto out_iomem;
+	}
+
+	if (ldkn_version < 2) {
+		dev_warn(smc->ldev, "iomem enable failed: "
+				"ldkn version %u is less than minimum (2)\n", ldkn_version);
+		goto out_iomem;
+	}
+
+	return 0;
+
+out_iomem:
+	iounmap(smc->iomem_base);
+out:
+	return -ENXIO;
+}
+
+static void applesmc_free_resources(struct applesmc_device *smc)
+{
+	if (smc->iomem_base_set)
+		iounmap(smc->iomem_base);
+	release_region(smc->port_base, APPLESMC_NR_PORTS);
+}
+
+/* Synchronize device with memorized backlight state */
+static int applesmc_pm_resume(struct device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	if (smc->reg.has_key_backlight)
+		applesmc_write_key(smc, BACKLIGHT_KEY, smc->backlight_state, 2);
+
+	return 0;
+}
+
+/* Reinitialize device on resume from hibernation */
+static int applesmc_pm_restore(struct device *dev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	applesmc_device_init(smc);
+
+	return applesmc_pm_resume(dev);
+}
+
+static const struct acpi_device_id applesmc_ids[] = {
+	{"APP0001", 0},
+	{"", 0},
+};
+
+static const struct dev_pm_ops applesmc_pm_ops = {
+	.resume = applesmc_pm_resume,
+	.restore = applesmc_pm_restore,
+};
+
+static struct acpi_driver applesmc_driver = {
+	.name = "applesmc",
+	.class = "applesmc",
+	.ids = applesmc_ids,
+	.ops = {
+		.add = applesmc_add,
+		.remove = applesmc_remove
+	},
+	.drv = {
+		.pm = &applesmc_pm_ops
+	},
+	.owner = THIS_MODULE
+};
+
+/*
+ * applesmc_calibrate - Set our "resting" values.  Callers must
+ * hold applesmc_lock.
+ */
+static void applesmc_calibrate(struct applesmc_device *smc)
+{
+	applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &smc->rest_x);
+	applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &smc->rest_y);
+	smc->rest_x = -smc->rest_x;
+}
+
+static void applesmc_idev_poll(struct input_dev *idev)
+{
+	struct applesmc_device *smc = dev_get_drvdata(&idev->dev);
+	s16 x, y;
+
+	if (applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &x))
+		return;
+	if (applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &y))
+		return;
+
+	x = -x;
+	input_report_abs(idev, ABS_X, x - smc->rest_x);
+	input_report_abs(idev, ABS_Y, y - smc->rest_y);
+	input_sync(idev);
+}
+
+/* Sysfs Files */
+
+static ssize_t applesmc_name_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	return snprintf(buf, PAGE_SIZE, "applesmc\n");
+}
+
+static ssize_t applesmc_position_show(struct device *dev,
+				   struct device_attribute *attr, char *buf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	s16 x, y, z;
+
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_X_KEY, &x);
+	if (ret)
+		goto out;
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_Y_KEY, &y);
+	if (ret)
+		goto out;
+	ret = applesmc_read_s16(smc, MOTION_SENSOR_Z_KEY, &z);
+	if (ret)
+		goto out;
+
+out:
+	if (ret)
+		return ret;
+	else
+		return snprintf(buf, PAGE_SIZE, "(%d,%d,%d)\n", x, y, z);
+}
+
+static ssize_t applesmc_light_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	static int data_length;
+	int ret;
+	u8 left = 0, right = 0;
+	u8 buffer[10];
+
+	if (!data_length) {
+		entry = applesmc_get_entry_by_key(smc, LIGHT_SENSOR_LEFT_KEY);
+		if (IS_ERR(entry))
+			return PTR_ERR(entry);
+		if (entry->len > 10)
+			return -ENXIO;
+		data_length = entry->len;
+		pr_info("light sensor data length set to %d\n", data_length);
+	}
+
+	ret = applesmc_read_key(smc, LIGHT_SENSOR_LEFT_KEY, buffer, data_length);
+	if (ret)
+		goto out;
+	/* newer macbooks report a single 10-bit bigendian value */
+	if (data_length == 10) {
+		left = be16_to_cpu(*(__be16 *)(buffer + 6)) >> 2;
+		goto out;
+	}
+	left = buffer[2];
+
+	ret = applesmc_read_key(smc, LIGHT_SENSOR_RIGHT_KEY, buffer, data_length);
+	if (ret)
+		goto out;
+	right = buffer[2];
+
+out:
+	if (ret)
+		return ret;
+	else
+		return snprintf(sysfsbuf, PAGE_SIZE, "(%d,%d)\n", left, right);
+}
+
+/* Displays sensor key as label */
+static ssize_t applesmc_show_sensor_label(struct device *dev,
+			struct device_attribute *devattr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const char *key = smc->reg.index[to_index(devattr)];
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%s\n", key);
+}
+
+/* Displays degree Celsius * 1000 */
+static ssize_t applesmc_show_temperature(struct device *dev,
+			struct device_attribute *devattr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const char *key = smc->reg.index[to_index(devattr)];
+	int ret;
+	s16 value;
+	int temp;
+
+	ret = applesmc_read_s16(smc, key, &value);
+	if (ret)
+		return ret;
+
+	temp = 250 * (value >> 6);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", temp);
+}
+
+static ssize_t applesmc_show_fan_speed(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *ent;
+	int ret;
+	unsigned int speed = 0;
+	char newkey[5];
+	u8 buffer[2];
+
+	scnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],
+		  to_index(attr));
+
+	ent = applesmc_get_entry_by_key(smc, newkey);
+	if (IS_ERR(ent)) {
+		return PTR_ERR(ent);
+	}
+
+	if (!strcmp(ent->type, FLOAT_TYPE)) {
+		ret = applesmc_read_entry(smc, ent, (u8 *) &speed, 4);
+		speed = applesmc_float_to_u32(speed);
+	} else {
+		ret = applesmc_read_entry(smc, ent, buffer, 2);
+		speed = ((buffer[0] << 8 | buffer[1]) >> 2);
+	}
+
+	if (ret)
+		return ret;
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%u\n", speed);
+}
+
+static ssize_t applesmc_store_fan_speed(struct device *dev,
+					struct device_attribute *attr,
+					const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *ent;
+	int ret;
+	unsigned long speed;
+	char newkey[5];
+	u8 buffer[2];
+
+	if (kstrtoul(sysfsbuf, 10, &speed) < 0 || speed >= 0x4000)
+		return -EINVAL;		/* Bigger than a 14-bit value */
+
+	scnprintf(newkey, sizeof(newkey), fan_speed_fmt[to_option(attr)],
+		  to_index(attr));
+
+	ent = applesmc_get_entry_by_key(smc, newkey);
+	if (IS_ERR(ent)) {
+		return PTR_ERR(ent);
+	}
+
+	if (!strcmp(ent->type, FLOAT_TYPE)) {
+		speed = applesmc_u32_to_float(speed);
+		ret = applesmc_write_entry(smc, ent, (u8 *) &speed, 4);
+	} else {
+		buffer[0] = (speed >> 6) & 0xff;
+		buffer[1] = (speed << 2) & 0xff;
+		ret = applesmc_write_key(smc, newkey, buffer, 2);
+	}
+
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_show_fan_manual(struct device *dev,
+			struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u16 manual = 0;
+	u8 buffer[2];
+	char newkey[5];
+	bool has_newkey = false;
+
+	scnprintf(newkey, sizeof(newkey), FAN_MANUAL_FMT, to_index(attr));
+
+	ret = applesmc_has_key(smc, newkey, &has_newkey);
+	if (ret)
+		return ret;
+
+	if (has_newkey) {
+		ret = applesmc_read_key(smc, newkey, buffer, 1);
+		manual = buffer[0];
+	} else {
+		ret = applesmc_read_key(smc, FANS_MANUAL, buffer, 2);
+		manual = ((buffer[0] << 8 | buffer[1]) >> to_index(attr)) & 0x01;
+	}
+
+	if (ret)
+		return ret;
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", manual);
+}
+
+static ssize_t applesmc_store_fan_manual(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u8 buffer[2];
+	char newkey[5];
+	bool has_newkey = false;
+	unsigned long input;
+	u16 val;
+
+	if (kstrtoul(sysfsbuf, 10, &input) < 0)
+		return -EINVAL;
+
+	scnprintf(newkey, sizeof(newkey), FAN_MANUAL_FMT, to_index(attr));
+
+	ret = applesmc_has_key(smc, newkey, &has_newkey);
+	if (ret)
+		return ret;
+
+	if (has_newkey) {
+		buffer[0] = input & 1;
+		ret = applesmc_write_key(smc, newkey, buffer, 1);
+	} else {
+		ret = applesmc_read_key(smc, FANS_MANUAL, buffer, 2);
+		val = (buffer[0] << 8 | buffer[1]);
+		if (ret)
+			goto out;
+
+		if (input)
+			val = val | (0x01 << to_index(attr));
+		else
+			val = val & ~(0x01 << to_index(attr));
+
+		buffer[0] = (val >> 8) & 0xFF;
+		buffer[1] = val & 0xFF;
+
+		ret = applesmc_write_key(smc, FANS_MANUAL, buffer, 2);
+	}
+
+out:
+	if (ret)
+		return ret;
+	else
+		return count;
+}
+
+static ssize_t applesmc_show_fan_position(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	char newkey[5];
+	u8 buffer[17];
+
+	scnprintf(newkey, sizeof(newkey), FAN_ID_FMT, to_index(attr));
+
+	ret = applesmc_read_key(smc, newkey, buffer, 16);
+	buffer[16] = 0;
+
+	if (ret)
+		return ret;
+	else
+		return snprintf(sysfsbuf, PAGE_SIZE, "%s\n", buffer+4);
+}
+
+static ssize_t applesmc_calibrate_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "(%d,%d)\n", smc->rest_x, smc->rest_y);
+}
+
+static ssize_t applesmc_calibrate_store(struct device *dev,
+	struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	applesmc_calibrate(smc);
+
+	return count;
+}
+
+static void applesmc_backlight_set(struct work_struct *work)
+{
+	struct applesmc_device *smc = container_of(work, struct applesmc_device, backlight_work);
+
+	applesmc_write_key(smc, BACKLIGHT_KEY, smc->backlight_state, 2);
+}
+
+static void applesmc_brightness_set(struct led_classdev *led_cdev,
+						enum led_brightness value)
+{
+	struct applesmc_device *smc = dev_get_drvdata(led_cdev->dev);
+	int ret;
+
+	smc->backlight_state[0] = value;
+	ret = queue_work(smc->backlight_wq, &smc->backlight_work);
+
+	if (debug && (!ret))
+		dev_dbg(led_cdev->dev, "work was already on the queue.\n");
+}
+
+static ssize_t applesmc_key_count_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	int ret;
+	u8 buffer[4];
+	u32 count;
+
+	ret = applesmc_read_key(smc, KEY_COUNT_KEY, buffer, 4);
+	if (ret)
+		return ret;
+
+	count = ((u32)buffer[0]<<24) + ((u32)buffer[1]<<16) +
+						((u32)buffer[2]<<8) + buffer[3];
+	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", count);
+}
+
+static ssize_t applesmc_key_at_index_read_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+	int ret;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+	ret = applesmc_read_entry(smc, entry, sysfsbuf, entry->len);
+	if (ret)
+		return ret;
+
+	return entry->len;
+}
+
+static ssize_t applesmc_key_at_index_data_length_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", entry->len);
+}
+
+static ssize_t applesmc_key_at_index_type_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%s\n", entry->type);
+}
+
+static ssize_t applesmc_key_at_index_name_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	const struct applesmc_entry *entry;
+
+	entry = applesmc_get_entry_by_index(smc, smc->key_at_index);
+	if (IS_ERR(entry))
+		return PTR_ERR(entry);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%s\n", entry->key);
+}
+
+static ssize_t applesmc_key_at_index_show(struct device *dev,
+				struct device_attribute *attr, char *sysfsbuf)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+
+	return snprintf(sysfsbuf, PAGE_SIZE, "%d\n", smc->key_at_index);
+}
+
+static ssize_t applesmc_key_at_index_store(struct device *dev,
+	struct device_attribute *attr, const char *sysfsbuf, size_t count)
+{
+	struct applesmc_device *smc = dev_get_drvdata(dev);
+	unsigned long newkey;
+
+	if (kstrtoul(sysfsbuf, 10, &newkey) < 0
+	    || newkey >= smc->reg.key_count)
+		return -EINVAL;
+
+	smc->key_at_index = newkey;
+	return count;
+}
+
+static struct applesmc_node_group info_group[] = {
+	{ "name", applesmc_name_show },
+	{ "key_count", applesmc_key_count_show },
+	{ "key_at_index", applesmc_key_at_index_show, applesmc_key_at_index_store },
+	{ "key_at_index_name", applesmc_key_at_index_name_show },
+	{ "key_at_index_type", applesmc_key_at_index_type_show },
+	{ "key_at_index_data_length", applesmc_key_at_index_data_length_show },
+	{ "key_at_index_data", applesmc_key_at_index_read_show },
+	{ }
+};
+
+static struct applesmc_node_group accelerometer_group[] = {
+	{ "position", applesmc_position_show },
+	{ "calibrate", applesmc_calibrate_show, applesmc_calibrate_store },
+	{ }
+};
+
+static struct applesmc_node_group light_sensor_group[] = {
+	{ "light", applesmc_light_show },
+	{ }
+};
+
+static struct applesmc_node_group fan_group[] = {
+	{ "fan%d_label", applesmc_show_fan_position },
+	{ "fan%d_input", applesmc_show_fan_speed, NULL, 0 },
+	{ "fan%d_min", applesmc_show_fan_speed, applesmc_store_fan_speed, 1 },
+	{ "fan%d_max", applesmc_show_fan_speed, NULL, 2 },
+	{ "fan%d_safe", applesmc_show_fan_speed, NULL, 3 },
+	{ "fan%d_output", applesmc_show_fan_speed, applesmc_store_fan_speed, 4 },
+	{ "fan%d_manual", applesmc_show_fan_manual, applesmc_store_fan_manual },
+	{ }
+};
+
+static struct applesmc_node_group temp_group[] = {
+	{ "temp%d_label", applesmc_show_sensor_label },
+	{ "temp%d_input", applesmc_show_temperature },
+	{ }
+};
+
+/* Module stuff */
+
+/*
+ * applesmc_destroy_nodes - remove files and free associated memory
+ */
+static void applesmc_destroy_nodes(struct applesmc_device *smc,
+	struct applesmc_node_group *groups)
+{
+	struct applesmc_node_group *grp;
+	struct applesmc_dev_attr *node;
+
+	for (grp = groups; grp->nodes; grp++) {
+		for (node = grp->nodes; node->sda.dev_attr.attr.name; node++)
+			sysfs_remove_file(&smc->dev->dev.kobj,
+					  &node->sda.dev_attr.attr);
+		kfree(grp->nodes);
+		grp->nodes = NULL;
+	}
+}
+
+/*
+ * applesmc_create_nodes - create a two-dimensional group of sysfs files
+ */
+static int applesmc_create_nodes(struct applesmc_device *smc,
+	struct applesmc_node_group *groups, int num)
+{
+	struct applesmc_node_group *grp;
+	struct applesmc_dev_attr *node;
+	struct attribute *attr;
+	int ret, i;
+
+	for (grp = groups; grp->format; grp++) {
+		grp->nodes = kcalloc(num + 1, sizeof(*node), GFP_KERNEL);
+		if (!grp->nodes) {
+			ret = -ENOMEM;
+			goto out;
+		}
+		for (i = 0; i < num; i++) {
+			node = &grp->nodes[i];
+			scnprintf(node->name, sizeof(node->name), grp->format,
+				  i + 1);
+			node->sda.index = (grp->option << 16) | (i & 0xffff);
+			node->sda.dev_attr.show = grp->show;
+			node->sda.dev_attr.store = grp->store;
+			attr = &node->sda.dev_attr.attr;
+			sysfs_attr_init(attr);
+			attr->name = node->name;
+			attr->mode = 0444 | (grp->store ? 0200 : 0);
+			ret = sysfs_create_file(&smc->dev->dev.kobj, attr);
+			if (ret) {
+				attr->name = NULL;
+				goto out;
+			}
+		}
+	}
+
+	return 0;
+out:
+	applesmc_destroy_nodes(smc, groups);
+	return ret;
+}
+
+/* Create accelerometer resources */
+static int applesmc_create_accelerometer(struct applesmc_device *smc)
+{
+	int ret;
+	if (!smc->reg.has_accelerometer)
+		return 0;
+
+	ret = applesmc_create_nodes(smc, accelerometer_group, 1);
+	if (ret)
+		goto out;
+
+	smc->idev = input_allocate_device();
+	if (!smc->idev) {
+		ret = -ENOMEM;
+		goto out_sysfs;
+	}
+
+	/* initial calibrate for the input device */
+	applesmc_calibrate(smc);
+
+	/* initialize the input device */
+	smc->idev->name = "applesmc";
+	smc->idev->id.bustype = BUS_HOST;
+	smc->idev->dev.parent = &smc->dev->dev;
+	input_set_abs_params(smc->idev, ABS_X,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+	input_set_abs_params(smc->idev, ABS_Y,
+			-256, 256, APPLESMC_INPUT_FUZZ, APPLESMC_INPUT_FLAT);
+
+	ret = input_setup_polling(smc->idev, applesmc_idev_poll);
+	if (ret)
+		goto out_idev;
+
+	input_set_poll_interval(smc->idev, APPLESMC_POLL_INTERVAL);
+
+	ret = input_register_device(smc->idev);
+	if (ret)
+		goto out_idev;
+
+	return 0;
+
+out_idev:
+	input_free_device(smc->idev);
+
+out_sysfs:
+	applesmc_destroy_nodes(smc, accelerometer_group);
+
+out:
+	pr_warn("driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+/* Release all resources used by the accelerometer */
+static void applesmc_release_accelerometer(struct applesmc_device *smc)
+{
+	if (!smc->reg.has_accelerometer)
+		return;
+	input_unregister_device(smc->idev);
+	applesmc_destroy_nodes(smc, accelerometer_group);
+}
+
+static int applesmc_create_light_sensor(struct applesmc_device *smc)
+{
+	if (!smc->reg.num_light_sensors)
+		return 0;
+	return applesmc_create_nodes(smc, light_sensor_group, 1);
+}
+
+static void applesmc_release_light_sensor(struct applesmc_device *smc)
+{
+	if (!smc->reg.num_light_sensors)
+		return;
+	applesmc_destroy_nodes(smc, light_sensor_group);
+}
+
+static int applesmc_create_key_backlight(struct applesmc_device *smc)
+{
+	int ret;
+
+	if (!smc->reg.has_key_backlight)
+		return 0;
+	smc->backlight_wq = create_singlethread_workqueue("applesmc-led");
+	if (!smc->backlight_wq)
+		return -ENOMEM;
+
+	INIT_WORK(&smc->backlight_work, applesmc_backlight_set);
+	smc->backlight_dev.name = "smc::kbd_backlight";
+	smc->backlight_dev.default_trigger = "nand-disk";
+	smc->backlight_dev.brightness_set = applesmc_brightness_set;
+	ret = led_classdev_register(&smc->dev->dev, &smc->backlight_dev);
+	if (ret)
+		destroy_workqueue(smc->backlight_wq);
+
+	return ret;
+}
+
+static void applesmc_release_key_backlight(struct applesmc_device *smc)
+{
+	if (!smc->reg.has_key_backlight)
+		return;
+	led_classdev_unregister(&smc->backlight_dev);
+	destroy_workqueue(smc->backlight_wq);
+}
+
+static int applesmc_dmi_match(const struct dmi_system_id *id)
+{
+	return 1;
+}
+
+/*
+ * Note that DMI_MATCH(...,"MacBook") will match "MacBookPro1,1".
+ * So we need to put "Apple MacBook Pro" before "Apple MacBook".
+ */
+static const struct dmi_system_id applesmc_whitelist[] __initconst = {
+	{ applesmc_dmi_match, "Apple MacBook Air", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBookAir") },
+	},
+	{ applesmc_dmi_match, "Apple MacBook Pro", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBookPro") },
+	},
+	{ applesmc_dmi_match, "Apple MacBook", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacBook") },
+	},
+	{ applesmc_dmi_match, "Apple Macmini", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "Macmini") },
+	},
+	{ applesmc_dmi_match, "Apple MacPro", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "MacPro") },
+	},
+	{ applesmc_dmi_match, "Apple iMac", {
+	  DMI_MATCH(DMI_BOARD_VENDOR, "Apple"),
+	  DMI_MATCH(DMI_PRODUCT_NAME, "iMac") },
+	},
+	{ .ident = NULL }
+};
+
+static int applesmc_create_modules(struct applesmc_device *smc)
+{
+	int ret;
+
+	ret = applesmc_create_nodes(smc, info_group, 1);
+	if (ret)
+		goto out;
+
+	ret = applesmc_create_nodes(smc, fan_group, smc->reg.fan_count);
+	if (ret)
+		goto out_info;
+
+	ret = applesmc_create_nodes(smc, temp_group, smc->reg.index_count);
+	if (ret)
+		goto out_fans;
+
+	ret = applesmc_create_accelerometer(smc);
+	if (ret)
+		goto out_temperature;
+
+	ret = applesmc_create_light_sensor(smc);
+	if (ret)
+		goto out_accelerometer;
+
+	ret = applesmc_create_key_backlight(smc);
+	if (ret)
+		goto out_light_sysfs;
+
+	smc->hwmon_dev = hwmon_device_register(&smc->dev->dev);
+	if (IS_ERR(smc->hwmon_dev)) {
+		ret = PTR_ERR(smc->hwmon_dev);
+		goto out_light_ledclass;
+	}
+
+	return 0;
+
+out_light_ledclass:
+	applesmc_release_key_backlight(smc);
+out_light_sysfs:
+	applesmc_release_light_sensor(smc);
+out_accelerometer:
+	applesmc_release_accelerometer(smc);
+out_temperature:
+	applesmc_destroy_nodes(smc, temp_group);
+out_fans:
+	applesmc_destroy_nodes(smc, fan_group);
+out_info:
+	applesmc_destroy_nodes(smc, info_group);
+out:
+	return ret;
+}
+
+static void applesmc_destroy_modules(struct applesmc_device *smc)
+{
+	hwmon_device_unregister(smc->hwmon_dev);
+	applesmc_release_key_backlight(smc);
+	applesmc_release_light_sensor(smc);
+	applesmc_release_accelerometer(smc);
+	applesmc_destroy_nodes(smc, temp_group);
+	applesmc_destroy_nodes(smc, fan_group);
+	applesmc_destroy_nodes(smc, info_group);
+}
+
+static int __init applesmc_init(void)
+{
+	int ret;
+
+	if (!dmi_check_system(applesmc_whitelist)) {
+		pr_warn("supported laptop not found!\n");
+		ret = -ENODEV;
+		goto out;
+	}
+
+	ret = acpi_bus_register_driver(&applesmc_driver);
+	if (ret)
+		goto out;
+
+	return 0;
+
+out:
+	pr_warn("driver init failed (ret=%d)!\n", ret);
+	return ret;
+}
+
+static void __exit applesmc_exit(void)
+{
+	acpi_bus_unregister_driver(&applesmc_driver);
+}
+
+module_init(applesmc_init);
+module_exit(applesmc_exit);
+
+MODULE_AUTHOR("Nicolas Boichat");
+MODULE_AUTHOR("Paul Pawlowski");
+MODULE_DESCRIPTION("Apple SMC");
+MODULE_LICENSE("GPL v2");
+MODULE_DEVICE_TABLE(dmi, applesmc_whitelist);
diff -Naurp a/linux-6.6.38.igel/drivers/hwmon/Makefile b/linux-6.6.38.igel/drivers/hwmon/Makefile
--- a/linux-6.6.38.igel/drivers/hwmon/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/hwmon/Makefile	2024-08-02 15:41:31.547491394 +0200
@@ -48,7 +48,11 @@ obj-$(CONFIG_SENSORS_ADT7462)	+= adt7462
 obj-$(CONFIG_SENSORS_ADT7470)	+= adt7470.o
 obj-$(CONFIG_SENSORS_ADT7475)	+= adt7475.o
 obj-$(CONFIG_SENSORS_AHT10)	+= aht10.o
+ifeq ($(CONFIG_IGEL_USE_PATCHED_APPLESMC),y)
+obj-$(CONFIG_SENSORS_APPLESMC)	+= igel/applesmc.o
+else
 obj-$(CONFIG_SENSORS_APPLESMC)	+= applesmc.o
+endif
 obj-$(CONFIG_SENSORS_AQUACOMPUTER_D5NEXT) += aquacomputer_d5next.o
 obj-$(CONFIG_SENSORS_ARM_SCMI)	+= scmi-hwmon.o
 obj-$(CONFIG_SENSORS_ARM_SCPI)	+= scpi-hwmon.o
diff -Naurp a/linux-6.6.38.igel/drivers/i2c/i2c-core-acpi.c b/linux-6.6.38.igel/drivers/i2c/i2c-core-acpi.c
--- a/linux-6.6.38.igel/drivers/i2c/i2c-core-acpi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/i2c/i2c-core-acpi.c	2024-08-02 15:41:31.551491490 +0200
@@ -639,6 +639,30 @@ static int acpi_gsb_i2c_write_bytes(stru
 	return (ret == 1) ? 0 : -EIO;
 }
 
+#ifdef CONFIG_IGEL_SURFACE_BOOK1_DGPU_SWITCH
+static int acpi_gsb_i2c_write_raw_bytes(struct i2c_client *client,
+		u8 *data, u8 data_len)
+{
+	struct i2c_msg msgs[1];
+	int ret = AE_OK;
+
+	msgs[0].addr = client->addr;
+	msgs[0].flags = client->flags;
+	msgs[0].len = data_len + 1;
+	msgs[0].buf = data;
+
+	ret = i2c_transfer(client->adapter, msgs, ARRAY_SIZE(msgs));
+
+	if (ret < 0) {
+		dev_err(&client->adapter->dev, "i2c write failed: %d\n", ret);
+		return ret;
+	}
+
+	/* 1 transfer must have completed successfully */
+	return (ret == 1) ? 0 : -EIO;
+}
+#endif
+
 static acpi_status
 i2c_acpi_space_handler(u32 function, acpi_physical_address command,
 			u32 bits, u64 *value64,
@@ -740,6 +764,21 @@ i2c_acpi_space_handler(u32 function, acp
 		}
 		break;
 
+#ifdef CONFIG_IGEL_SURFACE_BOOK1_DGPU_SWITCH
+	case ACPI_GSB_ACCESS_ATTRIB_RAW_BYTES:
+		if (action == ACPI_READ) {
+			dev_warn(&adapter->dev,
+				 "protocol 0x%02x not supported for client 0x%02x\n",
+				 accessor_type, client->addr);
+			ret = AE_BAD_PARAMETER;
+			goto err;
+		} else {
+			status = acpi_gsb_i2c_write_raw_bytes(client,
+					gsb->data, info->access_length);
+		}
+		break;
+#endif
+
 	default:
 		dev_warn(&adapter->dev, "protocol 0x%02x not supported for client 0x%02x\n",
 			 accessor_type, client->addr);
diff -Naurp a/linux-6.6.38.igel/drivers/idle/intel_idle.c b/linux-6.6.38.igel/drivers/idle/intel_idle.c
--- a/linux-6.6.38.igel/drivers/idle/intel_idle.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/idle/intel_idle.c	2024-08-02 15:41:31.551491490 +0200
@@ -51,6 +51,9 @@
 #include <linux/notifier.h>
 #include <linux/cpu.h>
 #include <linux/moduleparam.h>
+#ifdef CONFIG_IGEL_FIX_OLD_BIOS_CPU_STEPPING
+#include <linux/dmi.h>
+#endif
 #include <asm/cpu_device_id.h>
 #include <asm/intel-family.h>
 #include <asm/nospec-branch.h>
@@ -320,7 +323,13 @@ static struct cpuidle_state byt_cstates[
 	{
 		.name = "C6N",
 		.desc = "MWAIT 0x58",
+#ifdef CONFIG_IGEL_LIMIT_BAYTRAIL_C_STATES
+		/* gottwald@igel.com Try to fix j1900 freezes
+		 * Patch taken from: https://bugzilla.kernel.org/show_bug.cgi?id=109051#c865 */
+		.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_UNUSABLE,
+#else
 		.flags = MWAIT2flg(0x58) | CPUIDLE_FLAG_TLB_FLUSHED,
+#endif
 		.exit_latency = 300,
 		.target_residency = 275,
 		.enter = &intel_idle,
@@ -328,7 +337,13 @@ static struct cpuidle_state byt_cstates[
 	{
 		.name = "C6S",
 		.desc = "MWAIT 0x52",
+#ifdef CONFIG_IGEL_LIMIT_BAYTRAIL_C_STATES
+		/* gottwald@igel.com Try to fix j1900 freezes
+		 * Patch taken from: https://bugzilla.kernel.org/show_bug.cgi?id=109051#c865 */
+		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED | CPUIDLE_FLAG_UNUSABLE,
+#else
 		.flags = MWAIT2flg(0x52) | CPUIDLE_FLAG_TLB_FLUSHED,
+#endif
 		.exit_latency = 500,
 		.target_residency = 560,
 		.enter = &intel_idle,
@@ -2078,6 +2093,19 @@ static int __init intel_idle_init(void)
 			return -ENODEV;
 	}
 
+#ifdef CONFIG_IGEL_FIX_OLD_BIOS_CPU_STEPPING
+	if (max_cstate == CPUIDLE_STATE_MAX - 1) {
+		if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL &&
+		    boot_cpu_data.x86 ==  6 &&
+		    boot_cpu_data.x86_model == 0x37 &&
+		    boot_cpu_data.x86_stepping == 0x9) {
+			int year, month, day;
+			dmi_get_date(DMI_BIOS_DATE, &year, &month, &day);
+			if (year < 2018 || (year == 2018 && month < 11))
+				max_cstate = 1;
+		}
+	}
+#endif
 	if (boot_cpu_data.cpuid_level < CPUID_MWAIT_LEAF)
 		return -ENODEV;
 
diff -Naurp a/linux-6.6.38.igel/drivers/input/misc/soc_button_array.c b/linux-6.6.38.igel/drivers/input/misc/soc_button_array.c
--- a/linux-6.6.38.igel/drivers/input/misc/soc_button_array.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/input/misc/soc_button_array.c	2024-08-02 15:41:31.551491490 +0200
@@ -537,6 +537,34 @@ static const struct soc_device_data soc_
 	.button_info = soc_button_MSHW0028,
 };
 
+#ifdef CONFIG_IGEL_SURFACE_BUTTON_CHANGES
+/*
+ * Special device check for Surface Book 2 and Surface Pro (2017).
+ * Both, the Surface Pro 4 (surfacepro3_button.c) and the above mentioned
+ * devices use MSHW0040 for power and volume buttons, however the way they
+ * have to be addressed differs. Make sure that we only load this drivers
+ * for the correct devices by checking if the OEM Platform Revision DSM call
+ * exists.
+ */
+#define MSHW0040_DSM_REVISION		0x01
+#define MSHW0040_DSM_GET_OMPR		0x02	// get OEM Platform Revision
+static const guid_t MSHW0040_DSM_UUID =
+	GUID_INIT(0x6fd05c69, 0xcde3, 0x49f4, 0x95, 0xed, 0xab, 0x16, 0x65,
+		  0x49, 0x80, 0x35);
+
+static int soc_device_check_MSHW0040(struct device *dev)
+{
+	acpi_handle handle = ACPI_HANDLE(dev);
+	bool exists;
+
+	// check if OEM platform revision DSM call exists
+	exists = acpi_check_dsm(handle, &MSHW0040_DSM_UUID,
+				MSHW0040_DSM_REVISION,
+				BIT(MSHW0040_DSM_GET_OMPR));
+
+	return exists ? 0 : -ENODEV;
+}
+#else
 /*
  * Special device check for Surface Book 2 and Surface Pro (2017).
  * Both, the Surface Pro 4 (surfacepro3_button.c) and the above mentioned
@@ -580,6 +608,7 @@ static int soc_device_check_MSHW0040(str
 
 	return 0;
 }
+#endif
 
 /*
  * Button infos for Microsoft Surface Book 2 and Surface Pro (2017).
diff -Naurp a/linux-6.6.38.igel/drivers/input/mouse/bcm5974.c b/linux-6.6.38.igel/drivers/input/mouse/bcm5974.c
--- a/linux-6.6.38.igel/drivers/input/mouse/bcm5974.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/input/mouse/bcm5974.c	2024-08-02 15:41:31.551491490 +0200
@@ -83,6 +83,26 @@
 #define USB_DEVICE_ID_APPLE_WELLSPRING9_ISO	0x0273
 #define USB_DEVICE_ID_APPLE_WELLSPRING9_JIS	0x0274
 
+#ifdef CONFIG_IGEL_APPLE_TRACKPAD
+/* T2-Attached Devices */
+/* MacbookAir8,1 (2018) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J140K	0x027a
+/* MacbookPro15,2 (2018) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J132	0x027b
+/* MacbookPro15,1 (2018) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J680	0x027c
+/* MacbookPro15,4 (2019) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J213	0x027d
+/* MacbookPro16,2 (2020) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J214K	0x027e
+/* MacbookPro16,3 (2020) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J223	0x027f
+/* MacbookAir9,1 (2020) */
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J230K	0x0280
+/* MacbookPro16,1 (2019)*/
+#define USB_DEVICE_ID_APPLE_WELLSPRINGT2_J152F	0x0340
+#endif
+
 #define BCM5974_DEVICE(prod) {					\
 	.match_flags = (USB_DEVICE_ID_MATCH_DEVICE |		\
 			USB_DEVICE_ID_MATCH_INT_CLASS |		\
@@ -147,6 +167,24 @@ static const struct usb_device_id bcm597
 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING9_ANSI),
 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING9_ISO),
 	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRING9_JIS),
+#ifdef CONFIG_IGEL_APPLE_TRACKPAD
+	/* MacbookAir8,1 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J140K),
+	/* MacbookPro15,2 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J132),
+	/* MacbookPro15,1 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J680),
+	/* MacbookPro15,4 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J213),
+	/* MacbookPro16,2 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J214K),
+	/* MacbookPro16,3 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J223),
+	/* MacbookAir9,1 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J230K),
+	/* MacbookPro16,1 */
+	BCM5974_DEVICE(USB_DEVICE_ID_APPLE_WELLSPRINGT2_J152F),
+#endif
 	/* Terminating entry */
 	{}
 };
@@ -483,6 +521,112 @@ static const struct bcm5974_config bcm59
 		{ SN_COORD, -203, 6803 },
 		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
 	},
+#ifdef CONFIG_IGEL_APPLE_TRACKPAD
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J140K,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J132,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J680,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -7456, 7976 },
+		{ SN_COORD, -1768, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J213,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J214K,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J223,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J230K,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -6243, 6749 },
+		{ SN_COORD, -170, 7685 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+	{
+		USB_DEVICE_ID_APPLE_WELLSPRINGT2_J152F,
+		0,
+		0,
+		HAS_INTEGRATED_BUTTON,
+		0, sizeof(struct bt_data),
+		0x83, DATAFORMAT(TYPE4),
+		{ SN_PRESSURE, 0, 300 },
+		{ SN_WIDTH, 0, 2048 },
+		{ SN_COORD, -8916, 9918 },
+		{ SN_COORD, -1934, 9835 },
+		{ SN_ORIENT, -MAX_FINGER_ORIENTATION, MAX_FINGER_ORIENTATION }
+	},
+#endif
 	{}
 };
 
diff -Naurp a/linux-6.6.38.igel/drivers/input/touchscreen/usbtouchscreen.c b/linux-6.6.38.igel/drivers/input/touchscreen/usbtouchscreen.c
--- a/linux-6.6.38.igel/drivers/input/touchscreen/usbtouchscreen.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/input/touchscreen/usbtouchscreen.c	2024-08-02 15:41:31.551491490 +0200
@@ -128,6 +128,9 @@ enum {
 	DEVTYPE_NEXIO,
 	DEVTYPE_ELO,
 	DEVTYPE_ETOUCH,
+#ifdef CONFIG_IGEL_TOUCHSCREEN_USB_REAKIN
+	DEVTYPE_REAKIN,
+#endif
 };
 
 #define USB_DEVICE_HID_CLASS(vend, prod) \
@@ -237,6 +240,9 @@ static const struct usb_device_id usbtou
 	{USB_DEVICE(0x7374, 0x0001), .driver_info = DEVTYPE_ETOUCH},
 #endif
 
+#ifdef CONFIG_IGEL_TOUCHSCREEN_USB_REAKIN
+	{USB_DEVICE(0x16fd, 0x5453), .driver_info = DEVTYPE_REAKIN},
+#endif
 	{}
 };
 
@@ -288,6 +294,10 @@ static int e2i_read_data(struct usbtouch
 
 #define EGALAX_PKT_TYPE_MASK		0xFE
 #define EGALAX_PKT_TYPE_REPT		0x80
+#ifdef CONFIG_IGEL_TOUCHSCREEN_EGALAX_REPT2
+/* lechner@igel.de, 15.10.2010: add support for new touchscreen controller in UD9 */
+#define EGALAX_PKT_TYPE_REPT2		0x02
+#endif
 #define EGALAX_PKT_TYPE_DIAG		0x0A
 
 static int egalax_init(struct usbtouch_usb *usbtouch)
@@ -331,12 +341,32 @@ static int egalax_init(struct usbtouch_u
 
 static int egalax_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
 {
+#ifdef CONFIG_IGEL_TOUCHSCREEN_EGALAX_REPT2
+	if (((pkt[0] & EGALAX_PKT_TYPE_MASK) != EGALAX_PKT_TYPE_REPT)
+		&& ((pkt[0] & EGALAX_PKT_TYPE_MASK) != EGALAX_PKT_TYPE_REPT2)) {
+		return 0;
+	}
+
+	switch (pkt[0] & EGALAX_PKT_TYPE_MASK) {
+	case EGALAX_PKT_TYPE_REPT:
+		dev->x = ((pkt[3] & 0x0F) << 7) | (pkt[4] & 0x7F);
+		dev->y = ((pkt[1] & 0x0F) << 7) | (pkt[2] & 0x7F);
+		dev->touch = pkt[0] & 0x01;
+		break;
+	case EGALAX_PKT_TYPE_REPT2:
+		dev->x = ((pkt[3] & 0x0F) << 8) | pkt[2];
+		dev->y = ((pkt[5] & 0x0F) << 8) | pkt[4];
+		dev->touch = pkt[1] & 0x01;
+		break;
+	}
+#else
 	if ((pkt[0] & EGALAX_PKT_TYPE_MASK) != EGALAX_PKT_TYPE_REPT)
 		return 0;
 
 	dev->x = ((pkt[3] & 0x0F) << 7) | (pkt[4] & 0x7F);
 	dev->y = ((pkt[1] & 0x0F) << 7) | (pkt[2] & 0x7F);
 	dev->touch = pkt[0] & 0x01;
+#endif
 
 	return 1;
 }
@@ -347,6 +377,11 @@ static int egalax_get_pkt_len(unsigned c
 	case EGALAX_PKT_TYPE_REPT:
 		return 5;
 
+#ifdef CONFIG_IGEL_TOUCHSCREEN_EGALAX_REPT2
+	case EGALAX_PKT_TYPE_REPT2:
+		return 6;
+#endif
+
 	case EGALAX_PKT_TYPE_DIAG:
 		if (len < 2)
 			return -1;
@@ -1129,6 +1164,19 @@ static int nexio_read_data(struct usbtou
 }
 #endif
 
+#ifdef CONFIG_IGEL_TOUCHSCREEN_USB_REAKIN
+/*****************************************************************************
+ * Reakin Part
+ */
+static int reakin_read_data(struct usbtouch_usb *dev, unsigned char *pkt)
+{
+	dev->x = ((pkt[2] & 0x0F) << 8) | pkt[1];
+	dev->y = ((pkt[4] & 0x0F) << 8) | pkt[3];
+	dev->touch = pkt[0] & 0x01;
+
+	return 1;
+}
+#endif
 
 /*****************************************************************************
  * ELO part
@@ -1379,6 +1427,16 @@ static struct usbtouch_device_info usbto
 		.read_data	= etouch_read_data,
 	},
 #endif
+#ifdef CONFIG_IGEL_TOUCHSCREEN_USB_REAKIN
+	[DEVTYPE_REAKIN] = {
+		.min_xc		= 0x0,
+		.max_xc		= 0x03ff,
+		.min_yc		= 0x0,
+		.max_yc		= 0x03ff,
+		.rept_size	= 8,
+		.read_data	= reakin_read_data,
+	},
+#endif
 };
 
 
diff -Naurp a/linux-6.6.38.igel/drivers/iommu/intel/iommu.c b/linux-6.6.38.igel/drivers/iommu/intel/iommu.c
--- a/linux-6.6.38.igel/drivers/iommu/intel/iommu.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/iommu/intel/iommu.c	2024-08-02 15:41:31.551491490 +0200
@@ -38,6 +38,16 @@
 #define IS_GFX_DEVICE(pdev) ((pdev->class >> 16) == PCI_BASE_CLASS_DISPLAY)
 #define IS_USB_DEVICE(pdev) ((pdev->class >> 8) == PCI_CLASS_SERIAL_USB)
 #define IS_ISA_DEVICE(pdev) ((pdev->class >> 8) == PCI_CLASS_BRIDGE_ISA)
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+#define IS_INTEL_IPU(pdev) ((pdev)->vendor == PCI_VENDOR_ID_INTEL &&	\
+			   ((pdev)->device == 0x9a19 ||		\
+			    (pdev)->device == 0x9a39 ||		\
+			    (pdev)->device == 0x4e19 ||		\
+			    (pdev)->device == 0x465d ||		\
+			    (pdev)->device == 0x1919))
+#define IS_IPTS(pdev) ((pdev)->vendor == PCI_VENDOR_ID_INTEL &&	\
+			    ((pdev)->device == 0x9d3e))
+#endif
 #define IS_AZALIA(pdev) ((pdev)->vendor == 0x8086 && (pdev)->device == 0x3a3e)
 
 #define IOAPIC_RANGE_START	(0xfee00000)
@@ -292,12 +302,20 @@ int intel_iommu_enabled = 0;
 EXPORT_SYMBOL_GPL(intel_iommu_enabled);
 
 static int dmar_map_gfx = 1;
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+static int dmar_map_ipts = 1;
+static int dmar_map_ipu = 1;
+#endif
 static int intel_iommu_superpage = 1;
 static int iommu_identity_mapping;
 static int iommu_skip_te_disable;
 
 #define IDENTMAP_GFX		2
 #define IDENTMAP_AZALIA		4
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+#define IDENTMAP_IPU		8
+#define IDENTMAP_IPTS		16
+#endif
 
 const struct iommu_ops intel_iommu_ops;
 
@@ -2545,6 +2563,15 @@ static int device_def_domain_type(struct
 
 		if ((iommu_identity_mapping & IDENTMAP_GFX) && IS_GFX_DEVICE(pdev))
 			return IOMMU_DOMAIN_IDENTITY;
+
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+		if ((iommu_identity_mapping & IDENTMAP_IPU) && IS_INTEL_IPU(pdev))
+			return IOMMU_DOMAIN_IDENTITY;
+
+		if ((iommu_identity_mapping & IDENTMAP_IPTS) && IS_IPTS(pdev))
+			return IOMMU_DOMAIN_IDENTITY;
+#endif
+	
 	}
 
 	return 0;
@@ -2852,6 +2879,14 @@ static int __init init_dmars(void)
 	if (!dmar_map_gfx)
 		iommu_identity_mapping |= IDENTMAP_GFX;
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	if (!dmar_map_ipu)
+		iommu_identity_mapping |= IDENTMAP_IPU;
+
+	if (!dmar_map_ipts)
+		iommu_identity_mapping |= IDENTMAP_IPTS;
+#endif
+
 	check_tylersburg_isoch();
 
 	ret = si_domain_init(hw_pass_through);
@@ -4832,6 +4867,32 @@ static void quirk_iommu_igfx(struct pci_
 	dmar_map_gfx = 0;
 }
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+static void quirk_iommu_ipu(struct pci_dev *dev)
+{
+	if (!IS_INTEL_IPU(dev))
+		return;
+
+	if (risky_device(dev))
+		return;
+
+	pci_info(dev, "Passthrough IOMMU for integrated Intel IPU\n");
+	dmar_map_ipu = 0;
+}
+
+static void quirk_iommu_ipts(struct pci_dev *dev)
+{
+	if (!IS_IPTS(dev))
+		return;
+
+	if (risky_device(dev))
+		return;
+
+	pci_info(dev, "Passthrough IOMMU for IPTS\n");
+	dmar_map_ipts = 0;
+}
+#endif
+
 /* G4x/GM45 integrated gfx dmar support is totally busted. */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2a40, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x2e00, quirk_iommu_igfx);
@@ -4867,6 +4928,14 @@ DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_I
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163A, quirk_iommu_igfx);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x163D, quirk_iommu_igfx);
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+/* disable IPU dmar support */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, quirk_iommu_ipu);
+
+/* disable IPTS dmar support */
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, 0x9D3E, quirk_iommu_ipts);
+#endif
+
 static void quirk_iommu_rwbf(struct pci_dev *dev)
 {
 	if (risky_device(dev))
diff -Naurp a/linux-6.6.38.igel/drivers/media/i2c/dw9719.c b/linux-6.6.38.igel/drivers/media/i2c/dw9719.c
--- a/linux-6.6.38.igel/drivers/media/i2c/dw9719.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/media/i2c/dw9719.c	2024-08-02 15:41:31.551491490 +0200
@@ -6,6 +6,8 @@
  * https://github.com/ZenfoneArea/android_kernel_asus_zenfone5
  */
 
+#include <asm/unaligned.h>
+
 #include <linux/delay.h>
 #include <linux/i2c.h>
 #include <linux/pm_runtime.h>
diff -Naurp a/linux-6.6.38.igel/drivers/media/i2c/Kconfig b/linux-6.6.38.igel/drivers/media/i2c/Kconfig
--- a/linux-6.6.38.igel/drivers/media/i2c/Kconfig	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/media/i2c/Kconfig	2024-08-02 15:41:31.551491490 +0200
@@ -656,14 +656,14 @@ config VIDEO_DW9714
 
 config VIDEO_DW9719
 	tristate "DW9719 lens voice coil support"
-	depends on I2C && VIDEO_DEV
+	depends on I2C && VIDEO_DEV && IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
 	select MEDIA_CONTROLLER
 	select VIDEO_V4L2_SUBDEV_API
 	select V4L2_ASYNC
 	select V4L2_CCI_I2C
 	help
 	  This is a driver for the DW9719 camera lens voice coil.
-	  This is designed for linear control of voice coil motors,
+	  This is designed for linear control of  voice coil motors,
 	  controlled via I2C serial interface.
 
 config VIDEO_DW9768
diff -Naurp a/linux-6.6.38.igel/drivers/media/i2c/Makefile b/linux-6.6.38.igel/drivers/media/i2c/Makefile
--- a/linux-6.6.38.igel/drivers/media/i2c/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/media/i2c/Makefile	2024-08-02 15:41:31.551491490 +0200
@@ -32,6 +32,7 @@ obj-$(CONFIG_VIDEO_DS90UB913) += ds90ub9
 obj-$(CONFIG_VIDEO_DS90UB953) += ds90ub953.o
 obj-$(CONFIG_VIDEO_DS90UB960) += ds90ub960.o
 obj-$(CONFIG_VIDEO_DW9714) += dw9714.o
+# IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT handled in Kconfig option for VIDEO_DW9719
 obj-$(CONFIG_VIDEO_DW9719) += dw9719.o
 obj-$(CONFIG_VIDEO_DW9768) += dw9768.o
 obj-$(CONFIG_VIDEO_DW9807_VCM) += dw9807-vcm.o
diff -Naurp a/linux-6.6.38.igel/drivers/media/pci/intel/ipu3/ipu3-cio2.c b/linux-6.6.38.igel/drivers/media/pci/intel/ipu3/ipu3-cio2.c
--- a/linux-6.6.38.igel/drivers/media/pci/intel/ipu3/ipu3-cio2.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/media/pci/intel/ipu3/ipu3-cio2.c	2024-08-02 15:41:31.551491490 +0200
@@ -1388,7 +1388,11 @@ static int cio2_notifier_bound(struct v4
 	struct cio2_device *cio2 = to_cio2_device(notifier);
 	struct sensor_async_subdev *s_asd = to_sensor_asd(asd);
 	struct cio2_queue *q;
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	struct device *dev = &cio2->pci_dev->dev;
+	unsigned int pad;
 	int ret;
+#endif
 
 	if (cio2->queue[s_asd->csi2.port].sensor)
 		return -EBUSY;
@@ -1403,7 +1407,30 @@ static int cio2_notifier_bound(struct v4
 	q->sensor = sd;
 	q->csi_rx_base = cio2->base + CIO2_REG_PIPE_BASE(q->csi2.port);
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	for (pad = 0; pad < q->sensor->entity.num_pads; pad++)
+		if (q->sensor->entity.pads[pad].flags &
+					MEDIA_PAD_FL_SOURCE)
+			break;
+
+	if (pad == q->sensor->entity.num_pads) {
+		dev_err(dev, "failed to find src pad for %s\n",
+			q->sensor->name);
+		return -ENXIO;
+	}
+
+	ret = media_create_pad_link(&q->sensor->entity, pad, &q->subdev.entity,
+				    CIO2_PAD_SINK, 0);
+	if (ret) {
+		dev_err(dev, "failed to create link for %s\n",
+			q->sensor->name);
+		return ret;
+	}
+
+	return v4l2_device_register_subdev_nodes(&cio2->v4l2_dev);
+#else
 	return 0;
+#endif
 }
 
 /* The .unbind callback */
@@ -1421,6 +1448,7 @@ static void cio2_notifier_unbind(struct
 static int cio2_notifier_complete(struct v4l2_async_notifier *notifier)
 {
 	struct cio2_device *cio2 = to_cio2_device(notifier);
+#ifndef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
 	struct device *dev = &cio2->pci_dev->dev;
 	struct sensor_async_subdev *s_asd;
 	struct v4l2_async_connection *asd;
@@ -1449,6 +1477,7 @@ static int cio2_notifier_complete(struct
 			return ret;
 		}
 	}
+#endif
 
 	return v4l2_device_register_subdev_nodes(&cio2->v4l2_dev);
 }
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/context.h b/linux-6.6.38.igel/drivers/misc/ipts/context.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/context.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/context.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_CONTEXT_H_
+#define _IPTS_CONTEXT_H_
+
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/types.h>
+
+#include "protocol.h"
+
+enum ipts_host_status {
+	IPTS_HOST_STATUS_STARTING,
+	IPTS_HOST_STATUS_STARTED,
+	IPTS_HOST_STATUS_STOPPING,
+	IPTS_HOST_STATUS_STOPPED,
+};
+
+struct ipts_buffer_info {
+	u8 *address;
+	dma_addr_t dma_address;
+};
+
+struct ipts_context {
+	struct mei_cl_device *cldev;
+	struct device *dev;
+
+	bool restart;
+	enum ipts_host_status status;
+	struct ipts_get_device_info_rsp device_info;
+
+	struct ipts_buffer_info data[IPTS_BUFFERS];
+	struct ipts_buffer_info doorbell;
+
+	struct ipts_buffer_info feedback[IPTS_BUFFERS];
+	struct ipts_buffer_info workqueue;
+	struct ipts_buffer_info host2me;
+};
+
+#endif /* _IPTS_CONTEXT_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/control.c b/linux-6.6.38.igel/drivers/misc/ipts/control.c
--- a/linux-6.6.38.igel/drivers/misc/ipts/control.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/control.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,113 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/mei_cl_bus.h>
+
+#include "context.h"
+#include "protocol.h"
+#include "resources.h"
+#include "uapi.h"
+
+int ipts_control_send(struct ipts_context *ipts, u32 code, void *payload,
+		      size_t size)
+{
+	int ret;
+	struct ipts_command cmd;
+
+	memset(&cmd, 0, sizeof(struct ipts_command));
+	cmd.code = code;
+
+	if (payload && size > 0)
+		memcpy(&cmd.payload, payload, size);
+
+	ret = mei_cldev_send(ipts->cldev, (u8 *)&cmd, sizeof(cmd.code) + size);
+	if (ret >= 0)
+		return 0;
+
+	/*
+	 * During shutdown the device might get pulled away from below our feet.
+	 * Dont log an error in this case, because it will confuse people.
+	 */
+	if (ret != -ENODEV || ipts->status != IPTS_HOST_STATUS_STOPPING)
+		dev_err(ipts->dev, "Error while sending: 0x%X:%d\n", code, ret);
+
+	return ret;
+}
+
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer)
+{
+	struct ipts_feedback_cmd cmd;
+
+	memset(&cmd, 0, sizeof(struct ipts_feedback_cmd));
+	cmd.buffer = buffer;
+
+	return ipts_control_send(ipts, IPTS_CMD_FEEDBACK, &cmd,
+				 sizeof(struct ipts_feedback_cmd));
+}
+
+int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value)
+{
+	struct ipts_feedback_buffer *feedback;
+
+	memset(ipts->host2me.address, 0, ipts->device_info.feedback_size);
+	feedback = (struct ipts_feedback_buffer *)ipts->host2me.address;
+
+	feedback->cmd_type = IPTS_FEEDBACK_CMD_TYPE_NONE;
+	feedback->data_type = IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES;
+	feedback->buffer = IPTS_HOST2ME_BUFFER;
+	feedback->size = 2;
+	feedback->payload[0] = report;
+	feedback->payload[1] = value;
+
+	return ipts_control_send_feedback(ipts, IPTS_HOST2ME_BUFFER);
+}
+
+int ipts_control_start(struct ipts_context *ipts)
+{
+	if (ipts->status != IPTS_HOST_STATUS_STOPPED)
+		return -EBUSY;
+
+	dev_info(ipts->dev, "Starting IPTS\n");
+	ipts->status = IPTS_HOST_STATUS_STARTING;
+	ipts->restart = false;
+
+	ipts_uapi_link(ipts);
+	return ipts_control_send(ipts, IPTS_CMD_GET_DEVICE_INFO, NULL, 0);
+}
+
+int ipts_control_stop(struct ipts_context *ipts)
+{
+	int ret;
+
+	if (ipts->status == IPTS_HOST_STATUS_STOPPING)
+		return -EBUSY;
+
+	if (ipts->status == IPTS_HOST_STATUS_STOPPED)
+		return -EBUSY;
+
+	dev_info(ipts->dev, "Stopping IPTS\n");
+	ipts->status = IPTS_HOST_STATUS_STOPPING;
+
+	ipts_uapi_unlink();
+	ipts_resources_free(ipts);
+
+	ret = ipts_control_send_feedback(ipts, 0);
+	if (ret == -ENODEV)
+		ipts->status = IPTS_HOST_STATUS_STOPPED;
+
+	return ret;
+}
+
+int ipts_control_restart(struct ipts_context *ipts)
+{
+	if (ipts->restart)
+		return -EBUSY;
+
+	ipts->restart = true;
+	return ipts_control_stop(ipts);
+}
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/control.h b/linux-6.6.38.igel/drivers/misc/ipts/control.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/control.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/control.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_CONTROL_H_
+#define _IPTS_CONTROL_H_
+
+#include <linux/types.h>
+
+#include "context.h"
+
+int ipts_control_send(struct ipts_context *ipts, u32 cmd, void *payload,
+		      size_t size);
+int ipts_control_send_feedback(struct ipts_context *ipts, u32 buffer);
+int ipts_control_set_feature(struct ipts_context *ipts, u8 report, u8 value);
+int ipts_control_start(struct ipts_context *ipts);
+int ipts_control_restart(struct ipts_context *ipts);
+int ipts_control_stop(struct ipts_context *ipts);
+
+#endif /* _IPTS_CONTROL_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/Kconfig b/linux-6.6.38.igel/drivers/misc/ipts/Kconfig
--- a/linux-6.6.38.igel/drivers/misc/ipts/Kconfig	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/Kconfig	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,17 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+
+config MISC_IPTS
+	tristate "Intel Precise Touch & Stylus"
+	depends on INTEL_MEI
+	help
+	  Say Y here if your system has a touchscreen using Intels
+	  Precise Touch & Stylus (IPTS) technology.
+
+	  If unsure say N.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called ipts.
+
+	  Building this driver alone will not give you a working touchscreen.
+	  It only exposed a userspace API that can be used by a daemon to
+	  receive and process data from the touchscreen hardware.
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/Makefile b/linux-6.6.38.igel/drivers/misc/ipts/Makefile
--- a/linux-6.6.38.igel/drivers/misc/ipts/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/Makefile	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0-or-later
+#
+# Makefile for the IPTS touchscreen driver
+#
+
+obj-$(CONFIG_MISC_IPTS) += ipts.o
+ipts-objs := control.o
+ipts-objs += mei.o
+ipts-objs += receiver.o
+ipts-objs += resources.o
+ipts-objs += uapi.o
+
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/mei.c b/linux-6.6.38.igel/drivers/misc/ipts/mei.c
--- a/linux-6.6.38.igel/drivers/misc/ipts/mei.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/mei.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/mei_cl_bus.h>
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "receiver.h"
+#include "uapi.h"
+
+static int ipts_mei_set_dma_mask(struct mei_cl_device *cldev)
+{
+	int ret;
+
+	ret = dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(64));
+	if (!ret)
+		return 0;
+
+	return dma_coerce_mask_and_coherent(&cldev->dev, DMA_BIT_MASK(32));
+}
+
+static int ipts_mei_probe(struct mei_cl_device *cldev,
+			  const struct mei_cl_device_id *id)
+{
+	int ret;
+	struct ipts_context *ipts;
+
+	if (ipts_mei_set_dma_mask(cldev)) {
+		dev_err(&cldev->dev, "Failed to set DMA mask for IPTS\n");
+		return -EFAULT;
+	}
+
+	ret = mei_cldev_enable(cldev);
+	if (ret) {
+		dev_err(&cldev->dev, "Failed to enable MEI device: %d\n", ret);
+		return ret;
+	}
+
+	ipts = kzalloc(sizeof(*ipts), GFP_KERNEL);
+	if (!ipts) {
+		mei_cldev_disable(cldev);
+		return -ENOMEM;
+	}
+
+	ipts->cldev = cldev;
+	ipts->dev = &cldev->dev;
+	ipts->status = IPTS_HOST_STATUS_STOPPED;
+
+	mei_cldev_set_drvdata(cldev, ipts);
+	mei_cldev_register_rx_cb(cldev, ipts_receiver_callback);
+
+	return ipts_control_start(ipts);
+}
+
+static void ipts_mei_remove(struct mei_cl_device *cldev)
+{
+	int i;
+	struct ipts_context *ipts = mei_cldev_get_drvdata(cldev);
+
+	ipts_control_stop(ipts);
+
+	for (i = 0; i < 20; i++) {
+		if (ipts->status == IPTS_HOST_STATUS_STOPPED)
+			break;
+
+		msleep(25);
+	}
+
+	mei_cldev_disable(cldev);
+	kfree(ipts);
+}
+
+static struct mei_cl_device_id ipts_mei_device_id_table[] = {
+	{ "", IPTS_MEI_UUID, MEI_CL_VERSION_ANY },
+	{},
+};
+MODULE_DEVICE_TABLE(mei, ipts_mei_device_id_table);
+
+static struct mei_cl_driver ipts_mei_driver = {
+	.id_table = ipts_mei_device_id_table,
+	.name = "ipts",
+	.probe = ipts_mei_probe,
+	.remove = ipts_mei_remove,
+};
+
+static int __init ipts_mei_init(void)
+{
+	int ret;
+
+	ret = ipts_uapi_init();
+	if (ret)
+		return ret;
+
+	ret = mei_cldev_driver_register(&ipts_mei_driver);
+	if (ret) {
+		ipts_uapi_free();
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit ipts_mei_exit(void)
+{
+	mei_cldev_driver_unregister(&ipts_mei_driver);
+	ipts_uapi_free();
+}
+
+MODULE_DESCRIPTION("IPTS touchscreen driver");
+MODULE_AUTHOR("Dorian Stoll <dorian.stoll@tmsp.io>");
+MODULE_LICENSE("GPL");
+
+module_init(ipts_mei_init);
+module_exit(ipts_mei_exit);
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/protocol.h b/linux-6.6.38.igel/drivers/misc/ipts/protocol.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/protocol.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,347 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_PROTOCOL_H_
+#define _IPTS_PROTOCOL_H_
+
+#include <linux/types.h>
+
+/*
+ * The MEI client ID for IPTS functionality.
+ */
+#define IPTS_MEI_UUID                                                          \
+	UUID_LE(0x3e8d0870, 0x271a, 0x4208, 0x8e, 0xb5, 0x9a, 0xcb, 0x94,      \
+		0x02, 0xae, 0x04)
+
+/*
+ * Queries the device for vendor specific information.
+ *
+ * The command must not contain any payload.
+ * The response will contain struct ipts_get_device_info_rsp as payload.
+ */
+#define IPTS_CMD_GET_DEVICE_INFO 0x00000001
+#define IPTS_RSP_GET_DEVICE_INFO 0x80000001
+
+/*
+ * Sets the mode that IPTS will operate in.
+ *
+ * The command must contain struct ipts_set_mode_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_SET_MODE 0x00000002
+#define IPTS_RSP_SET_MODE 0x80000002
+
+/*
+ * Configures the memory buffers that the ME will use
+ * for passing data to the host.
+ *
+ * The command must contain struct ipts_set_mem_window_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_SET_MEM_WINDOW 0x00000003
+#define IPTS_RSP_SET_MEM_WINDOW 0x80000003
+
+/*
+ * Signals that the host is ready to receive data to the ME.
+ *
+ * The command must not contain any payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_READY_FOR_DATA 0x00000005
+#define IPTS_RSP_READY_FOR_DATA 0x80000005
+
+/*
+ * Signals that a buffer can be refilled to the ME.
+ *
+ * The command must contain struct ipts_feedback_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_FEEDBACK 0x00000006
+#define IPTS_RSP_FEEDBACK 0x80000006
+
+/*
+ * Resets the data flow from the ME to the hosts and
+ * clears the buffers that were set with SET_MEM_WINDOW.
+ *
+ * The command must not contain any payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_CLEAR_MEM_WINDOW 0x00000007
+#define IPTS_RSP_CLEAR_MEM_WINDOW 0x80000007
+
+/*
+ * Instructs the ME to reset the touch sensor.
+ *
+ * The command must contain struct ipts_reset_sensor_cmd as payload.
+ * The response will not contain any payload.
+ */
+#define IPTS_CMD_RESET_SENSOR 0x0000000B
+#define IPTS_RSP_RESET_SENSOR 0x8000000B
+
+/**
+ * enum ipts_status - Possible status codes returned by IPTS commands.
+ * @IPTS_STATUS_SUCCESS:                 Operation completed successfully.
+ * @IPTS_STATUS_INVALID_PARAMS:          Command contained a payload with invalid parameters.
+ * @IPTS_STATUS_ACCESS_DENIED:           ME could not validate buffer addresses supplied by host.
+ * @IPTS_STATUS_CMD_SIZE_ERROR:          Command contains an invalid payload.
+ * @IPTS_STATUS_NOT_READY:               Buffer addresses have not been set.
+ * @IPTS_STATUS_REQUEST_OUTSTANDING:     There is an outstanding command of the same type.
+ *                                       The host must wait for a response before sending another
+ *                                       command of the same type.
+ * @IPTS_STATUS_NO_SENSOR_FOUND:         No sensor could be found. Either no sensor is connected, it
+ *                                       has not been initialized yet, or the system is improperly
+ *                                       configured.
+ * @IPTS_STATUS_OUT_OF_MEMORY:           Not enough free memory for requested operation.
+ * @IPTS_STATUS_INTERNAL_ERROR:          An unexpected error occurred.
+ * @IPTS_STATUS_SENSOR_DISABLED:         The sensor has been disabled and must be reinitialized.
+ * @IPTS_STATUS_COMPAT_CHECK_FAIL:       Compatibility revision check between sensor and ME failed.
+ *                                       The host can ignore this error and attempt to continue.
+ * @IPTS_STATUS_SENSOR_EXPECTED_RESET:   The sensor went through a reset initiated by ME or host.
+ * @IPTS_STATUS_SENSOR_UNEXPECTED_RESET: The sensor went through an unexpected reset.
+ * @IPTS_STATUS_RESET_FAILED:            Requested sensor reset failed to complete.
+ * @IPTS_STATUS_TIMEOUT:                 The operation timed out.
+ * @IPTS_STATUS_TEST_MODE_FAIL:          Test mode pattern did not match expected values.
+ * @IPTS_STATUS_SENSOR_FAIL_FATAL:       The sensor reported a fatal error during reset sequence.
+ *                                       Further progress is not possible.
+ * @IPTS_STATUS_SENSOR_FAIL_NONFATAL:    The sensor reported a fatal error during reset sequence.
+ *                                       The host can attempt to continue.
+ * @IPTS_STATUS_INVALID_DEVICE_CAPS:     The device reported invalid capabilities.
+ * @IPTS_STATUS_QUIESCE_IO_IN_PROGRESS:  Command cannot be completed until Quiesce IO is done.
+ */
+enum ipts_status {
+	IPTS_STATUS_SUCCESS = 0,
+	IPTS_STATUS_INVALID_PARAMS = 1,
+	IPTS_STATUS_ACCESS_DENIED = 2,
+	IPTS_STATUS_CMD_SIZE_ERROR = 3,
+	IPTS_STATUS_NOT_READY = 4,
+	IPTS_STATUS_REQUEST_OUTSTANDING = 5,
+	IPTS_STATUS_NO_SENSOR_FOUND = 6,
+	IPTS_STATUS_OUT_OF_MEMORY = 7,
+	IPTS_STATUS_INTERNAL_ERROR = 8,
+	IPTS_STATUS_SENSOR_DISABLED = 9,
+	IPTS_STATUS_COMPAT_CHECK_FAIL = 10,
+	IPTS_STATUS_SENSOR_EXPECTED_RESET = 11,
+	IPTS_STATUS_SENSOR_UNEXPECTED_RESET = 12,
+	IPTS_STATUS_RESET_FAILED = 13,
+	IPTS_STATUS_TIMEOUT = 14,
+	IPTS_STATUS_TEST_MODE_FAIL = 15,
+	IPTS_STATUS_SENSOR_FAIL_FATAL = 16,
+	IPTS_STATUS_SENSOR_FAIL_NONFATAL = 17,
+	IPTS_STATUS_INVALID_DEVICE_CAPS = 18,
+	IPTS_STATUS_QUIESCE_IO_IN_PROGRESS = 19,
+};
+
+/*
+ * The amount of buffers that is used for IPTS
+ */
+#define IPTS_BUFFERS 16
+
+/*
+ * The special buffer ID that is used for direct host2me feedback.
+ */
+#define IPTS_HOST2ME_BUFFER IPTS_BUFFERS
+
+/**
+ * enum ipts_mode - Operation mode for IPTS hardware
+ * @IPTS_MODE_SINGLETOUCH: Fallback that supports only one finger and no stylus.
+ *                         The data is received as a HID report with ID 64.
+ * @IPTS_MODE_MULTITOUCH:  The "proper" operation mode for IPTS. It will return
+ *                         stylus data as well as capacitive heatmap touch data.
+ *                         This data needs to be processed in userspace.
+ */
+enum ipts_mode {
+	IPTS_MODE_SINGLETOUCH = 0,
+	IPTS_MODE_MULTITOUCH = 1,
+};
+
+/**
+ * struct ipts_set_mode_cmd - Payload for the SET_MODE command.
+ * @mode: The mode that IPTS should operate in.
+ */
+struct ipts_set_mode_cmd {
+	enum ipts_mode mode;
+	u8 reserved[12];
+} __packed;
+
+#define IPTS_WORKQUEUE_SIZE	 8192
+#define IPTS_WORKQUEUE_ITEM_SIZE 16
+
+/**
+ * struct ipts_set_mem_window_cmd - Payload for the SET_MEM_WINDOW command.
+ * @data_buffer_addr_lower:     Lower 32 bits of the data buffer addresses.
+ * @data_buffer_addr_upper:     Upper 32 bits of the data buffer addresses.
+ * @workqueue_addr_lower:       Lower 32 bits of the workqueue buffer address.
+ * @workqueue_addr_upper:       Upper 32 bits of the workqueue buffer address.
+ * @doorbell_addr_lower:        Lower 32 bits of the doorbell buffer address.
+ * @doorbell_addr_upper:        Upper 32 bits of the doorbell buffer address.
+ * @feedback_buffer_addr_lower: Lower 32 bits of the feedback buffer addresses.
+ * @feedback_buffer_addr_upper: Upper 32 bits of the feedback buffer addresses.
+ * @host2me_addr_lower:         Lower 32 bits of the host2me buffer address.
+ * @host2me_addr_upper:         Upper 32 bits of the host2me buffer address.
+ * @workqueue_item_size:        Magic value. (IPTS_WORKQUEUE_ITEM_SIZE)
+ * @workqueue_size:             Magic value. (IPTS_WORKQUEUE_SIZE)
+ *
+ * The data buffers are buffers that get filled with touch data by the ME.
+ * The doorbell buffer is a u32 that gets incremented by the ME once a data
+ * buffer has been filled with new data.
+ *
+ * The other buffers are required for using GuC submission with binary
+ * firmware. Since support for GuC submission has been dropped from i915,
+ * they are not used anymore, but they need to be allocated and passed,
+ * otherwise the hardware will refuse to start.
+ */
+struct ipts_set_mem_window_cmd {
+	u32 data_buffer_addr_lower[IPTS_BUFFERS];
+	u32 data_buffer_addr_upper[IPTS_BUFFERS];
+	u32 workqueue_addr_lower;
+	u32 workqueue_addr_upper;
+	u32 doorbell_addr_lower;
+	u32 doorbell_addr_upper;
+	u32 feedback_buffer_addr_lower[IPTS_BUFFERS];
+	u32 feedback_buffer_addr_upper[IPTS_BUFFERS];
+	u32 host2me_addr_lower;
+	u32 host2me_addr_upper;
+	u32 host2me_size;
+	u8 reserved1;
+	u8 workqueue_item_size;
+	u16 workqueue_size;
+	u8 reserved[32];
+} __packed;
+
+/**
+ * struct ipts_feedback_cmd - Payload for the FEEDBACK command.
+ * @buffer: The buffer that the ME should refill.
+ */
+struct ipts_feedback_cmd {
+	u32 buffer;
+	u8 reserved[12];
+} __packed;
+
+/**
+ * enum ipts_feedback_cmd_type - Commands that can be executed on the sensor through feedback.
+ */
+enum ipts_feedback_cmd_type {
+	IPTS_FEEDBACK_CMD_TYPE_NONE = 0,
+	IPTS_FEEDBACK_CMD_TYPE_SOFT_RESET = 1,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_ARMED = 2,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SENSING = 3,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_SLEEP = 4,
+	IPTS_FEEDBACK_CMD_TYPE_GOTO_DOZE = 5,
+	IPTS_FEEDBACK_CMD_TYPE_HARD_RESET = 6,
+};
+
+/**
+ * enum ipts_feedback_data_type - Describes the data that a feedback buffer contains.
+ * @IPTS_FEEDBACK_DATA_TYPE_VENDOR:        The buffer contains vendor specific feedback.
+ * @IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES:  The buffer contains a HID set features command.
+ * @IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES:  The buffer contains a HID get features command.
+ * @IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT: The buffer contains a HID output report.
+ * @IPTS_FEEDBACK_DATA_TYPE_STORE_DATA:    The buffer contains calibration data for the sensor.
+ */
+enum ipts_feedback_data_type {
+	IPTS_FEEDBACK_DATA_TYPE_VENDOR = 0,
+	IPTS_FEEDBACK_DATA_TYPE_SET_FEATURES = 1,
+	IPTS_FEEDBACK_DATA_TYPE_GET_FEATURES = 2,
+	IPTS_FEEDBACK_DATA_TYPE_OUTPUT_REPORT = 3,
+	IPTS_FEEDBACK_DATA_TYPE_STORE_DATA = 4,
+};
+
+/**
+ * struct ipts_feedback_buffer - The contents of an IPTS feedback buffer.
+ * @cmd_type: A command that should be executed on the sensor.
+ * @size: The size of the payload to be written.
+ * @buffer: The ID of the buffer that contains this feedback data.
+ * @protocol: The protocol version of the EDS.
+ * @data_type: The type of payload that the buffer contains.
+ * @spi_offset: The offset at which to write the payload data.
+ * @payload: Payload for the feedback command, or 0 if no payload is sent.
+ */
+struct ipts_feedback_buffer {
+	enum ipts_feedback_cmd_type cmd_type;
+	u32 size;
+	u32 buffer;
+	u32 protocol;
+	enum ipts_feedback_data_type data_type;
+	u32 spi_offset;
+	u8 reserved[40];
+	u8 payload[];
+} __packed;
+
+/**
+ * enum ipts_reset_type - Possible ways of resetting the touch sensor
+ * @IPTS_RESET_TYPE_HARD: Perform hardware reset using GPIO pin.
+ * @IPTS_RESET_TYPE_SOFT: Perform software reset using SPI interface.
+ */
+enum ipts_reset_type {
+	IPTS_RESET_TYPE_HARD = 0,
+	IPTS_RESET_TYPE_SOFT = 1,
+};
+
+/**
+ * struct ipts_reset_sensor_cmd - Payload for the RESET_SENSOR command.
+ * @type: What type of reset should be performed.
+ */
+struct ipts_reset_sensor_cmd {
+	enum ipts_reset_type type;
+	u8 reserved[4];
+} __packed;
+
+/**
+ * struct ipts_command - A message sent from the host to the ME.
+ * @code:    The message code describing the command. (see IPTS_CMD_*)
+ * @payload: Payload for the command, or 0 if no payload is required.
+ */
+struct ipts_command {
+	u32 code;
+	u8 payload[320];
+} __packed;
+
+/**
+ * struct ipts_device_info - Payload for the GET_DEVICE_INFO response.
+ * @vendor_id:     Vendor ID of the touch sensor.
+ * @device_id:     Device ID of the touch sensor.
+ * @hw_rev:        Hardware revision of the touch sensor.
+ * @fw_rev:        Firmware revision of the touch sensor.
+ * @data_size:     Required size of one data buffer.
+ * @feedback_size: Required size of one feedback buffer.
+ * @mode:          Current operation mode of IPTS.
+ * @max_contacts:  The amount of concurrent touches supported by the sensor.
+ */
+struct ipts_get_device_info_rsp {
+	u16 vendor_id;
+	u16 device_id;
+	u32 hw_rev;
+	u32 fw_rev;
+	u32 data_size;
+	u32 feedback_size;
+	enum ipts_mode mode;
+	u8 max_contacts;
+	u8 reserved[19];
+} __packed;
+
+/**
+ * struct ipts_feedback_rsp - Payload for the FEEDBACK response.
+ * @buffer: The buffer that has received feedback.
+ */
+struct ipts_feedback_rsp {
+	u32 buffer;
+} __packed;
+
+/**
+ * struct ipts_response - A message sent from the ME to the host.
+ * @code:    The message code describing the response. (see IPTS_RSP_*)
+ * @status:  The status code returned by the command.
+ * @payload: Payload returned by the command.
+ */
+struct ipts_response {
+	u32 code;
+	enum ipts_status status;
+	u8 payload[80];
+} __packed;
+
+#endif /* _IPTS_PROTOCOL_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/receiver.c b/linux-6.6.38.igel/drivers/misc/ipts/receiver.c
--- a/linux-6.6.38.igel/drivers/misc/ipts/receiver.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/receiver.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,224 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/mei_cl_bus.h>
+#include <linux/moduleparam.h>
+#include <linux/types.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "resources.h"
+
+/*
+ * Temporary parameter to guard gen7 multitouch mode.
+ * Remove once gen7 has stable iptsd support.
+ */
+static bool gen7mt;
+module_param(gen7mt, bool, 0644);
+
+static int ipts_receiver_handle_get_device_info(struct ipts_context *ipts,
+						struct ipts_response *rsp)
+{
+	struct ipts_set_mode_cmd cmd;
+
+	memcpy(&ipts->device_info, rsp->payload,
+	       sizeof(struct ipts_get_device_info_rsp));
+
+	memset(&cmd, 0, sizeof(struct ipts_set_mode_cmd));
+	cmd.mode = IPTS_MODE_MULTITOUCH;
+
+	return ipts_control_send(ipts, IPTS_CMD_SET_MODE, &cmd,
+				 sizeof(struct ipts_set_mode_cmd));
+}
+
+static int ipts_receiver_handle_set_mode(struct ipts_context *ipts)
+{
+	int i, ret;
+	struct ipts_set_mem_window_cmd cmd;
+
+	ret = ipts_resources_alloc(ipts);
+	if (ret) {
+		dev_err(ipts->dev, "Failed to allocate resources\n");
+		return ret;
+	}
+
+	memset(&cmd, 0, sizeof(struct ipts_set_mem_window_cmd));
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		cmd.data_buffer_addr_lower[i] =
+			lower_32_bits(ipts->data[i].dma_address);
+
+		cmd.data_buffer_addr_upper[i] =
+			upper_32_bits(ipts->data[i].dma_address);
+
+		cmd.feedback_buffer_addr_lower[i] =
+			lower_32_bits(ipts->feedback[i].dma_address);
+
+		cmd.feedback_buffer_addr_upper[i] =
+			upper_32_bits(ipts->feedback[i].dma_address);
+	}
+
+	cmd.workqueue_addr_lower = lower_32_bits(ipts->workqueue.dma_address);
+	cmd.workqueue_addr_upper = upper_32_bits(ipts->workqueue.dma_address);
+
+	cmd.doorbell_addr_lower = lower_32_bits(ipts->doorbell.dma_address);
+	cmd.doorbell_addr_upper = upper_32_bits(ipts->doorbell.dma_address);
+
+	cmd.host2me_addr_lower = lower_32_bits(ipts->host2me.dma_address);
+	cmd.host2me_addr_upper = upper_32_bits(ipts->host2me.dma_address);
+
+	cmd.workqueue_size = IPTS_WORKQUEUE_SIZE;
+	cmd.workqueue_item_size = IPTS_WORKQUEUE_ITEM_SIZE;
+
+	return ipts_control_send(ipts, IPTS_CMD_SET_MEM_WINDOW, &cmd,
+				 sizeof(struct ipts_set_mem_window_cmd));
+}
+
+static int ipts_receiver_handle_set_mem_window(struct ipts_context *ipts)
+{
+	int ret;
+
+	dev_info(ipts->dev, "Device %04hX:%04hX ready\n",
+		 ipts->device_info.vendor_id, ipts->device_info.device_id);
+	ipts->status = IPTS_HOST_STATUS_STARTED;
+
+	ret = ipts_control_send(ipts, IPTS_CMD_READY_FOR_DATA, NULL, 0);
+	if (ret)
+		return ret;
+
+	if (!gen7mt)
+		return 0;
+
+	return ipts_control_set_feature(ipts, 0x5, 0x1);
+}
+
+static int ipts_receiver_handle_feedback(struct ipts_context *ipts,
+					 struct ipts_response *rsp)
+{
+	struct ipts_feedback_rsp feedback;
+
+	if (ipts->status != IPTS_HOST_STATUS_STOPPING)
+		return 0;
+
+	memcpy(&feedback, rsp->payload, sizeof(feedback));
+
+	if (feedback.buffer < IPTS_BUFFERS - 1)
+		return ipts_control_send_feedback(ipts, feedback.buffer + 1);
+
+	return ipts_control_send(ipts, IPTS_CMD_CLEAR_MEM_WINDOW, NULL, 0);
+}
+
+static int ipts_receiver_handle_clear_mem_window(struct ipts_context *ipts)
+{
+	ipts->status = IPTS_HOST_STATUS_STOPPED;
+
+	if (ipts->restart)
+		return ipts_control_start(ipts);
+
+	return 0;
+}
+
+static bool ipts_receiver_sensor_was_reset(u32 status)
+{
+	return status == IPTS_STATUS_SENSOR_EXPECTED_RESET ||
+	       status == IPTS_STATUS_SENSOR_UNEXPECTED_RESET;
+}
+
+static bool ipts_receiver_handle_error(struct ipts_context *ipts,
+				       struct ipts_response *rsp)
+{
+	bool error;
+
+	switch (rsp->status) {
+	case IPTS_STATUS_SUCCESS:
+	case IPTS_STATUS_COMPAT_CHECK_FAIL:
+		error = false;
+		break;
+	case IPTS_STATUS_INVALID_PARAMS:
+		error = rsp->code != IPTS_RSP_FEEDBACK;
+		break;
+	case IPTS_STATUS_SENSOR_DISABLED:
+		error = ipts->status != IPTS_HOST_STATUS_STOPPING;
+		break;
+	default:
+		error = true;
+		break;
+	}
+
+	if (!error)
+		return false;
+
+	dev_err(ipts->dev, "Command 0x%08x failed: %d\n", rsp->code,
+		rsp->status);
+
+	if (ipts_receiver_sensor_was_reset(rsp->status)) {
+		dev_err(ipts->dev, "Sensor was reset\n");
+
+		if (ipts_control_restart(ipts))
+			dev_err(ipts->dev, "Failed to restart IPTS\n");
+	}
+
+	return true;
+}
+
+static void ipts_receiver_handle_response(struct ipts_context *ipts,
+					  struct ipts_response *rsp)
+{
+	int ret;
+
+	if (ipts_receiver_handle_error(ipts, rsp))
+		return;
+
+	switch (rsp->code) {
+	case IPTS_RSP_GET_DEVICE_INFO:
+		ret = ipts_receiver_handle_get_device_info(ipts, rsp);
+		break;
+	case IPTS_RSP_SET_MODE:
+		ret = ipts_receiver_handle_set_mode(ipts);
+		break;
+	case IPTS_RSP_SET_MEM_WINDOW:
+		ret = ipts_receiver_handle_set_mem_window(ipts);
+		break;
+	case IPTS_RSP_FEEDBACK:
+		ret = ipts_receiver_handle_feedback(ipts, rsp);
+		break;
+	case IPTS_RSP_CLEAR_MEM_WINDOW:
+		ret = ipts_receiver_handle_clear_mem_window(ipts);
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+
+	if (!ret)
+		return;
+
+	dev_err(ipts->dev, "Error while handling response 0x%08x: %d\n",
+		rsp->code, ret);
+
+	if (ipts_control_stop(ipts))
+		dev_err(ipts->dev, "Failed to stop IPTS\n");
+}
+
+void ipts_receiver_callback(struct mei_cl_device *cldev)
+{
+	int ret;
+	struct ipts_response rsp;
+	struct ipts_context *ipts;
+
+	ipts = mei_cldev_get_drvdata(cldev);
+
+	ret = mei_cldev_recv(cldev, (u8 *)&rsp, sizeof(struct ipts_response));
+	if (ret <= 0) {
+		dev_err(ipts->dev, "Error while reading response: %d\n", ret);
+		return;
+	}
+
+	ipts_receiver_handle_response(ipts, &rsp);
+}
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/receiver.h b/linux-6.6.38.igel/drivers/misc/ipts/receiver.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/receiver.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/receiver.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,16 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_RECEIVER_H_
+#define _IPTS_RECEIVER_H_
+
+#include <linux/mei_cl_bus.h>
+
+void ipts_receiver_callback(struct mei_cl_device *cldev);
+
+#endif /* _IPTS_RECEIVER_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/resources.c b/linux-6.6.38.igel/drivers/misc/ipts/resources.c
--- a/linux-6.6.38.igel/drivers/misc/ipts/resources.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/resources.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/dma-mapping.h>
+
+#include "context.h"
+
+void ipts_resources_free(struct ipts_context *ipts)
+{
+	int i;
+	struct ipts_buffer_info *buffers;
+
+	u32 data_buffer_size = ipts->device_info.data_size;
+	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->data;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dma_free_coherent(ipts->dev, data_buffer_size,
+				  buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = NULL;
+		buffers[i].dma_address = 0;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		if (!buffers[i].address)
+			continue;
+
+		dma_free_coherent(ipts->dev, feedback_buffer_size,
+				  buffers[i].address, buffers[i].dma_address);
+
+		buffers[i].address = NULL;
+		buffers[i].dma_address = 0;
+	}
+
+	if (ipts->doorbell.address) {
+		dma_free_coherent(ipts->dev, sizeof(u32),
+				  ipts->doorbell.address,
+				  ipts->doorbell.dma_address);
+
+		ipts->doorbell.address = NULL;
+		ipts->doorbell.dma_address = 0;
+	}
+
+	if (ipts->workqueue.address) {
+		dma_free_coherent(ipts->dev, sizeof(u32),
+				  ipts->workqueue.address,
+				  ipts->workqueue.dma_address);
+
+		ipts->workqueue.address = NULL;
+		ipts->workqueue.dma_address = 0;
+	}
+
+	if (ipts->host2me.address) {
+		dma_free_coherent(ipts->dev, feedback_buffer_size,
+				  ipts->host2me.address,
+				  ipts->host2me.dma_address);
+
+		ipts->host2me.address = NULL;
+		ipts->host2me.dma_address = 0;
+	}
+}
+
+int ipts_resources_alloc(struct ipts_context *ipts)
+{
+	int i;
+	struct ipts_buffer_info *buffers;
+
+	u32 data_buffer_size = ipts->device_info.data_size;
+	u32 feedback_buffer_size = ipts->device_info.feedback_size;
+
+	buffers = ipts->data;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		buffers[i].address =
+			dma_alloc_coherent(ipts->dev, data_buffer_size,
+					   &buffers[i].dma_address, GFP_KERNEL);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	buffers = ipts->feedback;
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		buffers[i].address =
+			dma_alloc_coherent(ipts->dev, feedback_buffer_size,
+					   &buffers[i].dma_address, GFP_KERNEL);
+
+		if (!buffers[i].address)
+			goto release_resources;
+	}
+
+	ipts->doorbell.address =
+		dma_alloc_coherent(ipts->dev, sizeof(u32),
+				   &ipts->doorbell.dma_address, GFP_KERNEL);
+
+	if (!ipts->doorbell.address)
+		goto release_resources;
+
+	ipts->workqueue.address =
+		dma_alloc_coherent(ipts->dev, sizeof(u32),
+				   &ipts->workqueue.dma_address, GFP_KERNEL);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	ipts->host2me.address =
+		dma_alloc_coherent(ipts->dev, feedback_buffer_size,
+				   &ipts->host2me.dma_address, GFP_KERNEL);
+
+	if (!ipts->workqueue.address)
+		goto release_resources;
+
+	return 0;
+
+release_resources:
+
+	ipts_resources_free(ipts);
+	return -ENOMEM;
+}
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/resources.h b/linux-6.6.38.igel/drivers/misc/ipts/resources.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/resources.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/resources.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_RESOURCES_H_
+#define _IPTS_RESOURCES_H_
+
+#include "context.h"
+
+int ipts_resources_alloc(struct ipts_context *ipts);
+void ipts_resources_free(struct ipts_context *ipts);
+
+#endif /* _IPTS_RESOURCES_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/uapi.c b/linux-6.6.38.igel/drivers/misc/ipts/uapi.c
--- a/linux-6.6.38.igel/drivers/misc/ipts/uapi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/uapi.c	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#include <linux/cdev.h>
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+
+#include "context.h"
+#include "control.h"
+#include "protocol.h"
+#include "uapi.h"
+
+struct ipts_uapi uapi;
+
+static ssize_t ipts_uapi_read(struct file *file, char __user *buf, size_t count,
+			      loff_t *offset)
+{
+	int buffer;
+	int maxbytes;
+	struct ipts_context *ipts = uapi.ipts;
+
+	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	maxbytes = ipts->device_info.data_size - *offset;
+	if (maxbytes <= 0 || count > maxbytes)
+		return -EINVAL;
+
+	if (copy_to_user(buf, ipts->data[buffer].address + *offset, count))
+		return -EFAULT;
+
+	return count;
+}
+
+static long ipts_uapi_ioctl_get_device_ready(struct ipts_context *ipts,
+					     unsigned long arg)
+{
+	void __user *buffer = (void __user *)arg;
+	u8 ready = 0;
+
+	if (ipts)
+		ready = ipts->status == IPTS_HOST_STATUS_STARTED;
+
+	if (copy_to_user(buffer, &ready, sizeof(u8)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_get_device_info(struct ipts_context *ipts,
+					    unsigned long arg)
+{
+	struct ipts_device_info info;
+	void __user *buffer = (void __user *)arg;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	info.vendor = ipts->device_info.vendor_id;
+	info.product = ipts->device_info.device_id;
+	info.version = ipts->device_info.fw_rev;
+	info.buffer_size = ipts->device_info.data_size;
+	info.max_contacts = ipts->device_info.max_contacts;
+
+	if (copy_to_user(buffer, &info, sizeof(struct ipts_device_info)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_get_doorbell(struct ipts_context *ipts,
+					 unsigned long arg)
+{
+	void __user *buffer = (void __user *)arg;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	if (copy_to_user(buffer, ipts->doorbell.address, sizeof(u32)))
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_send_feedback(struct ipts_context *ipts,
+					  struct file *file)
+{
+	int ret;
+	u32 buffer;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	buffer = MINOR(file->f_path.dentry->d_inode->i_rdev);
+
+	ret = ipts_control_send_feedback(ipts, buffer);
+	if (ret)
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl_send_reset(struct ipts_context *ipts)
+{
+	int ret;
+	struct ipts_reset_sensor_cmd cmd;
+
+	if (!ipts || ipts->status != IPTS_HOST_STATUS_STARTED)
+		return -ENODEV;
+
+	memset(&cmd, 0, sizeof(struct ipts_reset_sensor_cmd));
+	cmd.type = IPTS_RESET_TYPE_SOFT;
+
+	ret = ipts_control_send(ipts, IPTS_CMD_RESET_SENSOR, &cmd,
+				sizeof(struct ipts_reset_sensor_cmd));
+
+	if (ret)
+		return -EFAULT;
+
+	return 0;
+}
+
+static long ipts_uapi_ioctl(struct file *file, unsigned int cmd,
+			    unsigned long arg)
+{
+	struct ipts_context *ipts = uapi.ipts;
+
+	switch (cmd) {
+	case IPTS_IOCTL_GET_DEVICE_READY:
+		return ipts_uapi_ioctl_get_device_ready(ipts, arg);
+	case IPTS_IOCTL_GET_DEVICE_INFO:
+		return ipts_uapi_ioctl_get_device_info(ipts, arg);
+	case IPTS_IOCTL_GET_DOORBELL:
+		return ipts_uapi_ioctl_get_doorbell(ipts, arg);
+	case IPTS_IOCTL_SEND_FEEDBACK:
+		return ipts_uapi_ioctl_send_feedback(ipts, file);
+	case IPTS_IOCTL_SEND_RESET:
+		return ipts_uapi_ioctl_send_reset(ipts);
+	default:
+		return -ENOTTY;
+	}
+}
+
+static const struct file_operations ipts_uapi_fops = {
+	.owner = THIS_MODULE,
+	.read = ipts_uapi_read,
+	.unlocked_ioctl = ipts_uapi_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl = ipts_uapi_ioctl,
+#endif
+};
+
+void ipts_uapi_link(struct ipts_context *ipts)
+{
+	uapi.ipts = ipts;
+}
+
+void ipts_uapi_unlink(void)
+{
+	uapi.ipts = NULL;
+}
+
+int ipts_uapi_init(void)
+{
+	int i, major;
+
+	alloc_chrdev_region(&uapi.dev, 0, IPTS_BUFFERS, "ipts");
+	uapi.class = class_create(THIS_MODULE, "ipts");
+
+	major = MAJOR(uapi.dev);
+
+	cdev_init(&uapi.cdev, &ipts_uapi_fops);
+	uapi.cdev.owner = THIS_MODULE;
+	cdev_add(&uapi.cdev, MKDEV(major, 0), IPTS_BUFFERS);
+
+	for (i = 0; i < IPTS_BUFFERS; i++) {
+		device_create(uapi.class, NULL, MKDEV(major, i), NULL,
+			      "ipts/%d", i);
+	}
+
+	return 0;
+}
+
+void ipts_uapi_free(void)
+{
+	int i;
+	int major;
+
+	major = MAJOR(uapi.dev);
+
+	for (i = 0; i < IPTS_BUFFERS; i++)
+		device_destroy(uapi.class, MKDEV(major, i));
+
+	cdev_del(&uapi.cdev);
+
+	unregister_chrdev_region(MKDEV(major, 0), MINORMASK);
+	class_destroy(uapi.class);
+}
diff -Naurp a/linux-6.6.38.igel/drivers/misc/ipts/uapi.h b/linux-6.6.38.igel/drivers/misc/ipts/uapi.h
--- a/linux-6.6.38.igel/drivers/misc/ipts/uapi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/misc/ipts/uapi.h	2024-08-02 15:41:31.551491490 +0200
@@ -0,0 +1,47 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
+/*
+ * Copyright (c) 2016 Intel Corporation
+ * Copyright (c) 2020 Dorian Stoll
+ *
+ * Linux driver for Intel Precise Touch & Stylus
+ */
+
+#ifndef _IPTS_UAPI_H_
+#define _IPTS_UAPI_H_
+
+#include <linux/types.h>
+
+#include "context.h"
+
+struct ipts_uapi {
+	dev_t dev;
+	struct class *class;
+	struct cdev cdev;
+
+	struct ipts_context *ipts;
+};
+
+struct ipts_device_info {
+	__u16 vendor;
+	__u16 product;
+	__u32 version;
+	__u32 buffer_size;
+	__u8 max_contacts;
+
+	/* For future expansion */
+	__u8 reserved[19];
+};
+
+#define IPTS_IOCTL_GET_DEVICE_READY _IOR(0x86, 0x01, __u8)
+#define IPTS_IOCTL_GET_DEVICE_INFO  _IOR(0x86, 0x02, struct ipts_device_info)
+#define IPTS_IOCTL_GET_DOORBELL	    _IOR(0x86, 0x03, __u32)
+#define IPTS_IOCTL_SEND_FEEDBACK    _IO(0x86, 0x04)
+#define IPTS_IOCTL_SEND_RESET	    _IO(0x86, 0x05)
+
+void ipts_uapi_link(struct ipts_context *ipts);
+void ipts_uapi_unlink(void);
+
+int ipts_uapi_init(void);
+void ipts_uapi_free(void);
+
+#endif /* _IPTS_UAPI_H_ */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/Kconfig b/linux-6.6.38.igel/drivers/misc/Kconfig
--- a/linux-6.6.38.igel/drivers/misc/Kconfig	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/misc/Kconfig	2024-08-02 15:41:31.551491490 +0200
@@ -579,4 +579,5 @@ source "drivers/misc/cardreader/Kconfig"
 source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
 source "drivers/misc/mchp_pci1xxxx/Kconfig"
+source "drivers/misc/ipts/Kconfig"
 endmenu
diff -Naurp a/linux-6.6.38.igel/drivers/misc/Makefile b/linux-6.6.38.igel/drivers/misc/Makefile
--- a/linux-6.6.38.igel/drivers/misc/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/misc/Makefile	2024-08-02 15:41:31.551491490 +0200
@@ -63,6 +63,7 @@ obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v6
 obj-$(CONFIG_OPEN_DICE)		+= open-dice.o
 obj-$(CONFIG_GP_PCI1XXXX)	+= mchp_pci1xxxx/
 obj-$(CONFIG_VCPU_STALL_DETECTOR)	+= vcpu_stall_detector.o
+obj-$(CONFIG_MISC_IPTS)		+= ipts/
 obj-$(CONFIG_TMR_MANAGER)      += xilinx_tmr_manager.o
 obj-$(CONFIG_TMR_INJECT)	+= xilinx_tmr_inject.o
 obj-$(CONFIG_TPS6594_ESM)	+= tps6594-esm.o
diff -Naurp a/linux-6.6.38.igel/drivers/misc/mei/hw-me-regs.h b/linux-6.6.38.igel/drivers/misc/mei/hw-me-regs.h
--- a/linux-6.6.38.igel/drivers/misc/mei/hw-me-regs.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/misc/mei/hw-me-regs.h	2024-08-02 15:41:31.551491490 +0200
@@ -92,6 +92,9 @@
 #define MEI_DEV_ID_CDF        0x18D3  /* Cedar Fork */
 
 #define MEI_DEV_ID_ICP_LP     0x34E0  /* Ice Lake Point LP */
+#ifdef CONFIG_IGEL_SURFACE_IPTS_MEI_CHANGES
+#define MEI_DEV_ID_ICP_LP_3   0x34E4  /* Ice Lake Point LP 3 (iTouch) */
+#endif
 #define MEI_DEV_ID_ICP_N      0x38E0  /* Ice Lake Point N */
 
 #define MEI_DEV_ID_JSP_N      0x4DE0  /* Jasper Lake Point N */
diff -Naurp a/linux-6.6.38.igel/drivers/misc/mei/pci-me.c b/linux-6.6.38.igel/drivers/misc/mei/pci-me.c
--- a/linux-6.6.38.igel/drivers/misc/mei/pci-me.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/misc/mei/pci-me.c	2024-08-02 15:41:31.551491490 +0200
@@ -97,6 +97,9 @@ static const struct pci_device_id mei_me
 	{MEI_PCI_DEVICE(MEI_DEV_ID_CMP_H_3, MEI_ME_PCH8_ITOUCH_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP, MEI_ME_PCH12_CFG)},
+#ifdef CONFIG_IGEL_SURFACE_IPTS_MEI_CHANGES
+	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_LP_3, MEI_ME_PCH12_CFG)},
+#endif
 	{MEI_PCI_DEVICE(MEI_DEV_ID_ICP_N, MEI_ME_PCH12_CFG)},
 
 	{MEI_PCI_DEVICE(MEI_DEV_ID_TGP_LP, MEI_ME_PCH15_CFG)},
diff -Naurp a/linux-6.6.38.igel/drivers/mmc/core/block.c b/linux-6.6.38.igel/drivers/mmc/core/block.c
--- a/linux-6.6.38.igel/drivers/mmc/core/block.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/mmc/core/block.c	2024-08-02 15:41:31.551491490 +0200
@@ -2534,6 +2534,11 @@ static struct mmc_blk_data *mmc_blk_allo
 	 * messages to tell when the card is present.
 	 */
 
+#ifdef CONFIG_IGEL_MARK_MMC_SD_CARD_REMOVEABLE
+	/* gottwald@igel.com set removable flag if MMC type is SD card (cardreader in laptop for example) */
+	if (card->type == MMC_TYPE_SD_COMBO || card->type == MMC_TYPE_SD || card->type == MMC_TYPE_SDIO)
+		md->disk->flags |= GENHD_FL_REMOVABLE;
+#endif
 	snprintf(md->disk->disk_name, sizeof(md->disk->disk_name),
 		 "mmcblk%u%s", card->host->index, subname ? subname : "");
 
diff -Naurp a/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-core.c b/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-core.c
--- a/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-core.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-core.c	2024-08-02 15:41:31.551491490 +0200
@@ -902,6 +902,15 @@ static int byt_emmc_probe_slot(struct sd
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_CLIENTRON_SD_CARD_QUIRK
+static bool adl_clientron_removable(struct sdhci_pci_slot *slot)
+{
+	return slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_ADL_EMMC &&
+	       (dmi_match(DMI_SYS_VENDOR, "Clientron corp.") ||
+		dmi_match(DMI_PRODUCT_NAME, "UA9 TC156-AN"));
+}
+#endif
+
 static bool glk_broken_cqhci(struct sdhci_pci_slot *slot)
 {
 	return slot->chip->pdev->device == PCI_DEVICE_ID_INTEL_GLK_EMMC &&
@@ -919,6 +928,13 @@ static int glk_emmc_probe_slot(struct sd
 {
 	int ret = byt_emmc_probe_slot(slot);
 
+#ifdef CONFIG_IGEL_CLIENTRON_SD_CARD_QUIRK
+	if (adl_clientron_removable(slot)) {
+		printk(KERN_ERR "Mark MMC as removable\n");
+		slot->host->mmc->caps &= ~MMC_CAP_NONREMOVABLE;
+	}
+#endif
+
 	if (!glk_broken_cqhci(slot))
 		slot->host->mmc->caps2 |= MMC_CAP2_CQE;
 
@@ -1749,8 +1765,13 @@ static int amd_probe(struct sdhci_pci_ch
 
 	pci_dev_put(smbus_dev);
 
-	if (gen == AMD_CHIPSET_BEFORE_ML || gen == AMD_CHIPSET_CZ)
+	if (gen == AMD_CHIPSET_BEFORE_ML || gen == AMD_CHIPSET_CZ) {
 		chip->quirks2 |= SDHCI_QUIRK2_CLEAR_TRANSFERMODE_REG_BEFORE_CMD;
+#ifdef CONFIG_IGEL_MMC_QUIRK_FOR_SAMSUNG_TC2
+		/* gottwald@igel.com : Fix MMC support for Samsung TC2 */
+		chip->quirks2 |= SDHCI_QUIRK2_BROKEN_HS200;
+#endif
+	}
 
 	return 0;
 }
diff -Naurp a/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-o2micro.c b/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-o2micro.c
--- a/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-o2micro.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/mmc/host/sdhci-pci-o2micro.c	2024-08-02 15:41:31.555491585 +0200
@@ -314,13 +314,17 @@ static int sdhci_o2_dll_recovery(struct
 static int sdhci_o2_execute_tuning(struct mmc_host *mmc, u32 opcode)
 {
 	struct sdhci_host *host = mmc_priv(mmc);
+#ifndef CONFIG_IGEL_HP_T640_EMMC_FIX
 	struct sdhci_pci_slot *slot = sdhci_priv(host);
 	struct sdhci_pci_chip *chip = slot->chip;
+#endif
 	int current_bus_width = 0;
 	u32 scratch32 = 0;
 	u16 scratch = 0;
+#ifndef CONFIG_IGEL_HP_T640_EMMC_FIX
 	u8  scratch_8 = 0;
 	u32 reg_val;
+#endif
 
 	/*
 	 * This handler implements the hardware tuning that is specific to
@@ -339,6 +343,7 @@ static int sdhci_o2_execute_tuning(struc
 	scratch |= O2_SD_PWR_FORCE_L0;
 	sdhci_writew(host, scratch, O2_SD_MISC_CTRL);
 
+#ifndef CONFIG_IGEL_HP_T640_EMMC_FIX
 	/* Update output phase */
 	switch (chip->pdev->device) {
 	case PCI_DEVICE_ID_O2_SDS0:
@@ -378,6 +383,7 @@ static int sdhci_o2_execute_tuning(struc
 	default:
 		break;
 	}
+#endif
 
 	/* wait DLL lock, timeout value 5ms */
 	if (readx_poll_timeout(sdhci_o2_pll_dll_wdt_control, host,
@@ -607,6 +613,7 @@ static void sdhci_pci_o2_set_clock(struc
 		dmdn_200m = 0x25100000;
 	}
 
+#ifndef CONFIG_IGEL_HP_T640_EMMC_FIX
 	if ((host->timing == MMC_TIMING_UHS_SDR104) && (clock == 200000000)) {
 		pci_read_config_dword(chip->pdev, O2_SD_PLL_SETTING, &scratch_32);
 
@@ -622,6 +629,14 @@ static void sdhci_pci_o2_set_clock(struc
 	pci_read_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, &scratch_32);
 	scratch_32 &= ~(O2_SD_SEL_DLL | O2_SD_PHASE_MASK);
 	pci_write_config_dword(chip->pdev, O2_SD_OUTPUT_CLK_SOURCE_SWITCH, scratch_32);
+#else
+	if ((host->timing == MMC_TIMING_UHS_SDR104) && (clock == 200000000)) {
+		pci_read_config_dword(chip->pdev, O2_SD_PLL_SETTING, &scratch_32);
+
+		if ((scratch_32 & 0xFFFF0000) != 0x2c280000)
+			o2_pci_set_baseclk(chip, 0x2c280000);
+	}
+#endif
 
 	/* Lock WP */
 	pci_read_config_byte(chip->pdev, O2_SD_LOCK_WP, &scratch);
diff -Naurp a/linux-6.6.38.igel/drivers/net/ethernet/realtek/8139too.c b/linux-6.6.38.igel/drivers/net/ethernet/realtek/8139too.c
--- a/linux-6.6.38.igel/drivers/net/ethernet/realtek/8139too.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/ethernet/realtek/8139too.c	2024-08-02 15:41:31.555491585 +0200
@@ -1103,6 +1103,12 @@ static int rtl8139_init_one(struct pci_d
 	if (rtl_chip_info[tp->chipset].flags & HasHltClk)
 		RTL_W8 (HltClk, 'H');	/* 'R' would leave the clock running. */
 
+#ifdef CONFIG_IGEL_WOL_FIX_8139TOO
+	// lugmair@igel.com Kernel Patch
+	/* lang@igel.de: enable WOL */
+	if (rtl_chip_info[tp->chipset].flags & HasLWake)
+		device_set_wakeup_enable(&tp->pci_dev->dev, true);
+#endif
 	return 0;
 
 err_out:
@@ -2372,6 +2378,11 @@ static int rtl8139_set_wol(struct net_de
 	if (wol->wolopts & WAKE_BCAST)
 		cfg5 |= Cfg5_BWF;
 	RTL_W8 (Config5, cfg5);	/* need not unlock via Cfg9346 */
+#ifdef CONFIG_IGEL_WOL_FIX_8139TOO
+	// lugmair@igel.com Kernel patch
+	/* lang@igel.de: enable WOL */
+	device_set_wakeup_enable(&tp->pci_dev->dev, wol->wolopts);
+#endif
 	spin_unlock_irq(&tp->lock);
 
 	return 0;
@@ -2611,8 +2622,20 @@ static int __maybe_unused rtl8139_suspen
 	void __iomem *ioaddr = tp->mmio_addr;
 	unsigned long flags;
 
+#ifdef CONFIG_IGEL_WOL_FIX_8139TOO
+	// lugmair@igel.com Kernel patch
+	if (!netif_running (dev)) {
+		if (tp->pci_dev != NULL) {
+			/* lang@igel.de: enable WOL from d3 state */
+			pci_wake_from_d3(tp->pci_dev, true);
+			pci_set_power_state (tp->pci_dev, PCI_D3hot);
+		}
+		return 0;
+	}
+#else
 	if (!netif_running (dev))
 		return 0;
+#endif
 
 	netif_device_detach (dev);
 
@@ -2628,6 +2651,14 @@ static int __maybe_unused rtl8139_suspen
 
 	spin_unlock_irqrestore (&tp->lock, flags);
 
+#ifdef CONFIG_IGEL_WOL_FIX_8139TOO
+	// lugmair@igel.com Kernel patch
+	/* lang@igel.de: enable WOL from d3 state */
+	if (tp->pci_dev != NULL) {
+		pci_wake_from_d3(tp->pci_dev, true);
+		pci_set_power_state (tp->pci_dev, PCI_D3hot);
+	}
+#endif
 	return 0;
 }
 
@@ -2635,6 +2666,15 @@ static int __maybe_unused rtl8139_resume
 {
 	struct net_device *dev = dev_get_drvdata(device);
 
+#ifdef CONFIG_IGEL_WOL_FIX_8139TOO
+	struct rtl8139_private *tp = netdev_priv(dev);
+	/* lang@igel.de: disable WOL from d3 state */
+	if (tp->pci_dev != NULL) {
+		pci_set_power_state (tp->pci_dev, PCI_D0);
+		pci_wake_from_d3(tp->pci_dev, false);
+	}
+#endif
+
 	if (!netif_running (dev))
 		return 0;
 
diff -Naurp a/linux-6.6.38.igel/drivers/net/ethernet/realtek/r8169_main.c b/linux-6.6.38.igel/drivers/net/ethernet/realtek/r8169_main.c
--- a/linux-6.6.38.igel/drivers/net/ethernet/realtek/r8169_main.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/ethernet/realtek/r8169_main.c	2024-08-02 15:41:31.555491585 +0200
@@ -1421,7 +1421,16 @@ static void rtl8169_get_wol(struct net_d
 {
 	struct rtl8169_private *tp = netdev_priv(dev);
 
+#ifdef CONFIG_IGEL_FIX_R8169_WOL
+	/*
+	 *  waffler@igel.de :  for some reason the chip doesn't wake up
+	 *                     by any method if BCAST is involved
+	 *                     the hotfix is not to declare WAKE_BCAST as supported
+	 */
+	wol->supported = WAKE_ANY & (~WAKE_BCAST);
+#else
 	wol->supported = WAKE_ANY;
+#endif
 	wol->wolopts = tp->saved_wolopts;
 }
 
@@ -2544,7 +2553,12 @@ static void rtl_enable_rxdvgate(struct r
 
 static void rtl_wol_enable_rx(struct rtl8169_private *tp)
 {
+#ifdef CONFIG_IGEL_FIX_R8169_WOL
+	/* IGEL change use suspend quirk for more devices */
+	if (tp->mac_version >= RTL_GIGA_MAC_VER_18)
+#else
 	if (tp->mac_version >= RTL_GIGA_MAC_VER_25)
+#endif
 		RTL_W32(tp, RxConfig, RTL_R32(tp, RxConfig) |
 			AcceptBroadcast | AcceptMulticast | AcceptMyPhys);
 
@@ -5334,6 +5348,11 @@ static int rtl_init_one(struct pci_dev *
 
 	tp->irq = pci_irq_vector(pdev, 0);
 
+#ifdef CONFIG_IGEL_FIX_R8169_WOL
+	/* IGEL change: set WOL to zero first */
+	__rtl8169_set_wol(tp, 0);
+#endif
+
 	INIT_WORK(&tp->wk.work, rtl_task);
 
 	rtl_init_mac_address(tp);
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/ath/ath10k/core.c b/linux-6.6.38.igel/drivers/net/wireless/ath/ath10k/core.c
--- a/linux-6.6.38.igel/drivers/net/wireless/ath/ath10k/core.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/ath/ath10k/core.c	2024-08-02 15:41:31.555491585 +0200
@@ -38,6 +38,11 @@ static bool fw_diag_log;
 /* frame mode values are mapped as per enum ath10k_hw_txrx_mode */
 unsigned int ath10k_frame_mode = ATH10K_HW_TXRX_NATIVE_WIFI;
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+static char *override_board = "";
+static char *override_board2 = "";
+#endif
+
 unsigned long ath10k_coredump_mask = BIT(ATH10K_FW_CRASH_DUMP_REGISTERS) |
 				     BIT(ATH10K_FW_CRASH_DUMP_CE_DATA);
 
@@ -50,6 +55,11 @@ module_param(fw_diag_log, bool, 0644);
 module_param_named(frame_mode, ath10k_frame_mode, uint, 0644);
 module_param_named(coredump_mask, ath10k_coredump_mask, ulong, 0444);
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+module_param(override_board, charp, 0644);
+module_param(override_board2, charp, 0644);
+#endif
+
 MODULE_PARM_DESC(debug_mask, "Debugging mask");
 MODULE_PARM_DESC(uart_print, "Uart target debugging");
 MODULE_PARM_DESC(skip_otp, "Skip otp failure for calibration in testmode");
@@ -59,6 +69,11 @@ MODULE_PARM_DESC(frame_mode,
 MODULE_PARM_DESC(coredump_mask, "Bitfield of what to include in firmware crash file");
 MODULE_PARM_DESC(fw_diag_log, "Diag based fw log debugging");
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+MODULE_PARM_DESC(override_board, "Override for board.bin file");
+MODULE_PARM_DESC(override_board2, "Override for board-2.bin file");
+#endif
+
 static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 	{
 		.id = QCA988X_HW_2_0_VERSION,
@@ -914,6 +929,44 @@ static int ath10k_init_configure_target(
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+static const char *ath10k_override_board_fw_file(struct ath10k *ar,
+						 const char *file)
+{
+	if (strcmp(file, "board.bin") == 0) {
+		if (strcmp(override_board, "") == 0)
+			return file;
+
+		if (strcmp(override_board, "none") == 0) {
+			dev_info(ar->dev, "firmware override: pretending 'board.bin' does not exist\n");
+			return NULL;
+		}
+
+		dev_info(ar->dev, "firmware override: replacing 'board.bin' with '%s'\n",
+			 override_board);
+
+		return override_board;
+	}
+
+	if (strcmp(file, "board-2.bin") == 0) {
+		if (strcmp(override_board2, "") == 0)
+			return file;
+
+		if (strcmp(override_board2, "none") == 0) {
+			dev_info(ar->dev, "firmware override: pretending 'board-2.bin' does not exist\n");
+			return NULL;
+		}
+
+		dev_info(ar->dev, "firmware override: replacing 'board-2.bin' with '%s'\n",
+			 override_board2);
+
+		return override_board2;
+	}
+
+	return file;
+}
+#endif
+
 static const struct firmware *ath10k_fetch_fw_file(struct ath10k *ar,
 						   const char *dir,
 						   const char *file)
@@ -928,6 +981,21 @@ static const struct firmware *ath10k_fet
 	if (dir == NULL)
 		dir = ".";
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	/* HACK: Override board.bin and board-2.bin files if specified.
+	 *
+	 * Some Surface devices perform better with a different board
+	 * configuration. To this end, one would need to replace the board.bin
+	 * file with the modified config and remove the board-2.bin file.
+	 * Unfortunately, that's not a solution that we can easily package. So
+	 * we add module options to perform these overrides here.
+	 */
+
+	file = ath10k_override_board_fw_file(ar, file);
+	if (!file)
+		return ERR_PTR(-ENOENT);
+#endif
+
 	snprintf(filename, sizeof(filename), "%s/%s", dir, file);
 	ret = firmware_request_nowarn(&fw, filename, ar->dev);
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, "boot fw request '%s': %d\n",
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/settings.h b/linux-6.6.38.igel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/settings.h
--- a/linux-6.6.38.igel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/settings.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/net/wireless/broadcom/brcm80211/brcmfmac/settings.h	2024-08-02 15:41:31.555491585 +0200
@@ -0,0 +1,47 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (c) 2014 Broadcom Corporation
+ */
+
+#ifndef BRCMFMAC_SETTINGS_H
+#define BRCMFMAC_SETTINGS_H
+
+#include <linux/platform_data/brcmfmac.h>
+
+/* Definition for the device specific settings are defined here. One struct
+ * is used called brcmf_mp_device. The device specific settings is part of
+ * the drvr struct and should be initialized on every brcmf_attach.
+ */
+
+/**
+ * struct brcmf_mp_device - Device module paramaters.
+ *
+ * @p2p_enable: Legacy P2P0 enable (old wpa_supplicant).
+ * @feature_disable: Feature_disable bitmask.
+ * @fcmode: FWS flow control.
+ * @roamoff: Firmware roaming off?
+ * @ignore_probe_fail: Ignore probe failure.
+ * @trivial_ccode_map: Assume firmware uses ISO3166 country codes with rev 0
+ * @country_codes: If available, pointer to struct for translating country codes
+ * @bus: Bus specific platform data. Only SDIO at the mmoment.
+ * @rambase_addr: Manually specified FW shared rambase address.
+ */
+struct brcmf_mp_device {
+	bool		p2p_enable;
+	unsigned int	feature_disable;
+	int		fcmode;
+	bool		roamoff;
+	bool		iapp;
+	bool		ignore_probe_fail;
+	bool		trivial_ccode_map;
+	struct brcmfmac_pd_cc *country_codes;
+	const char	*board_type;
+	unsigned char	mac[ETH_ALEN];
+	const char	*antenna_sku;
+	union {
+		struct brcmfmac_sdio_pd sdio;
+	} bus;
+	u32		rambase_addr;
+};
+
+#endif /* BRCMFMAC_SETTINGS_H */
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie.c b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie.c
--- a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie.c	2024-08-02 15:41:31.555491585 +0200
@@ -370,6 +370,9 @@ static int mwifiex_pcie_probe(struct pci
 					const struct pci_device_id *ent)
 {
 	struct pcie_service_card *card;
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
+#endif
 	int ret;
 
 	pr_debug("info: vendor=0x%4.04X device=0x%4.04X rev=%d\n",
@@ -411,6 +414,14 @@ static int mwifiex_pcie_probe(struct pci
 		return -1;
 	}
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	/* disable bridge_d3 for Surface gen4+ devices to fix fw crashing
+	 * after suspend
+	 */
+	if (card->quirks & QUIRK_NO_BRIDGE_D3)
+		parent_pdev->bridge_d3 = false;
+#endif
+
 	return 0;
 }
 
@@ -1771,9 +1782,25 @@ mwifiex_pcie_send_boot_cmd(struct mwifie
 static int mwifiex_pcie_init_fw_port(struct mwifiex_adapter *adapter)
 {
 	struct pcie_service_card *card = adapter->card;
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	struct pci_dev *pdev = card->dev;
+	struct pci_dev *parent_pdev = pci_upstream_bridge(pdev);
+#endif
 	const struct mwifiex_pcie_card_reg *reg = card->pcie.reg;
 	int tx_wrap = card->txbd_wrptr & reg->tx_wrap_mask;
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	/* Trigger a function level reset of the PCI bridge device, this makes
+	 * the firmware of PCIe 88W8897 cards stop reporting a fixed LTR value
+	 * that prevents the system from entering package C10 and S0ix powersaving
+	 * states.
+	 * We need to do it here because it must happen after firmware
+	 * initialization and this function is called after that is done.
+	 */
+	if (card->quirks & QUIRK_DO_FLR_ON_BRIDGE)
+		pci_reset_function(parent_pdev);
+#endif
+
 	/* Write the RX ring read pointer in to reg->rx_rdptr */
 	if (mwifiex_write_reg(adapter, reg->rx_rdptr, card->rxbd_rdptr |
 			      tx_wrap)) {
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c
--- a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.c	2024-08-02 15:41:31.555491585 +0200
@@ -13,7 +13,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 4"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Pro 5",
@@ -22,7 +28,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1796"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Pro 5 (LTE)",
@@ -31,7 +43,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_SKU, "Surface_Pro_1807"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Pro 6",
@@ -39,7 +57,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Pro 6"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Book 1",
@@ -47,7 +71,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Book 2",
@@ -55,7 +85,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Book 2"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Laptop 1",
@@ -63,7 +99,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{
 		.ident = "Surface Laptop 2",
@@ -71,7 +113,13 @@ static const struct dmi_system_id mwifie
 			DMI_EXACT_MATCH(DMI_SYS_VENDOR, "Microsoft Corporation"),
 			DMI_EXACT_MATCH(DMI_PRODUCT_NAME, "Surface Laptop 2"),
 		},
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+		.driver_data = (void *)(QUIRK_FW_RST_D3COLD |
+					QUIRK_NO_BRIDGE_D3 |
+					QUIRK_DO_FLR_ON_BRIDGE),
+#else
 		.driver_data = (void *)QUIRK_FW_RST_D3COLD,
+#endif
 	},
 	{}
 };
@@ -89,6 +137,13 @@ void mwifiex_initialize_quirks(struct pc
 		dev_info(&pdev->dev, "no quirks enabled\n");
 	if (card->quirks & QUIRK_FW_RST_D3COLD)
 		dev_info(&pdev->dev, "quirk reset_d3cold enabled\n");
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+	if (card->quirks & QUIRK_DO_FLR_ON_BRIDGE)
+		dev_info(&pdev->dev, "quirk do_flr_on_bridge enabled\n");
+	if (card->quirks & QUIRK_NO_BRIDGE_D3)
+		dev_info(&pdev->dev,
+			 "quirk no_brigde_d3 enabled\n");
+#endif
 }
 
 static void mwifiex_pcie_set_power_d3cold(struct pci_dev *pdev)
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h
--- a/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/marvell/mwifiex/pcie_quirks.h	2024-08-02 15:41:31.555491585 +0200
@@ -5,5 +5,10 @@
 
 #define QUIRK_FW_RST_D3COLD	BIT(0)
 
+#ifdef CONFIG_IGEL_SURFACE_WLAN_IMPROVEMENTS
+#define QUIRK_DO_FLR_ON_BRIDGE	BIT(1)
+#define QUIRK_NO_BRIDGE_D3	BIT(2)
+#endif
+
 void mwifiex_initialize_quirks(struct pcie_service_card *card);
 int mwifiex_pcie_reset_d3cold_quirk(struct pci_dev *pdev);
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
--- a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.c	2024-08-02 15:41:31.555491585 +0200
@@ -5348,8 +5348,14 @@ static void rt2800_config_txpower_rt28xx
 	 * maximum tx power. For other devices we take user power_level into
 	 * consideration on rt2800_compensate_txpower().
 	 */
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com fix for control tx power */
+	delta += rt2800_get_txpower_reg_delta(rt2x00dev, power_level,
+					      chan->max_reg_power);
+#else
 	delta += rt2800_get_txpower_reg_delta(rt2x00dev, power_level,
 					      chan->max_power);
+#endif
 
 	/*
 	 * BBP_R1 controls TX power for all rates, it allow to set the following
@@ -5365,6 +5371,12 @@ static void rt2800_config_txpower_rt28xx
 	} else if (delta <= -6) {
 		power_ctrl = 1;
 		delta += 6;
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com fix for control tx power */
+	} else if (delta > 0) {
+		power_ctrl = 3;
+		delta -= 6;
+#endif
 	} else {
 		power_ctrl = 0;
 	}
@@ -6030,7 +6042,16 @@ static int rt2800_init_registers(struct
 	rt2800_register_write(rt2x00dev, TX_TIMEOUT_CFG, reg);
 
 	reg = rt2800_register_read(rt2x00dev, MAX_LEN_CFG);
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com fix for frame aggregation with one antenna */
+	if (rt2x00dev->default_ant.tx_chain_num < 2) {
+		rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_MPDU, DATA_FRAME_SIZE);
+	} else {
+		rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_MPDU, AGGREGATION_SIZE);
+	}
+#else
 	rt2x00_set_field32(&reg, MAX_LEN_CFG_MAX_MPDU, AGGREGATION_SIZE);
+#endif
 	if (rt2x00_is_usb(rt2x00dev)) {
 		drv_data->max_psdu = 3;
 	} else if (rt2x00_rt_rev_gte(rt2x00dev, RT2872, REV_RT2872E) ||
@@ -11016,6 +11037,9 @@ static int rt2800_init_eeprom(struct rt2
 	u16 value;
 	u16 eeprom;
 	u16 rf;
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	int n;
+#endif
 
 	/*
 	 * Read EEPROM word for configuration.
@@ -11080,10 +11104,24 @@ static int rt2800_init_eeprom(struct rt2
 	/*
 	 * Identify default antenna configuration.
 	 */
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com adapted for using with one antenna */
+	if ((n = rt2800_get_chain_number(rt2x00dev)) > 0) {
+		/* set chain number from the module parameter */
+		rt2x00dev->default_ant.tx_chain_num = n;
+		rt2x00dev->default_ant.rx_chain_num = n;
+	} else {
+		rt2x00dev->default_ant.tx_chain_num =
+		    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH);
+		rt2x00dev->default_ant.rx_chain_num =
+		    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH);
+	}
+#else
 	rt2x00dev->default_ant.tx_chain_num =
 	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_TXPATH);
 	rt2x00dev->default_ant.rx_chain_num =
 	    rt2x00_get_field16(eeprom, EEPROM_NIC_CONF0_RXPATH);
+#endif
 
 	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF1);
 
@@ -11593,7 +11631,13 @@ static int rt2800_probe_hw_mode(struct r
 	 * Initialize all hw fields.
 	 */
 	ieee80211_hw_set(rt2x00dev->hw, REPORTS_TX_ACK_STATUS);
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com fix for AMPDU with one antenna */
+	if (rt2x00dev->default_ant.tx_chain_num > 1)
+		ieee80211_hw_set(rt2x00dev->hw, AMPDU_AGGREGATION);
+#else
 	ieee80211_hw_set(rt2x00dev->hw, AMPDU_AGGREGATION);
+#endif
 	ieee80211_hw_set(rt2x00dev->hw, PS_NULLFUNC_STACK);
 	ieee80211_hw_set(rt2x00dev->hw, SIGNAL_DBM);
 	ieee80211_hw_set(rt2x00dev->hw, SUPPORTS_PS);
@@ -11706,10 +11750,24 @@ static int rt2800_probe_hw_mode(struct r
 	/*
 	 * Initialize HT information.
 	 */
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com adapted for using with one antenna */
+	if (!rt2x00_rf(rt2x00dev, RF2020)) {
+		if (rt2800_ht_disabled(rt2x00dev)) {
+			spec->ht.ht_supported = false;
+			rt2x00_info(rt2x00dev, "HT is disabled.\n");
+		} else {
+			spec->ht.ht_supported = true;
+		}
+	} else {
+		spec->ht.ht_supported = false;
+	}
+#else
 	if (!rt2x00_rf(rt2x00dev, RF2020))
 		spec->ht.ht_supported = true;
 	else
 		spec->ht.ht_supported = false;
+#endif
 
 	spec->ht.cap =
 	    IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.h b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
--- a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800lib.h	2024-08-02 15:41:31.555491585 +0200
@@ -76,6 +76,12 @@ struct rt2800_ops {
 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
 	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
+
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com adapted for using with one antenna */
+	bool (*ht_disabled)(struct rt2x00_dev *rt2x00dev);
+	int (*get_chain_number)(struct rt2x00_dev *rt2x00dev);
+#endif
 };
 
 static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
@@ -155,6 +161,30 @@ static inline bool rt2800_hwcrypt_disabl
 	return rt2800ops->hwcrypt_disabled(rt2x00dev);
 }
 
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+/* hamburg@igel.com adapted for using with one antenna */
+
+static inline bool rt2800_ht_disabled(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+	if (NULL == rt2800ops->ht_disabled) {
+		return false;
+	}
+	return rt2800ops->ht_disabled(rt2x00dev);
+}
+
+/* hamburg@igel.com adapted for using with one antenna */
+
+static inline int rt2800_get_chain_number(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+	if (NULL == rt2800ops->get_chain_number) {
+		return -1;
+	}
+	return rt2800ops->get_chain_number(rt2x00dev);
+}
+#endif
+
 static inline int rt2800_drv_write_firmware(struct rt2x00_dev *rt2x00dev,
 					    const u8 *data, const size_t len)
 {
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800usb.c b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
--- a/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800usb.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/ralink/rt2x00/rt2800usb.c	2024-08-02 15:41:31.555491585 +0200
@@ -40,6 +40,29 @@ static bool rt2800usb_hwcrypt_disabled(s
 	return modparam_nohwcrypt;
 }
 
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+/* hamburg@igel.com adapted for using with one antenna */
+
+static bool modparam_noht;
+module_param_named(noht, modparam_noht, bool, S_IRUGO);
+MODULE_PARM_DESC(noht, "Disable HT capabilities.");
+
+static bool rt2800usb_ht_disabled(struct rt2x00_dev *rt2x00dev)
+{
+	return modparam_noht;
+}
+
+/* hamburg@igel.com adapted for using with one antenna */
+
+static int modparam_chain_num = -1;
+module_param_named(chain_num, modparam_chain_num, int, S_IRUGO);
+MODULE_PARM_DESC(chain_num, "Set RX/TX chain number.");
+
+static int rt2800usb_modparam_chain_num(struct rt2x00_dev *rt2x00dev)
+{
+	return modparam_chain_num;
+}
+#endif
 /*
  * Queue handlers.
  */
@@ -672,6 +695,11 @@ static const struct rt2800_ops rt2800usb
 	.drv_init_registers	= rt2800usb_init_registers,
 	.drv_get_txwi		= rt2800usb_get_txwi,
 	.drv_get_dma_done	= rt2800usb_get_dma_done,
+#ifdef CONFIG_IGEL_RALINK_ONE_ANTENNA_QUIRK
+	/* hamburg@igel.com adapted for using with one antenna */
+	.ht_disabled		= rt2800usb_ht_disabled,
+	.get_chain_number	= rt2800usb_modparam_chain_num,
+#endif
 };
 
 static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff -Naurp a/linux-6.6.38.igel/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c b/linux-6.6.38.igel/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c
--- a/linux-6.6.38.igel/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c	2024-08-02 15:41:31.555491585 +0200
@@ -7725,6 +7725,7 @@ static const struct usb_device_id dev_ta
 	.driver_info = (unsigned long)&rtl8723au_fops},
 {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x0724, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8723au_fops},
+#ifndef CONFIG_IGEL_DISABLE_RTL8XXXU_USB_IDS_HANDLED_BY_8192EU
 {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0x818b, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8192eu_fops},
 /* TP-Link TL-WN822N v4 */
@@ -7736,6 +7737,7 @@ static const struct usb_device_id dev_ta
 /* Tested by Myckel Habets */
 {USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0109, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8192eu_fops},
+#endif
 {USB_DEVICE_AND_INTERFACE_INFO(USB_VENDOR_ID_REALTEK, 0xb720, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8723bu_fops},
 {USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0xa611, 0xff, 0xff, 0xff),
@@ -7952,6 +7954,7 @@ static const struct usb_device_id dev_ta
 {USB_DEVICE_AND_INTERFACE_INFO(0x7392, 0x7822, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8192cu_fops},
 /* found in rtl8192eu vendor driver */
+#ifndef CONFIG_IGEL_DISABLE_RTL8XXXU_USB_IDS_HANDLED_BY_8192EU
 {USB_DEVICE_AND_INTERFACE_INFO(0x2357, 0x0107, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8192eu_fops},
 {USB_DEVICE_AND_INTERFACE_INFO(0x2019, 0xab33, 0xff, 0xff, 0xff),
@@ -7971,6 +7974,7 @@ static const struct usb_device_id dev_ta
 {USB_DEVICE_AND_INTERFACE_INFO(0x2c4e, 0x0104, 0xff, 0xff, 0xff),
 	.driver_info = (unsigned long)&rtl8192eu_fops},
 #endif
+#endif
 { }
 };
 
diff -Naurp a/linux-6.6.38.igel/drivers/pci/pci.c b/linux-6.6.38.igel/drivers/pci/pci.c
--- a/linux-6.6.38.igel/drivers/pci/pci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/pci/pci.c	2024-08-02 15:41:31.559491681 +0200
@@ -3045,6 +3045,20 @@ static const struct dmi_system_id bridge
 			DMI_MATCH(DMI_BOARD_VERSION, "Continental Z2"),
 		},
 	},
+#ifdef CONFIG_IGEL_FIX_ELO_I2_WIFI_ISSUE
+	{
+		/*
+		* Downstream device is not accessible after putting a root port
+		* into D3cold and back into D0 on Elo i2.
+		*/
+		.ident = "Elo i2",
+		.matches = {
+			DMI_MATCH(DMI_SYS_VENDOR, "Elo Touch Solutions"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "Elo i2"),
+			DMI_MATCH(DMI_PRODUCT_VERSION, "RevB"),
+		},
+	},
+#endif
 	{
 		/*
 		 * Changing power state of root port dGPU is connected fails
diff -Naurp a/linux-6.6.38.igel/drivers/pci/pcie/aer.c b/linux-6.6.38.igel/drivers/pci/pcie/aer.c
--- a/linux-6.6.38.igel/drivers/pci/pcie/aer.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/pci/pcie/aer.c	2024-08-02 15:41:31.559491681 +0200
@@ -107,7 +107,15 @@ struct aer_stats {
 					PCI_ERR_ROOT_MULTI_COR_RCV |	\
 					PCI_ERR_ROOT_MULTI_UNCOR_RCV)
 
+/* gottwald@igel.com disable PCI advanced error reporting because it is spaming
+ * the syslog with unnecessary messages see also
+ * http://marc.info/?l=linux-pci&m=145140470807043
+ * for details */
+#ifdef CONFIG_IGEL_PCIEAER_DISABLE
+static int pcie_aer_disable = 1;
+#else
 static int pcie_aer_disable;
+#endif
 static pci_ers_result_t aer_root_reset(struct pci_dev *dev);
 
 void pci_no_aer(void)
diff -Naurp a/linux-6.6.38.igel/drivers/pci/vgaarb.c b/linux-6.6.38.igel/drivers/pci/vgaarb.c
--- a/linux-6.6.38.igel/drivers/pci/vgaarb.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/pci/vgaarb.c	2024-08-02 15:41:31.559491681 +0200
@@ -143,6 +143,9 @@ void vga_set_default_device(struct pci_d
 	pci_dev_put(vga_default);
 	vga_default = pci_dev_get(pdev);
 }
+#ifdef CONFIG_IGEL_APPLE_GMUX
+EXPORT_SYMBOL_GPL(vga_set_default_device);
+#endif
 
 /**
  * vga_remove_vgacon - deactivate VGA console
diff -Naurp a/linux-6.6.38.igel/drivers/pinctrl/intel/pinctrl-intel.c b/linux-6.6.38.igel/drivers/pinctrl/intel/pinctrl-intel.c
--- a/linux-6.6.38.igel/drivers/pinctrl/intel/pinctrl-intel.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/pinctrl/intel/pinctrl-intel.c	2024-08-02 15:41:31.559491681 +0200
@@ -1692,14 +1692,22 @@ const struct intel_pinctrl_soc_data *int
 	if (table) {
 		struct acpi_device *adev = ACPI_COMPANION(dev);
 		unsigned int i;
-
-		for (i = 0; table[i]; i++) {
-			if (!strcmp(adev->pnp.unique_id, table[i]->uid)) {
-				data = table[i];
-				break;
+		/* gottwald@igel.com : Workaround for intel Elkhardt platform do not remove */
+		if (adev && adev->pnp.unique_id) {
+			for (i = 0; table[i]; i++) {
+				if (!table[i]->uid) {
+					printk(KERN_ERR "intel_pinctrl_get_soc_data: table[%d]->uid is NULL\n", i);
+				} else if (!strcmp(adev->pnp.unique_id, table[i]->uid)) {
+					data = table[i];
+					break;
+				}
 			}
+		} else {
+			printk(KERN_ERR "intel_pinctrl_get_soc_data: adev->pnp.unique_id is NULL\n");
+			table = NULL;
 		}
-	} else {
+	}
+	if (!table) {
 		const struct platform_device_id *id;
 
 		id = platform_get_device_id(pdev);
diff -Naurp a/linux-6.6.38.igel/drivers/platform/surface/Makefile b/linux-6.6.38.igel/drivers/platform/surface/Makefile
--- a/linux-6.6.38.igel/drivers/platform/surface/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/surface/Makefile	2024-08-02 15:41:31.559491681 +0200
@@ -12,6 +12,7 @@ obj-$(CONFIG_SURFACE_AGGREGATOR_CDEV)	+=
 obj-$(CONFIG_SURFACE_AGGREGATOR_HUB)	+= surface_aggregator_hub.o
 obj-$(CONFIG_SURFACE_AGGREGATOR_REGISTRY) += surface_aggregator_registry.o
 obj-$(CONFIG_SURFACE_AGGREGATOR_TABLET_SWITCH) += surface_aggregator_tabletsw.o
+obj-$(CONFIG_IGEL_SURFACE_BOOK1_DGPU_SWITCH) += surfacebook1_dgpu_switch.o
 obj-$(CONFIG_SURFACE_DTX)		+= surface_dtx.o
 obj-$(CONFIG_SURFACE_GPE)		+= surface_gpe.o
 obj-$(CONFIG_SURFACE_HOTPLUG)		+= surface_hotplug.o
diff -Naurp a/linux-6.6.38.igel/drivers/platform/surface/surface3-wmi.c b/linux-6.6.38.igel/drivers/platform/surface/surface3-wmi.c
--- a/linux-6.6.38.igel/drivers/platform/surface/surface3-wmi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/surface/surface3-wmi.c	2024-08-02 15:41:31.559491681 +0200
@@ -37,6 +37,15 @@ static const struct dmi_system_id surfac
 			DMI_MATCH(DMI_PRODUCT_NAME, "Surface 3"),
 		},
 	},
+#ifdef CONFIG_IGEL_SURFACE_SURFACE3_OEMB_FIX
+	{
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+	},
+#endif /* CONFIG_IGEL_SURFACE_SURFACE3_OEMB_FIX */
 #endif
 	{ }
 };
diff -Naurp a/linux-6.6.38.igel/drivers/platform/surface/surfacebook1_dgpu_switch.c b/linux-6.6.38.igel/drivers/platform/surface/surfacebook1_dgpu_switch.c
--- a/linux-6.6.38.igel/drivers/platform/surface/surfacebook1_dgpu_switch.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/drivers/platform/surface/surfacebook1_dgpu_switch.c	2024-08-02 15:41:31.559491681 +0200
@@ -0,0 +1,162 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <linux/platform_device.h>
+
+
+#ifdef pr_fmt
+#undef pr_fmt
+#endif
+#define pr_fmt(fmt) "%s:%s: " fmt, KBUILD_MODNAME, __func__
+
+
+static const guid_t dgpu_sw_guid = GUID_INIT(0x6fd05c69, 0xcde3, 0x49f4,
+	0x95, 0xed, 0xab, 0x16, 0x65, 0x49, 0x80, 0x35);
+
+#define DGPUSW_ACPI_PATH_DSM	"\\_SB_.PCI0.LPCB.EC0_.VGBI"
+#define DGPUSW_ACPI_PATH_HGON	"\\_SB_.PCI0.RP05.HGON"
+#define DGPUSW_ACPI_PATH_HGOF	"\\_SB_.PCI0.RP05.HGOF"
+
+
+static int sb1_dgpu_sw_dsmcall(void)
+{
+	union acpi_object *ret;
+	acpi_handle handle;
+	acpi_status status;
+
+	status = acpi_get_handle(NULL, DGPUSW_ACPI_PATH_DSM, &handle);
+	if (status)
+		return -EINVAL;
+
+	ret = acpi_evaluate_dsm_typed(handle, &dgpu_sw_guid, 1, 1, NULL, ACPI_TYPE_BUFFER);
+	if (!ret)
+		return -EINVAL;
+
+	ACPI_FREE(ret);
+	return 0;
+}
+
+static int sb1_dgpu_sw_hgon(void)
+{
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+
+	status = acpi_evaluate_object(NULL, DGPUSW_ACPI_PATH_HGON, NULL, &buf);
+	if (status) {
+		pr_err("failed to run HGON: %d\n", status);
+		return -EINVAL;
+	}
+
+	if (buf.pointer)
+		ACPI_FREE(buf.pointer);
+
+	pr_info("turned-on dGPU via HGON\n");
+	return 0;
+}
+
+static int sb1_dgpu_sw_hgof(void)
+{
+	struct acpi_buffer buf = {ACPI_ALLOCATE_BUFFER, NULL};
+	acpi_status status;
+
+	status = acpi_evaluate_object(NULL, DGPUSW_ACPI_PATH_HGOF, NULL, &buf);
+	if (status) {
+		pr_err("failed to run HGOF: %d\n", status);
+		return -EINVAL;
+	}
+
+	if (buf.pointer)
+		ACPI_FREE(buf.pointer);
+
+	pr_info("turned-off dGPU via HGOF\n");
+	return 0;
+}
+
+
+static ssize_t dgpu_dsmcall_store(struct device *dev, struct device_attribute *attr,
+				  const char *buf, size_t len)
+{
+	int status, value;
+
+	status = kstrtoint(buf, 0, &value);
+	if (status < 0)
+		return status;
+
+	if (value != 1)
+		return -EINVAL;
+
+	status = sb1_dgpu_sw_dsmcall();
+
+	return status < 0 ? status : len;
+}
+
+static ssize_t dgpu_power_store(struct device *dev, struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	bool power;
+	int status;
+
+	status = kstrtobool(buf, &power);
+	if (status < 0)
+		return status;
+
+	if (power)
+		status = sb1_dgpu_sw_hgon();
+	else
+		status = sb1_dgpu_sw_hgof();
+
+	return status < 0 ? status : len;
+}
+
+static DEVICE_ATTR_WO(dgpu_dsmcall);
+static DEVICE_ATTR_WO(dgpu_power);
+
+static struct attribute *sb1_dgpu_sw_attrs[] = {
+	&dev_attr_dgpu_dsmcall.attr,
+	&dev_attr_dgpu_power.attr,
+	NULL,
+};
+
+static const struct attribute_group sb1_dgpu_sw_attr_group = {
+	.attrs = sb1_dgpu_sw_attrs,
+};
+
+
+static int sb1_dgpu_sw_probe(struct platform_device *pdev)
+{
+	return sysfs_create_group(&pdev->dev.kobj, &sb1_dgpu_sw_attr_group);
+}
+
+static int sb1_dgpu_sw_remove(struct platform_device *pdev)
+{
+	sysfs_remove_group(&pdev->dev.kobj, &sb1_dgpu_sw_attr_group);
+	return 0;
+}
+
+/*
+ * The dGPU power seems to be actually handled by MSHW0040. However, that is
+ * also the power-/volume-button device with a mainline driver. So let's use
+ * MSHW0041 instead for now, which seems to be the LTCH (latch/DTX) device.
+ */
+static const struct acpi_device_id sb1_dgpu_sw_match[] = {
+	{ "MSHW0041", },
+	{ },
+};
+MODULE_DEVICE_TABLE(acpi, sb1_dgpu_sw_match);
+
+static struct platform_driver sb1_dgpu_sw = {
+	.probe = sb1_dgpu_sw_probe,
+	.remove = sb1_dgpu_sw_remove,
+	.driver = {
+		.name = "surfacebook1_dgpu_switch",
+		.acpi_match_table = sb1_dgpu_sw_match,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
+	},
+};
+module_platform_driver(sb1_dgpu_sw);
+
+MODULE_AUTHOR("Maximilian Luz <luzmaximilian@gmail.com>");
+MODULE_DESCRIPTION("Discrete GPU Power-Switch for Surface Book 1");
+MODULE_LICENSE("GPL");
diff -Naurp a/linux-6.6.38.igel/drivers/platform/surface/surfacepro3_button.c b/linux-6.6.38.igel/drivers/platform/surface/surfacepro3_button.c
--- a/linux-6.6.38.igel/drivers/platform/surface/surfacepro3_button.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/surface/surfacepro3_button.c	2024-08-02 15:41:31.559491681 +0200
@@ -146,6 +146,26 @@ static int surface_button_resume(struct
 }
 #endif
 
+#ifdef CONFIG_IGEL_SURFACE_BUTTON_CHANGES
+/*
+ * Surface Pro 4 and Surface Book 2 / Surface Pro 2017 use the same device
+ * ID (MSHW0040) for the power/volume buttons. Make sure this is the right
+ * device by checking for the _DSM method and OEM Platform Revision DSM
+ * function.
+ *
+ * Returns true if the driver should bind to this device, i.e. the device is
+ * either MSWH0028 (Pro 3) or MSHW0040 on a Pro 4 or Book 1.
+ */
+static bool surface_button_check_MSHW0040(struct acpi_device *dev)
+{
+	acpi_handle handle = dev->handle;
+
+	// make sure that OEM platform revision DSM call does not exist
+	return !acpi_check_dsm(handle, &MSHW0040_DSM_UUID,
+			       MSHW0040_DSM_REVISION,
+			       BIT(MSHW0040_DSM_GET_OMPR));
+}
+#else
 /*
  * Surface Pro 4 and Surface Book 2 / Surface Pro 2017 use the same device
  * ID (MSHW0040) for the power/volume buttons. Make sure this is the right
@@ -182,7 +202,7 @@ static bool surface_button_check_MSHW004
 
 	return oem_platform_rev == 0;
 }
-
+#endif
 
 static int surface_button_add(struct acpi_device *device)
 {
diff -Naurp a/linux-6.6.38.igel/drivers/platform/x86/apple-gmux.c b/linux-6.6.38.igel/drivers/platform/x86/apple-gmux.c
--- a/linux-6.6.38.igel/drivers/platform/x86/apple-gmux.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/x86/apple-gmux.c	2024-08-02 15:41:31.559491681 +0200
@@ -21,6 +21,9 @@
 #include <linux/delay.h>
 #include <linux/pci.h>
 #include <linux/vga_switcheroo.h>
+#ifdef CONFIG_IGEL_APPLE_GMUX
+#include <linux/vgaarb.h>
+#endif
 #include <linux/debugfs.h>
 #include <acpi/video.h>
 #include <asm/io.h>
@@ -91,6 +94,9 @@ struct apple_gmux_config {
 	enum vga_switcheroo_handler_flags_t handler_flags;
 	unsigned long resource_type;
 	bool read_version_as_u32;
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	bool use_acpi_gmsp;
+#endif
 	char *name;
 };
 
@@ -107,6 +113,12 @@ struct apple_gmux_config {
 
 # define MMIO_GMUX_MAX_BRIGHTNESS	0xffff
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+static bool force_igd;
+module_param(force_igd, bool, 0);
+MODULE_PARM_DESC(force_idg, "Switch gpu to igd on module load. Make sure that you have apple-set-os set up and the iGPU is in `lspci -s 00:02.0`. (default: false) (bool)");
+#endif
+
 static u8 gmux_pio_read8(struct apple_gmux_data *gmux_data, int port)
 {
 	return inb(gmux_data->iostart + port);
@@ -578,6 +590,9 @@ static const struct apple_gmux_config ap
 	.handler_flags = VGA_SWITCHEROO_CAN_SWITCH_DDC,
 	.resource_type = IORESOURCE_IO,
 	.read_version_as_u32 = false,
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	.use_acpi_gmsp = false,
+#endif
 	.name = "classic"
 };
 
@@ -590,6 +605,9 @@ static const struct apple_gmux_config ap
 	.handler_flags = VGA_SWITCHEROO_NEEDS_EDP_CONFIG,
 	.resource_type = IORESOURCE_IO,
 	.read_version_as_u32 = true,
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	.use_acpi_gmsp = false,
+#endif
 	.name = "indexed"
 };
 
@@ -602,6 +620,9 @@ static const struct apple_gmux_config ap
 	.handler_flags = VGA_SWITCHEROO_NEEDS_EDP_CONFIG,
 	.resource_type = IORESOURCE_MEM,
 	.read_version_as_u32 = true,
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	.use_acpi_gmsp = true,
+#endif
 	.name = "T2"
 };
 
@@ -631,6 +652,26 @@ static const struct apple_gmux_config ap
  * that can't be cleared. This issue seems to be unique to MMIO gmux's.
  */
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+static int gmux_call_acpi_gmsp(struct apple_gmux_data *gmux_data, int arg)
+{
+	acpi_status status = AE_OK;
+	union acpi_object arg0 = { ACPI_TYPE_INTEGER };
+	struct acpi_object_list arg_list = { 1, &arg0 };
+
+	arg0.integer.value = arg;
+
+	status = acpi_evaluate_object(gmux_data->dhandle, "GMSP", &arg_list, NULL);
+	if (ACPI_FAILURE(status)) {
+		pr_err("GMSP call failed: %s\n",
+		       acpi_format_exception(status));
+		return -ENODEV;
+	}
+
+	return 0;
+}
+#endif
+
 static inline void gmux_disable_interrupts(struct apple_gmux_data *gmux_data)
 {
 	gmux_write8(gmux_data, GMUX_PORT_INTERRUPT_ENABLE,
@@ -655,9 +696,14 @@ static void gmux_clear_interrupts(struct
 	/* to clear interrupts write back current status */
 	status = gmux_interrupt_get_status(gmux_data);
 	gmux_write8(gmux_data, GMUX_PORT_INTERRUPT_STATUS, status);
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	if (gmux_data->config->use_acpi_gmsp)
+		gmux_call_acpi_gmsp(gmux_data, 0);
+#else
 	/* Prevent flood of status=0 interrupts */
 	if (gmux_data->config == &apple_gmux_mmio)
 		acpi_execute_simple_method(gmux_data->dhandle, "GMSP", 0);
+#endif
 }
 
 static void gmux_notify_handler(acpi_handle device, u32 value, void *context)
@@ -695,6 +741,9 @@ static ssize_t gmux_selected_port_data_w
 		const char __user *userbuf, size_t count, loff_t *ppos)
 {
 	struct apple_gmux_data *gmux_data = file->private_data;
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	int ret;
+#endif
 
 	if (*ppos)
 		return -EINVAL;
@@ -702,15 +751,27 @@ static ssize_t gmux_selected_port_data_w
 	if (count == 1) {
 		u8 data;
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+		ret = copy_from_user(&data, userbuf, 1);
+		if (ret)
+			return ret;
+#else
 		if (copy_from_user(&data, userbuf, 1))
 			return -EFAULT;
+#endif
 
 		gmux_write8(gmux_data, gmux_data->selected_port, data);
 	} else if (count == 4) {
 		u32 data;
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+		ret = copy_from_user(&data, userbuf, 4);
+		if (ret)
+			return ret;
+#else
 		if (copy_from_user(&data, userbuf, 4))
 			return -EFAULT;
+#endif
 
 		gmux_write32(gmux_data, gmux_data->selected_port, data);
 	} else
@@ -945,6 +1006,21 @@ get_version:
 	gmux_enable_interrupts(gmux_data);
 	gmux_read_switch_state(gmux_data);
 
+#ifdef CONFIG_IGEL_APPLE_GMUX
+	if (force_igd) {
+		struct pci_dev *pdev;
+
+		pdev = pci_get_domain_bus_and_slot(0, 0, PCI_DEVFN(2, 0));
+		if (pdev) {
+			pr_info("Switching to IGD");
+			gmux_switchto(VGA_SWITCHEROO_IGD);
+			vga_set_default_device(pdev);
+		} else {
+			pr_err("force_idg is true, but couldn't find iGPU at 00:02.0! Is apple-set-os working?");
+		}
+	}
+#endif
+
 	/*
 	 * Retina MacBook Pros cannot switch the panel's AUX separately
 	 * and need eDP pre-calibration. They are distinguishable from
diff -Naurp a/linux-6.6.38.igel/drivers/platform/x86/hp/hp-wmi.c b/linux-6.6.38.igel/drivers/platform/x86/hp/hp-wmi.c
--- a/linux-6.6.38.igel/drivers/platform/x86/hp/hp-wmi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/x86/hp/hp-wmi.c	2024-08-02 15:41:31.559491681 +0200
@@ -1451,11 +1451,27 @@ static int hp_wmi_hwmon_init(void);
 static int __init hp_wmi_bios_setup(struct platform_device *device)
 {
 	int err;
+#ifdef CONFIG_IGEL_HP_RFKILL_MT645_G7_FIX
+        const char *vendor = NULL;
+        const char *name = NULL;
+	int no_rfkill = 0;
+#endif
+
 	/* clear detected rfkill devices */
 	wifi_rfkill = NULL;
 	bluetooth_rfkill = NULL;
 	wwan_rfkill = NULL;
 	rfkill2_count = 0;
+#ifdef CONFIG_IGEL_HP_RFKILL_MT645_G7_FIX
+        vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+        name = dmi_get_system_info(DMI_PRODUCT_NAME);
+
+        if (vendor != NULL && name != NULL) {
+                if (strstr(vendor, "HP") &&
+                    strstr(name, "mt645 G7")) {
+                        no_rfkill = 1;
+                }
+        }
 
 	/*
 	 * In pre-2009 BIOS, command 1Bh return 0x4 to indicate that
@@ -1463,10 +1479,22 @@ static int __init hp_wmi_bios_setup(stru
 	 * devices. All features supported by this command will no
 	 * longer be supported.
 	 */
+	if (!no_rfkill && !hp_wmi_bios_2009_later()) {
+		if (hp_wmi_rfkill_setup(device))
+			hp_wmi_rfkill2_setup(device);
+	}
+#else
+	/*
+	 * In pre-2009 BIOS, command 1Bh return 0x4 to indicate that
+	 * BIOS no longer controls the power for the wireless
+	 * devices. All features supported by this command will no
+	 * longer be supported.
+	 */
 	if (!hp_wmi_bios_2009_later()) {
 		if (hp_wmi_rfkill_setup(device))
 			hp_wmi_rfkill2_setup(device);
 	}
+#endif
 
 	err = hp_wmi_hwmon_init();
 
diff -Naurp a/linux-6.6.38.igel/drivers/platform/x86/ideapad-laptop.c b/linux-6.6.38.igel/drivers/platform/x86/ideapad-laptop.c
--- a/linux-6.6.38.igel/drivers/platform/x86/ideapad-laptop.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/x86/ideapad-laptop.c	2024-08-02 15:41:31.559491681 +0200
@@ -154,6 +154,18 @@ struct ideapad_private {
 	} kbd_bl;
 };
 
+#ifdef CONFIG_IGEL_ADD_HW_RFKILL_TO_IDEAPAD
+/* gottwald@igel.com Make it possible to disable hardware rfkill switch usage */
+
+static bool no_hw_rfkill;
+module_param(no_hw_rfkill, bool, 0444);
+MODULE_PARM_DESC(no_hw_rfkill, "Disable usage of hardware rfkill switch.");
+
+static bool hw_rfkill = 0;
+module_param(hw_rfkill, bool, 0444);
+MODULE_PARM_DESC(hw_rfkill, "Enable usage of hardware rfkill switch.");
+#endif
+
 static bool no_bt_rfkill;
 module_param(no_bt_rfkill, bool, 0444);
 MODULE_PARM_DESC(no_bt_rfkill, "No rfkill for bluetooth.");
@@ -1629,8 +1641,21 @@ static void ideapad_check_features(struc
 
 	priv->features.set_fn_lock_led =
 		set_fn_lock_led || dmi_check_system(set_fn_lock_led_list);
+#ifdef CONFIG_IGEL_ADD_HW_RFKILL_TO_IDEAPAD
+	/* gottwald@igel.com Make it possible to enable/disable hardware
+	 * rfkill switch usage with module parameter */
+	if (no_hw_rfkill) {
+		priv->features.hw_rfkill_switch = 0;
+	} else if (hw_rfkill) {
+		priv->features.hw_rfkill_switch = 1;
+	} else {
+		priv->features.hw_rfkill_switch =
+			hw_rfkill_switch || dmi_check_system(hw_rfkill_list);
+	}
+#else
 	priv->features.hw_rfkill_switch =
 		hw_rfkill_switch || dmi_check_system(hw_rfkill_list);
+#endif
 	priv->features.ctrl_ps2_aux_port =
 		ctrl_ps2_aux_port || dmi_check_system(ctrl_ps2_aux_port_list);
 	priv->features.touchpad_ctrl_via_ec = touchpad_ctrl_via_ec;
diff -Naurp a/linux-6.6.38.igel/drivers/platform/x86/intel/int3472/tps68470.c b/linux-6.6.38.igel/drivers/platform/x86/intel/int3472/tps68470.c
--- a/linux-6.6.38.igel/drivers/platform/x86/intel/int3472/tps68470.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/x86/intel/int3472/tps68470.c	2024-08-02 15:41:31.559491681 +0200
@@ -46,6 +46,15 @@ static int tps68470_chip_init(struct dev
 		return ret;
 	}
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	/* Enable I2C daisy chain */
+	ret = regmap_write(regmap, TPS68470_REG_S_I2C_CTL, 0x03);
+	if (ret) {
+		dev_err(dev, "Failed to enable i2c daisy chain\n");
+		return ret;
+	}
+#endif
+
 	dev_info(dev, "TPS68470 REVID: 0x%02x\n", version);
 
 	return 0;
diff -Naurp a/linux-6.6.38.igel/drivers/platform/x86/thinkpad_acpi.c b/linux-6.6.38.igel/drivers/platform/x86/thinkpad_acpi.c
--- a/linux-6.6.38.igel/drivers/platform/x86/thinkpad_acpi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/platform/x86/thinkpad_acpi.c	2024-08-02 15:41:31.559491681 +0200
@@ -413,6 +413,12 @@ static int dbg_uwbemul;
 static bool tpacpi_uwb_emulstate;
 #endif
 
+#ifdef CONFIG_IGEL_THINKPAD_RFKILL_MODULE_PARAM
+static bool wwan_rfkill = 1;
+static bool wlan_rfkill = 1;
+static bool bluetooth_rfkill = 1;
+#endif
+
 
 /*************************************************************************
  *  Debugging helpers
@@ -1937,6 +1943,10 @@ static int hotkey_get_wlsw(void)
 	if (!tp_features.hotkey_wlsw)
 		return -ENODEV;
 
+#ifdef CONFIG_IGEL_THINKPAD_RFKILL_MODULE_PARAM
+	if (!wlan_rfkill)
+		return TPACPI_RFK_RADIO_ON;
+#endif
 #ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES
 	if (dbg_wlswemul)
 		return (tpacpi_wlsw_emulstate) ?
@@ -4274,6 +4284,10 @@ static int bluetooth_get_status(void)
 {
 	int status;
 
+#ifdef CONFIG_IGEL_THINKPAD_RFKILL_MODULE_PARAM
+	if (!bluetooth_rfkill)
+		return TPACPI_RFK_RADIO_ON;
+#endif
 #ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES
 	if (dbg_bluetoothemul)
 		return (tpacpi_bluetooth_emulstate) ?
@@ -4528,7 +4542,27 @@ enum {
 static int wan_get_status(void)
 {
 	int status;
+#ifdef CONFIG_IGEL_FIX_WWAN_RFKILL_FOR_THINKPAD_L480
+	const char *vendor;
+	const char *version;
+#endif
+#ifdef CONFIG_IGEL_THINKPAD_RFKILL_MODULE_PARAM
+	if (!wwan_rfkill)
+		return TPACPI_RFK_RADIO_ON;
+#endif
 
+#ifdef CONFIG_IGEL_FIX_WWAN_RFKILL_FOR_THINKPAD_L480
+	/* gottwald@igel.com rfkill for wwan is invalid for Lenovo ThinkPad L480 */
+	vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+	version = dmi_get_system_info(DMI_PRODUCT_VERSION);
+
+	if (vendor != NULL && version != NULL) {
+		if (strstr(vendor, "LENOVO") &&
+                    strstr(version, "ThinkPad L480")) {
+			return TPACPI_RFK_RADIO_ON;
+		}
+	}
+#endif
 #ifdef CONFIG_THINKPAD_ACPI_DEBUGFACILITIES
 	if (dbg_wwanemul)
 		return (tpacpi_wwan_emulstate) ?
@@ -10862,6 +10896,93 @@ static struct ibm_struct dprc_driver_dat
 	.name = "dprc",
 };
 
+#ifdef CONFIG_IGEL_THINKPAD_MAC_PASSTHROUGH
+
+/*
+ * Auxmac
+ *
+ * This auxiliary mac address is enabled in the bios through the
+ * MAC Address Pass-through feature. In most cases, there are three
+ * possibilities: Internal Mac, Second Mac, and disabled.
+ *
+ */
+
+#define AUXMAC_LEN 12
+#define AUXMAC_START 9
+#define AUXMAC_STRLEN 22
+#define AUXMAC_BEGIN_MARKER 8
+#define AUXMAC_END_MARKER 21
+
+static char auxmac[AUXMAC_LEN + 1];
+
+static int auxmac_init(struct ibm_init_struct *iibm)
+{
+	acpi_status status;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *obj;
+
+	status = acpi_evaluate_object(NULL, "\\MACA", NULL, &buffer);
+
+	if (ACPI_FAILURE(status))
+		return -ENODEV;
+
+	obj = buffer.pointer;
+
+	if (obj->type != ACPI_TYPE_STRING || obj->string.length != AUXMAC_STRLEN) {
+		pr_info("Invalid buffer for MAC address pass-through.\n");
+		goto auxmacinvalid;
+	}
+
+	if (obj->string.pointer[AUXMAC_BEGIN_MARKER] != '#' ||
+	    obj->string.pointer[AUXMAC_END_MARKER] != '#') {
+		pr_info("Invalid header for MAC address pass-through.\n");
+		goto auxmacinvalid;
+	}
+
+	if (strncmp(obj->string.pointer + AUXMAC_START, "XXXXXXXXXXXX", AUXMAC_LEN) != 0)
+		strscpy(auxmac, obj->string.pointer + AUXMAC_START, sizeof(auxmac));
+	else
+		strscpy(auxmac, "disabled", sizeof(auxmac));
+
+free:
+	kfree(obj);
+	return 0;
+
+auxmacinvalid:
+	strscpy(auxmac, "unavailable", sizeof(auxmac));
+	goto free;
+}
+
+static struct ibm_struct auxmac_data = {
+	.name = "auxmac",
+};
+
+static ssize_t auxmac_show(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	return sysfs_emit(buf, "%s\n", auxmac);
+}
+static DEVICE_ATTR_RO(auxmac);
+
+static umode_t auxmac_attr_is_visible(struct kobject *kobj,
+				      struct attribute *attr, int n)
+{
+	return auxmac[0] == 0 ? 0 : attr->mode;
+}
+
+static struct attribute *auxmac_attributes[] = {
+	&dev_attr_auxmac.attr,
+	NULL
+};
+
+static const struct attribute_group auxmac_attr_group = {
+	.is_visible = auxmac_attr_is_visible,
+	.attrs = auxmac_attributes,
+};
+
+#endif // CONFIG_IGEL_THINKPAD_MAC_PASSTHROUGH
+
 /* --------------------------------------------------------------------- */
 
 static struct attribute *tpacpi_driver_attributes[] = {
@@ -10920,6 +11041,9 @@ static const struct attribute_group *tpa
 	&proxsensor_attr_group,
 	&kbdlang_attr_group,
 	&dprc_attr_group,
+#ifdef CONFIG_IGEL_THINKPAD_MAC_PASSTHROUGH
+	&auxmac_attr_group,
+#endif
 	NULL,
 };
 
@@ -11491,6 +11615,12 @@ static struct ibm_init_struct ibms_init[
 		.init = tpacpi_dprc_init,
 		.data = &dprc_driver_data,
 	},
+#ifdef CONFIG_IGEL_THINKPAD_MAC_PASSTHROUGH
+	{
+		.init = auxmac_init,
+		.data = &auxmac_data,
+	},
+#endif
 };
 
 static int __init set_ibm_param(const char *val, const struct kernel_param *kp)
@@ -11608,6 +11738,18 @@ MODULE_PARM_DESC(uwb_state,
 		 "Initial state of the emulated UWB switch");
 #endif
 
+#ifdef CONFIG_IGEL_THINKPAD_RFKILL_MODULE_PARAM
+module_param(wwan_rfkill, bool, 0444);
+MODULE_PARM_DESC(wwan_rfkill,
+		 "If set to false the rfkill for WWAN get disabled (rfkill switch setting get ignored)");
+module_param(wlan_rfkill, bool, 0444);
+MODULE_PARM_DESC(wlan_rfkill,
+		 "If set to false the rfkill for WLAN get disabled (rfkill switch setting get ignored)");
+module_param(bluetooth_rfkill, bool, 0444);
+MODULE_PARM_DESC(bluetooth_rfkill,
+		 "If set to false the rfkill for Bluetooth get disabled (rfkill switch setting get ignored)");
+#endif
+
 module_param(profile_force, int, 0444);
 MODULE_PARM_DESC(profile_force, "Force profile mode. -1=off, 1=MMC, 2=PSC");
 
diff -Naurp a/linux-6.6.38.igel/drivers/ssb/b43_pci_bridge.c b/linux-6.6.38.igel/drivers/ssb/b43_pci_bridge.c
--- a/linux-6.6.38.igel/drivers/ssb/b43_pci_bridge.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/ssb/b43_pci_bridge.c	2024-08-02 15:41:31.559491681 +0200
@@ -21,9 +21,12 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4301) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4306) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4307) },
+	/* gobbo@igel.com support of Broadcom bcm943224hms WLAN Adapter in our UDC2 */
+#ifndef CONFIG_IGEL_SSB_B43_PCI_PREFER_BROADCOM_STA
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4311) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4312) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4315) },
+#endif
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4318) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BCM_GVC,  0x4318) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4319) },
@@ -33,10 +36,13 @@ static const struct pci_device_id b43_pc
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 43222) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4324) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4325) },
+	/* gobbo@igel.com support of Broadcom bcm943224hms WLAN Adapter in our UDC2 */
+#ifndef CONFIG_IGEL_SSB_B43_PCI_PREFER_BROADCOM_STA
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4328) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4329) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x432b) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x432c) },
+#endif
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4350) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_BROADCOM, 0x4351) },
 	{ 0, },
diff -Naurp a/linux-6.6.38.igel/drivers/staging/media/ipu3/ipu3-v4l2.c b/linux-6.6.38.igel/drivers/staging/media/ipu3/ipu3-v4l2.c
--- a/linux-6.6.38.igel/drivers/staging/media/ipu3/ipu3-v4l2.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/staging/media/ipu3/ipu3-v4l2.c	2024-08-02 15:41:31.559491681 +0200
@@ -188,6 +188,7 @@ static int imgu_subdev_set_fmt(struct v4
 	return 0;
 }
 
+#ifndef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
 static struct v4l2_rect *
 imgu_subdev_get_crop(struct imgu_v4l2_subdev *sd,
 		     struct v4l2_subdev_state *sd_state, unsigned int pad,
@@ -209,6 +210,7 @@ imgu_subdev_get_compose(struct imgu_v4l2
 	else
 		return &sd->rect.bds;
 }
+#endif
 
 static int imgu_subdev_get_selection(struct v4l2_subdev *sd,
 				     struct v4l2_subdev_state *sd_state,
@@ -222,12 +224,28 @@ static int imgu_subdev_get_selection(str
 
 	switch (sel->target) {
 	case V4L2_SEL_TGT_CROP:
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+		if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+			sel->r = *v4l2_subdev_get_try_crop(sd, sd_state,
+							   sel->pad);
+		else
+			sel->r = imgu_sd->rect.eff;
+#else
 		sel->r = *imgu_subdev_get_crop(imgu_sd, sd_state, sel->pad,
 					       sel->which);
+#endif
 		return 0;
 	case V4L2_SEL_TGT_COMPOSE:
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+		if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+			sel->r = *v4l2_subdev_get_try_compose(sd, sd_state,
+							      sel->pad);
+		else
+			sel->r = imgu_sd->rect.bds;
+#else
 		sel->r = *imgu_subdev_get_compose(imgu_sd, sd_state, sel->pad,
 						  sel->which);
+#endif
 		return 0;
 	default:
 		return -EINVAL;
@@ -239,9 +257,16 @@ static int imgu_subdev_set_selection(str
 				     struct v4l2_subdev_selection *sel)
 {
 	struct imgu_device *imgu = v4l2_get_subdevdata(sd);
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	struct imgu_v4l2_subdev *imgu_sd = container_of(sd,
+							struct imgu_v4l2_subdev,
+							subdev);
+	struct v4l2_rect *rect, *try_sel;
+#else
 	struct imgu_v4l2_subdev *imgu_sd =
 		container_of(sd, struct imgu_v4l2_subdev, subdev);
 	struct v4l2_rect *rect;
+#endif
 
 	dev_dbg(&imgu->pci_dev->dev,
 		 "set subdev %u sel which %u target 0x%4x rect [%ux%u]",
@@ -253,18 +278,36 @@ static int imgu_subdev_set_selection(str
 
 	switch (sel->target) {
 	case V4L2_SEL_TGT_CROP:
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+		try_sel = v4l2_subdev_get_try_crop(sd, sd_state, sel->pad);
+		rect = &imgu_sd->rect.eff;
+#else
 		rect = imgu_subdev_get_crop(imgu_sd, sd_state, sel->pad,
 					    sel->which);
+#endif
 		break;
 	case V4L2_SEL_TGT_COMPOSE:
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+		try_sel = v4l2_subdev_get_try_compose(sd, sd_state, sel->pad);
+		rect = &imgu_sd->rect.bds;
+#else
 		rect = imgu_subdev_get_compose(imgu_sd, sd_state, sel->pad,
 					       sel->which);
+#endif
 		break;
 	default:
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_IGEL_SURFACE_IMPROVE_CAMERA_SUPPORT
+	if (sel->which == V4L2_SUBDEV_FORMAT_TRY)
+		*try_sel = sel->r;
+	else
+		*rect = sel->r;
+#else
 	*rect = sel->r;
+#endif
+
 	return 0;
 }
 
diff -Naurp a/linux-6.6.38.igel/drivers/tty/serial/8250/8250_dw.c b/linux-6.6.38.igel/drivers/tty/serial/8250/8250_dw.c
--- a/linux-6.6.38.igel/drivers/tty/serial/8250/8250_dw.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/tty/serial/8250/8250_dw.c	2024-08-02 15:41:31.559491681 +0200
@@ -9,6 +9,7 @@
  * LCR is written whilst busy.  If it is, then a busy detect interrupt is
  * raised, the LCR needs to be rewritten and the uart status register read.
  */
+#include <linux/acpi.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/device.h>
@@ -498,7 +499,13 @@ static void dw8250_quirks(struct uart_po
 		data->data.dma.prepare_tx_dma = dw8250_prepare_tx_dma;
 		data->data.dma.prepare_rx_dma = dw8250_prepare_rx_dma;
 	}
+#ifdef CONFIG_IGEL_FIX_SERIAL_DEVICE_THINKPAD_10_ESK_316A
+	/* gobbo@igel.com Fixed serial device support for ThinkPad 10 ESK-316A */
+	if (quirks & DW_UART_QUIRK_APMC0D08 ||
+	    acpi_dev_present("80860F0A", NULL, -1)) {
+#else
 	if (quirks & DW_UART_QUIRK_APMC0D08) {
+#endif
 		p->iotype = UPIO_MEM32;
 		p->regshift = 2;
 		p->serial_in = dw8250_serial_in32;
diff -Naurp a/linux-6.6.38.igel/drivers/tty/serial/8250/8250_pci.c b/linux-6.6.38.igel/drivers/tty/serial/8250/8250_pci.c
--- a/linux-6.6.38.igel/drivers/tty/serial/8250/8250_pci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/tty/serial/8250/8250_pci.c	2024-08-02 15:41:31.559491681 +0200
@@ -3850,6 +3850,339 @@ static const struct pci_device_id blackl
 	{ }
 };
 
+#ifdef CONFIG_IGEL_PERLE_BLACKLIST
+/*
+ * lechner@igel.de, 07.08.09
+ * this list is copied from the perle_serial driver
+ * blacklist perle cards here and handle them with perle_serial driver
+ */
+
+/* PCI PNP Vendor and Device IDs */
+#define PCI_VENDOR_ID_PLX				0x10b5
+#define PCI_DEVICE_ID_PLX_9030				0x9030
+
+#define PCI_VENDOR_ID_P_EXAR	   			0x13A8
+#define PCI_DEVICE_ID_EXAR_158     			0x158
+#define PCI_DEVICE_ID_EXAR_154     			0x154
+#define PCI_DEVICE_ID_EXAR_152     			0x152
+
+// duplicate of Vender and Device ID for Exar as sub-vendor and sub-device IDs
+#define PCI_SUBVENDOR_ID_P_EXAR				0x13A8
+#define PCI_SUBDEVICE_ID_EXAR_158     			0x158
+#define PCI_SUBDEVICE_ID_EXAR_154     			0x154
+#define PCI_SUBDEVICE_ID_EXAR_152     			0x152
+
+#define PCI_VENDOR_ID_PERLE				0x155F
+#define PCI_DEVICE_ID_PERLE_SPEED1LE			0xB001
+#define PCI_DEVICE_ID_PERLE_SPEED2LE			0xB002
+#define PCI_DEVICE_ID_PERLE_SPEED4LE			0xB004
+#define PCI_DEVICE_ID_PERLE_SPEED8LE			0xB008
+
+#define PCI_DEVICE_ID_PERLE_SPEED1LEV2			0xB011
+#define PCI_DEVICE_ID_PERLE_SPEED2LEV2			0xB012
+#define PCI_DEVICE_ID_PERLE_SPEED1LE1P			0xB013
+#define PCI_DEVICE_ID_PERLE_SPEED2LE1P			0xB014
+#define PCI_DEVICE_ID_PERLE_SPEEDLE1P			0xB015
+
+#define PCI_DEVICE_ID_PERLE_SPEED1LEEXP			0xB021
+#define PCI_DEVICE_ID_PERLE_SPEED2LEEXP			0xB022
+#define PCI_DEVICE_ID_PERLE_SPEED1LE1PEXP		0xB026
+#define PCI_DEVICE_ID_PERLE_SPEED2LE1PEXP		0xB024
+#define PCI_DEVICE_ID_PERLE_SPEEDLE1PEXP		0xB025
+
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT1EXP		0x0361
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT2EXP		0x0311
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT4EXP		0x0331
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT8EXP		0x0321
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT8IEXP		0x0351
+
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT1EXPV2		0xB030
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT2EXPV2		0xB031
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT4EXPV2		0xB032
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT8EXPV2		0xB033
+
+// duplicate of Ultraport SI sub-device IDs as Device IDs
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT1SI		0x0261
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT2SI		0x0211
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT4SI		0x0231
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT8SI		0x0221
+#define PCI_DEVICE_ID_PERLE_ULTRAPORT8ISI		0x0251
+
+// Versions of linux kernel at approx. 2.6.22 now have PCI_SUBVENDOR_ID_PERLE
+//	defined. Therefore undefine and redefine here.
+#undef	 PCI_SUBVENDOR_ID_PERLE
+#define PCI_SUBVENDOR_ID_PERLE				0x155F
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT1		0x0061
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT2		0x0011
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT4		0x0031
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8		0x0021
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT16		0x0041
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8I		0x0051
+
+#define PCI_SUBDEVICE_ID_PERLE_PCIRAS4			0xF001
+#define PCI_SUBDEVICE_ID_PERLE_PCIRAS8			0xF010
+
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT1SI		0x0261
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT2SI		0x0211
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT4SI		0x0231
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8SI		0x0221
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT16SI		0x0241
+#define PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8ISI		0x0251
+
+#define PCI_SUBVENDOR_ID_OXSEMI				0x1415
+#define PCI_SUBDEVICE_ID_OXSEMI_16PCI952		0x9521
+#define PCI_SUBDEVICE_ID_OXSEMI_16PCI954		0x9501
+#define PCI_SUBDEVICE_ID_OXSEMI_16PCI95N		0x9511
+#define PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x		0x9505
+#define PCI_SUBDEVICE_ID_OXSEMI_OXMPCI952P		0x9513
+
+static const struct pci_device_id perle_blacklist[] = {
+
+	/* Perle PCI-RAS V.92 Multi-Modem cards */
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_PCIRAS4, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_PCIRAS8, 0, 0,
+		0 },
+
+	/* Perle UltraPort cards */
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT1, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT2, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT4, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT16, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8I, 0, 0,
+		0 },
+
+	/* Perle UltraPort SI cards */
+	{	PCI_VENDOR_ID_P_EXAR, PCI_DEVICE_ID_EXAR_152,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT1SI, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_P_EXAR, PCI_DEVICE_ID_EXAR_152,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT2SI, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_P_EXAR, PCI_DEVICE_ID_EXAR_154,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT4SI, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_P_EXAR, PCI_DEVICE_ID_EXAR_158,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8SI, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PLX, PCI_DEVICE_ID_PLX_9030,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT16SI, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_P_EXAR, PCI_DEVICE_ID_EXAR_158,
+		PCI_SUBVENDOR_ID_PERLE,
+		PCI_SUBDEVICE_ID_PERLE_ULTRAPORT8ISI, 0, 0,
+		0 },
+
+	/* Perle UltraPort SI cards - now with Perle as the Vender ID. */
+	//	Do not create a new version for 16SI, it is safe (for now) using PLX.
+
+	{	PCI_VENDOR_ID_PERLE,		PCI_DEVICE_ID_PERLE_ULTRAPORT1SI,
+		PCI_SUBVENDOR_ID_P_EXAR, 	PCI_SUBDEVICE_ID_EXAR_152,
+		0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE,		PCI_DEVICE_ID_PERLE_ULTRAPORT2SI,
+		PCI_SUBVENDOR_ID_P_EXAR, 	PCI_SUBDEVICE_ID_EXAR_152,
+		0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE,		PCI_DEVICE_ID_PERLE_ULTRAPORT4SI,
+		PCI_SUBVENDOR_ID_P_EXAR,	PCI_SUBDEVICE_ID_EXAR_154,
+		0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, 		PCI_DEVICE_ID_PERLE_ULTRAPORT8SI,
+		PCI_SUBVENDOR_ID_P_EXAR, 	PCI_SUBDEVICE_ID_EXAR_158,
+		0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE,		PCI_DEVICE_ID_PERLE_ULTRAPORT8ISI,
+		PCI_SUBVENDOR_ID_P_EXAR, 	PCI_SUBDEVICE_ID_EXAR_158,
+		0, 0,
+		0 },
+
+		/* Perle Speed LE cards */
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED1LE,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI952, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED2LE,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI952, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED4LE,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI954, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED8LE,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI954, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED8LE,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI95N, 0, 0,
+		0 },
+
+		// Kludges to solve hardware problems.
+		//
+		// PCI - The Speed1 LE1P will use the 2nd Uart (which is connected to
+		//       the 10 pin header) for port 1. This is done to allow both the
+		//       serial and parallel ports to fit on 1 back panel.
+		//
+		// Express - The express chip does not allow 2 serial ports when the
+		//           parallel port is enabled. Therefore the first Uart was
+		//           connected to the 10 pin header. This required the
+		//           Speed1 LE Express to use 2nd Uart (which is
+		//           connected to the DB9 ) for port 1
+		//           This also required that a new back panel for the 2 serial
+		//           port version of the card to be created which changed the
+		//           labelling of ports 1 and 2.
+
+
+	// Perle Speed LE with Parallel Port cards.
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED1LEV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED2LEV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED1LE1P,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED2LE1P,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	// do not include parallel only card (PCI_DEVICE_ID_PERLE_SPEEDLE1P)
+
+	// Perle Speed LE Express with Parallel Port cards.
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED1LEEXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED2LEEXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_SPEED1LE1PEXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	// do not include parallel only card (PCI_DEVICE_ID_PERLE_SPEEDLE1PEXP)
+
+
+	/* Perle UltraPort Express cards */
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT1EXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI952, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT2EXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI952, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT4EXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI954, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT8EXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI954, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT8EXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI95N, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT8IEXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI954, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT8IEXP,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_16PCI95N, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT1EXPV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT2EXPV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT4EXPV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	PCI_VENDOR_ID_PERLE, PCI_DEVICE_ID_PERLE_ULTRAPORT8EXPV2,
+		PCI_SUBVENDOR_ID_OXSEMI,
+		PCI_SUBDEVICE_ID_OXSEMI_OXMPCIe95x, 0, 0,
+		0 },
+
+	{	0, }
+};
+#endif
+
 static int serial_pci_is_class_communication(struct pci_dev *dev)
 {
 	/*
@@ -4125,6 +4458,25 @@ pciserial_init_one(struct pci_dev *dev,
 
 	board = &pci_boards[ent->driver_data];
 
+#ifdef CONFIG_IGEL_PERLE_BLACKLIST
+	/*
+	 * lechner@igel.de, 07.08.09
+	 * blacklist perle cards handled by perle_serial driver
+	 * Do not access blacklisted devices that are known not to
+	 * feature serial ports.
+	 */
+
+	for (exclude = perle_blacklist;
+	     exclude < perle_blacklist + ARRAY_SIZE(perle_blacklist);
+	     exclude++) {
+		if (dev->vendor == exclude->vendor &&
+		    dev->device == exclude->device &&
+		    dev->subsystem_vendor == exclude->subvendor &&
+		    dev->subsystem_device == exclude->subdevice)
+			return -ENODEV;
+	}
+#endif
+
 	exclude = pci_match_id(blacklist, dev);
 	if (exclude) {
 		if (exclude->driver_data)
diff -Naurp a/linux-6.6.38.igel/drivers/tty/vt/keyboard.c b/linux-6.6.38.igel/drivers/tty/vt/keyboard.c
--- a/linux-6.6.38.igel/drivers/tty/vt/keyboard.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/tty/vt/keyboard.c	2024-08-02 15:41:31.563491776 +0200
@@ -1287,6 +1287,26 @@ static inline bool kbd_is_hw_raw(const s
 		dev->id.vendor == 0x0001 && dev->id.product == 0x0001;
 }
 
+/* lechner@igel.com fix x86_keycodes */
+
+#ifdef CONFIG_IGEL_KEYCODES
+static const unsigned short x86_keycodes[256] =
+       { 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
+        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
+        32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
+        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
+        64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
+        80, 81, 82, 83, 84,118, 86, 87, 88,115,120,119,121,112,123, 92,
+       284,285,309,311,312, 91,327,328,329,331,333,335,336,337,338,339,
+       367,288,302,304,350, 89,334,326,267,126,268,269,125,347,348,349,
+       360,261,262,263,268,376,100,101,321,316,373,286,289,102,351,355,
+       103,104,105,275,287,279,258,106,274,107,294,364,358,363,362,361,
+        98,108,381,281,290,272,292,305,280, 99,112,257,306,359,113,114,
+       264,117,271,374,379,265,266, 93, 94, 95, 85,259,375,260, 90,116,
+       377,109,111,277,278,282,283,295,296,297,299,300,301,293,303,307,
+       308,310,313,314,315,317,318,319,320,357,322,323,324,325,276,330,
+       332,340,365,342,343,344,345,346,356,270,341,368,369,370,371,372 };
+#else
 static const unsigned short x86_keycodes[256] =
 	{ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
 	 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
@@ -1303,6 +1323,7 @@ static const unsigned short x86_keycodes
 	377,109,111,277,278,282,283,295,296,297,299,300,301,293,303,307,
 	308,310,313,314,315,317,318,319,320,357,322,323,324,325,276,330,
 	332,340,365,342,343,344,345,346,356,270,341,368,369,370,371,372 };
+#endif
 
 #ifdef CONFIG_SPARC
 static int sparc_l1_a_state;
diff -Naurp a/linux-6.6.38.igel/drivers/usb/core/devio.c b/linux-6.6.38.igel/drivers/usb/core/devio.c
--- a/linux-6.6.38.igel/drivers/usb/core/devio.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/core/devio.c	2024-08-02 15:41:31.563491776 +0200
@@ -2352,6 +2352,15 @@ static int proc_ioctl(struct usb_dev_sta
 	/* disconnect kernel driver from interface */
 	case USBDEVFS_DISCONNECT:
 		if (intf->dev.driver) {
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+			struct usb_device       *udev = ps->dev;
+			/* gottwald@igel.com disable disconnect if it was disabled via sysfs */
+			if (udev->disable_disconnect) {
+				printk(KERN_WARNING "Blocked usbdevfs disconnect ioctl for USB device protected by disable_disconnect\n");
+				retval = -EACCES;
+				break;
+			}
+#endif
 			driver = to_usb_driver(intf->dev.driver);
 			dev_dbg(&intf->dev, "disconnect by usbfs\n");
 			usb_driver_release_interface(driver, intf);
@@ -2461,6 +2470,9 @@ static int proc_disconnect_claim(struct
 {
 	struct usbdevfs_disconnect_claim dc;
 	struct usb_interface *intf;
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	struct usb_device *udev = ps->dev;
+#endif
 
 	if (copy_from_user(&dc, arg, sizeof(dc)))
 		return -EFAULT;
@@ -2469,6 +2481,15 @@ static int proc_disconnect_claim(struct
 	if (!intf)
 		return -EINVAL;
 
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	/* gottwald@igel.com disable disconnect if it was disabled via sysfs */
+
+	if (udev->disable_disconnect) {
+		printk(KERN_WARNING "Blocked disconnect claim ioctl for USB device protected by disable_disconnect\n");
+		return -EACCES;
+	}
+#endif
+
 	if (intf->dev.driver) {
 		struct usb_driver *driver = to_usb_driver(intf->dev.driver);
 
diff -Naurp a/linux-6.6.38.igel/drivers/usb/core/driver.c b/linux-6.6.38.igel/drivers/usb/core/driver.c
--- a/linux-6.6.38.igel/drivers/usb/core/driver.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/core/driver.c	2024-08-02 15:41:31.563491776 +0200
@@ -305,6 +305,14 @@ static int usb_unbind_device(struct devi
 	struct usb_device *udev = to_usb_device(dev);
 	struct usb_device_driver *udriver = to_usb_device_driver(dev->driver);
 
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	/* gottwald@igel.com prevent device from being released */
+
+	if (udev->disable_disconnect) {
+		printk(KERN_WARNING "Blocked usb_unbind_device for USB device protected by disable_disconnect\n");
+		return -ENODEV;
+	}
+#endif
 	if (udriver->disconnect)
 		udriver->disconnect(udev);
 	if (udriver->generic_subclass)
@@ -434,10 +442,24 @@ static int usb_unbind_interface(struct d
 	int i, j, error, r;
 	int lpm_disable_error = -ENODEV;
 
+#ifndef CONFIG_IGEL_USB_DISABLE_DISCONNECT
 	intf->condition = USB_INTERFACE_UNBINDING;
 
 	/* Autoresume for set_interface call below */
 	udev = interface_to_usbdev(intf);
+#else
+	/* Autoresume for set_interface call below */
+	udev = interface_to_usbdev(intf);
+
+	/* gottwald@igel.com prevent device from being released */
+
+	if (udev->disable_disconnect) {
+		printk(KERN_WARNING "Blocked usb_unbind_interface for USB device protected by disable_disconnect\n");
+		return lpm_disable_error;
+	}
+
+	intf->condition = USB_INTERFACE_UNBINDING;
+#endif
 	error = usb_autoresume_device(udev);
 
 	/* If hub-initiated LPM policy may change, attempt to disable LPM until
@@ -610,6 +632,9 @@ void usb_driver_release_interface(struct
 					struct usb_interface *iface)
 {
 	struct device *dev = &iface->dev;
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	struct usb_device *udev = interface_to_usbdev(iface);
+#endif
 
 	/* this should never happen, don't release something that's not ours */
 	if (!dev->driver || dev->driver != &driver->drvwrap.driver)
@@ -618,6 +643,14 @@ void usb_driver_release_interface(struct
 	/* don't release from within disconnect() */
 	if (iface->condition != USB_INTERFACE_BOUND)
 		return;
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	/* gottwald@igel.com prevent device from being released */
+
+	if (udev->disable_disconnect) {
+		printk(KERN_WARNING "Blocked usb_driver_release_interface for USB device protected by disable_disconnect\n");
+		return;
+	}
+#endif
 	iface->condition = USB_INTERFACE_UNBINDING;
 
 	/* Release via the driver core only if the interface
diff -Naurp a/linux-6.6.38.igel/drivers/usb/core/quirks.c b/linux-6.6.38.igel/drivers/usb/core/quirks.c
--- a/linux-6.6.38.igel/drivers/usb/core/quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/core/quirks.c	2024-08-02 15:41:31.563491776 +0200
@@ -325,6 +325,11 @@ static const struct usb_device_id usb_qu
 	/* Alcor Micro Corp. Hub */
 	{ USB_DEVICE(0x058f, 0x9254), .driver_info = USB_QUIRK_RESET_RESUME },
 
+#ifdef CONFIG_IGEL_MICROTOUCH_USB_RESUME_QUIRK
+	/* MicroTouch Systems touchscreen */
+	{ USB_DEVICE(0x0596, 0x051e), .driver_info = USB_QUIRK_RESET_RESUME },
+#endif
+
 	/* appletouch */
 	{ USB_DEVICE(0x05ac, 0x021a), .driver_info = USB_QUIRK_RESET_RESUME },
 
@@ -477,6 +482,12 @@ static const struct usb_device_id usb_qu
 	{ USB_DEVICE(0x1908, 0x1315), .driver_info =
 			USB_QUIRK_HONOR_BNUMINTERFACES },
 
+#ifdef CONFIG_IGEL_KYOCERA_USB_SET_INTF_QUIRK
+	/* lang@igel: Kyocera FS-1350DN printer
+	 * doesn't print anything if quirk is not set */
+	{ USB_DEVICE(0x0482, 0x0392), .driver_info = USB_QUIRK_NO_SET_INTF },
+#endif
+
 	/* Protocol and OTG Electrical Test Device */
 	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =
 			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },
diff -Naurp a/linux-6.6.38.igel/drivers/usb/core/sysfs.c b/linux-6.6.38.igel/drivers/usb/core/sysfs.c
--- a/linux-6.6.38.igel/drivers/usb/core/sysfs.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/core/sysfs.c	2024-08-02 15:41:31.563491776 +0200
@@ -417,6 +417,42 @@ static ssize_t autosuspend_store(struct
 }
 static DEVICE_ATTR_RW(autosuspend);
 
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+/* gottwald@igel.com added sysfs entry to disable USB device disconnect */
+
+static ssize_t disable_disconnect_show(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct usb_device *udev = to_usb_device(dev);
+	return sprintf(buf, "%d\n", udev->disable_disconnect);
+}
+
+static ssize_t disable_disconnect_store(struct device *dev,
+				 struct device_attribute *attr, const char *buf,
+				 size_t count)
+{
+	int value;
+	struct usb_interface *intf = to_usb_interface(dev);
+	struct usb_device *udev = to_usb_device(dev);
+	struct usb_device *udev2 = interface_to_usbdev(intf);
+
+	if (sscanf(buf, "%d", &value) != 1 || value > 1 ||
+			value < 0)
+		return -EINVAL;
+
+	usb_lock_device(udev);
+	udev->disable_disconnect = value;
+	usb_unlock_device(udev);
+
+	usb_lock_device(udev2);
+	udev2->disable_disconnect = value;
+	usb_unlock_device(udev2);
+
+	return count;
+}
+static DEVICE_ATTR_RW(disable_disconnect);
+#endif
+
 static const char on_string[] = "on";
 static const char auto_string[] = "auto";
 
@@ -803,6 +839,9 @@ static struct attribute *dev_attrs[] = {
 	&dev_attr_avoid_reset_quirk.attr,
 	&dev_attr_authorized.attr,
 	&dev_attr_remove.attr,
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	&dev_attr_disable_disconnect.attr,
+#endif
 	&dev_attr_ltm_capable.attr,
 #ifdef CONFIG_OF
 	&dev_attr_devspec.attr,
diff -Naurp a/linux-6.6.38.igel/drivers/usb/host/pci-quirks.c b/linux-6.6.38.igel/drivers/usb/host/pci-quirks.c
--- a/linux-6.6.38.igel/drivers/usb/host/pci-quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/host/pci-quirks.c	2024-08-02 15:41:31.563491776 +0200
@@ -1016,6 +1016,57 @@ static int handshake(void __iomem *ptr,
 					 delay_usec, wait_usec);
 }
 
+#ifdef CONFIG_IGEL_TI_TUSB73X0_XHCI_QUIRK
+/* lang@igel: quirk for TI tusb73x0 xHCI controller, if HC halt failed */
+/* gottwald@igel.de: readded patch from 3.2 kernel */
+#define PCI_DEVICE_ID_TI_TUSB73X0_XHCI	0x8241
+#define PCIE_TUSB73X0_USBCONTROL	0xE0
+#define XHCI_CMD_LHCRSE		(1 << 7)
+static int quirk_ti_tusb73x0_xhci(struct pci_dev *pdev, void __iomem *op_reg_base)
+{
+	u32 ti_usbcontrol_reg = 0, val;
+	int timeout;
+
+	if (pdev->class != PCI_CLASS_SERIAL_USB_XHCI ||
+	    pdev->vendor != PCI_VENDOR_ID_TI ||
+	    pdev->device != PCI_DEVICE_ID_TI_TUSB73X0_XHCI)
+		return 1;
+
+	dev_warn(&pdev->dev, "Quirk for TI tusb73x0 xHCI controller\n");
+	pci_read_config_dword(pdev, PCIE_TUSB73X0_USBCONTROL,
+			&ti_usbcontrol_reg);
+	/* disable all ports */
+	pci_write_config_dword(pdev, PCIE_TUSB73X0_USBCONTROL,
+			cpu_to_le32(ti_usbcontrol_reg | 0xf00));
+
+	/* light host controller reset */
+	val = readl(op_reg_base + XHCI_CMD_OFFSET);
+	val |= XHCI_CMD_LHCRSE;
+	writel(val, op_reg_base + XHCI_CMD_OFFSET);
+	timeout = handshake(op_reg_base + XHCI_CMD_OFFSET, XHCI_CMD_LHCRSE, 0,
+			5000, 125);
+	/* Wait for the host controller to be ready before writing any
+	 * operational or runtime registers.  Wait 5 seconds and no more.
+	 */
+	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_CNR, 0,
+			5000, 10);
+
+	dev_warn(&pdev->dev, "xHCI HC status=%08x, cmd=%08x\n",
+			readl(op_reg_base + XHCI_STS_OFFSET),
+			readl(op_reg_base + XHCI_CMD_OFFSET));
+
+	/* Wait for the HC to halt - poll every 125 usec (one microframe). */
+	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_HALT, 1,
+			XHCI_MAX_HALT_USEC, 125);
+
+	/* enable ports again */
+	pci_write_config_dword(pdev, PCIE_TUSB73X0_USBCONTROL,
+			cpu_to_le32(ti_usbcontrol_reg));
+
+	return timeout;
+}
+#endif
+
 /*
  * Intel's Panther Point chipset has two host controllers (EHCI and xHCI) that
  * share some number of ports.  These ports can be switched between either
@@ -1227,10 +1278,21 @@ hc_init:
 	timeout = handshake(op_reg_base + XHCI_STS_OFFSET, XHCI_STS_HALT, 1,
 			XHCI_MAX_HALT_USEC, 125);
 	if (timeout) {
+#ifdef CONFIG_IGEL_TI_TUSB73X0_XHCI_QUIRK
+		/* lang@igel: quirk for TI tusb73x0 xHCI controller */
+		/* gottwald@igel.de: readded patch from 3.2 kernel */
+		if (quirk_ti_tusb73x0_xhci(pdev, op_reg_base)) {
+			val = readl(op_reg_base + XHCI_STS_OFFSET);
+			dev_warn(&pdev->dev,
+				 "xHCI HW did not halt within %d usec status = 0x%x\n",
+				 XHCI_MAX_HALT_USEC, val);
+		}
+#else
 		val = readl(op_reg_base + XHCI_STS_OFFSET);
 		dev_warn(&pdev->dev,
 			 "xHCI HW did not halt within %d usec status = 0x%x\n",
 			 XHCI_MAX_HALT_USEC, val);
+#endif
 	}
 
 iounmap:
diff -Naurp a/linux-6.6.38.igel/drivers/usb/host/xhci.c b/linux-6.6.38.igel/drivers/usb/host/xhci.c
--- a/linux-6.6.38.igel/drivers/usb/host/xhci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/host/xhci.c	2024-08-02 15:41:31.563491776 +0200
@@ -3085,6 +3085,29 @@ static void xhci_endpoint_reset(struct u
 	if (!host_ep->hcpriv)
 		return;
 	udev = (struct usb_device *) host_ep->hcpriv;
+
+#ifdef CONFIG_IGEL_AMD_USB2_CHERRY_KEYBOARD_WORKAROUND
+	/* gottwald@igel.com : Do this only for AMD devices as the problem
+	 * seems only occur there and not on Intel devices */
+	if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD) {
+		//andrew.li@amd.com added Jul-28-2020
+		//revert from commit f5249461b504d35aa1a40140983b7ec415807d9e
+		//to commit 15febf5eede9ff9d3180d257441e9a2fbb3f0ae6
+		//for Cherry GmbH only, to fix CHERRY SECURE BOARD not working issue
+		//
+		//For Cherry GmbH usb devices, driver will work like as linux kernel v4.16; for others, it works as normal.
+		//if (udev->product && !strncmp(udev->product, "CHERRY SECURE BOARD", strlen("CHERRY SECURE BOARD"))){
+		if (udev->manufacturer && !strncmp(udev->manufacturer, "Cherry GmbH", strlen("Cherry GmbH"))){
+			/* For now just print debug to follow the situation */
+			xhci_dbg(xhci, "Endpoint 0x%x ep reset callback called\n",
+				 host_ep->desc.bEndpointAddress);
+			dev_info(&udev->dev, "A '%s' USB device found, Will not reset device.\n",
+				 udev->manufacturer);
+			return;
+		}
+	}
+#endif
+
 	vdev = xhci->devs[udev->slot_id];
 
 	/*
diff -Naurp a/linux-6.6.38.igel/drivers/usb/host/xhci-pci.c b/linux-6.6.38.igel/drivers/usb/host/xhci-pci.c
--- a/linux-6.6.38.igel/drivers/usb/host/xhci-pci.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/host/xhci-pci.c	2024-08-02 15:41:31.563491776 +0200
@@ -365,10 +365,18 @@ static void xhci_pci_quirks(struct devic
 	    (pdev->device == 0x15e0 || pdev->device == 0x15e1))
 		xhci->quirks |= XHCI_SNPS_BROKEN_SUSPEND;
 
+#ifdef CONFIG_IGEL_AMD_WORKAROUND_XHCI_S3_ISSUES
+	if (pdev->vendor == PCI_VENDOR_ID_AMD &&
+            (pdev->device == 0x15e0 || pdev->device == 0x15e1 || pdev->device == 0x15e5)) {
+		xhci->quirks |= XHCI_DISABLE_SPARSE;
+		xhci->quirks |= XHCI_RESET_ON_RESUME;
+	}
+#else
 	if (pdev->vendor == PCI_VENDOR_ID_AMD && pdev->device == 0x15e5) {
 		xhci->quirks |= XHCI_DISABLE_SPARSE;
 		xhci->quirks |= XHCI_RESET_ON_RESUME;
 	}
+#endif
 
 	if (pdev->vendor == PCI_VENDOR_ID_AMD)
 		xhci->quirks |= XHCI_TRUST_TX_LENGTH;
@@ -543,6 +551,14 @@ static void xhci_pci_quirks(struct devic
 	if (xhci->hci_version >= 0x120)
 		xhci->quirks |= XHCI_DEFAULT_PM_RUNTIME_ALLOW;
 
+#ifdef CONFIG_IGEL_XHCI_THINKCENTRE_M73_REBOOT_QUIRK
+	/* gottwald@igel: quirk Lenovo ThinkCentre M73 to avoid superious reboot after shutdown problems */
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL &&
+		pdev->device == PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI) {
+		xhci->quirks |= XHCI_SPURIOUS_REBOOT;
+	}
+#endif
+
 	if (xhci->quirks & XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				"QUIRK: Resetting on resume");
diff -Naurp a/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio.c b/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio.c
--- a/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio.c	2024-08-02 15:41:31.563491776 +0200
@@ -1023,6 +1023,10 @@ static const struct usb_device_id id_tab
 	{ USB_DEVICE(BRAINBOXES_VID, BRAINBOXES_US_842_4_PID) },
 	/* ekey Devices */
 	{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },
+#ifdef CONFIG_IGEL_ADD_KABA_B_Net_9107_RFID_READER
+	/* freund@igel: KABA B-Net 9107 Legic RFID reader */
+	{ USB_DEVICE(KABA_VID, KABA_B_Net_9107_PID) },
+#endif
 	/* Infineon Devices */
 	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC1798_PID, 1) },
 	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC2X7_PID, 1) },
diff -Naurp a/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio_ids.h b/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio_ids.h
--- a/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio_ids.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/serial/ftdi_sio_ids.h	2024-08-02 15:41:31.563491776 +0200
@@ -1498,6 +1498,13 @@
  */
 #define FTDI_CT_COMET_PID	0x8e08
 
+/* freund@igel
+ * KABA B-Net 9107
+ * Legic RFID reader
+ */
+#define KABA_VID 0x18D9
+#define KABA_B_Net_9107_PID	0x01A0
+
 /*
  * Product: Z3X Box
  * Manufacturer: Smart GSM Team
diff -Naurp a/linux-6.6.38.igel/drivers/usb/serial/generic.c b/linux-6.6.38.igel/drivers/usb/serial/generic.c
--- a/linux-6.6.38.igel/drivers/usb/serial/generic.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/serial/generic.c	2024-08-02 15:41:31.563491776 +0200
@@ -32,7 +32,23 @@ MODULE_PARM_DESC(vendor, "User specified
 module_param(product, ushort, 0);
 MODULE_PARM_DESC(product, "User specified USB idProduct");
 
+#ifdef CONFIG_IGEL_ADD_GENERIC_USB_DEVICE_IDS
+/* lechner@igel.com add some more devices in device table */
+
+static struct usb_device_id generic_device_ids[] = {
+	/* The first entry is a placeholder for the insmod-specified device */
+	{ USB_DEVICE(0x05f9, 0xffff) },
+	{ USB_DEVICE(0x0780, 0x1202) }, /* Sagem Monetel ORGA 900 */
+	{ USB_DEVICE(0x0780, 0x1302) }, /* Sagem Monetel ORGA 6000 */
+	{ USB_DEVICE(0x04e6, 0x1a02) }, /* SCM Microsystems eHealth500 */
+	{ USB_DEVICE(0x152a, 0x8180) }, /* Celectronic CARD STAR /medic2 and /memo3 */
+	{ }                             /* Terminating entry */
+};
+
+MODULE_DEVICE_TABLE (usb, generic_device_ids);
+#else
 static struct usb_device_id generic_device_ids[2]; /* Initially all zeroes. */
+#endif
 
 static int usb_serial_generic_probe(struct usb_serial *serial,
 					const struct usb_device_id *id)
diff -Naurp a/linux-6.6.38.igel/drivers/usb/serial/pl2303.c b/linux-6.6.38.igel/drivers/usb/serial/pl2303.c
--- a/linux-6.6.38.igel/drivers/usb/serial/pl2303.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/serial/pl2303.c	2024-08-02 15:41:31.563491776 +0200
@@ -109,6 +109,9 @@ static const struct usb_device_id id_tab
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LM930_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_LM940_PRODUCT_ID) },
 	{ USB_DEVICE(HP_VENDOR_ID, HP_TD620_PRODUCT_ID) },
+#ifdef CONFIG_IGEL_USB_SERIAL_SUPPORT_HP_LDM350_DEVICES
+	{ USB_DEVICE(HP_VENDOR_ID, HP_LDM350_PRODUCT_ID) },
+#endif
 	{ USB_DEVICE(CRESSI_VENDOR_ID, CRESSI_EDY_PRODUCT_ID) },
 	{ USB_DEVICE(ZEAGLE_VENDOR_ID, ZEAGLE_N2ITION3_PRODUCT_ID) },
 	{ USB_DEVICE(SONY_VENDOR_ID, SONY_QN3USB_PRODUCT_ID) },
diff -Naurp a/linux-6.6.38.igel/drivers/usb/serial/pl2303.h b/linux-6.6.38.igel/drivers/usb/serial/pl2303.h
--- a/linux-6.6.38.igel/drivers/usb/serial/pl2303.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/usb/serial/pl2303.h	2024-08-02 15:41:31.563491776 +0200
@@ -139,6 +139,9 @@
 #define HP_LCM220_PRODUCT_ID	0x3139
 #define HP_LCM960_PRODUCT_ID	0x3239
 #define HP_LD220_PRODUCT_ID	0x3524
+#ifdef CONFIG_IGEL_USB_SERIAL_SUPPORT_HP_LDM350_DEVICES
+#define HP_LDM350_PRODUCT_ID	0x3739
+#endif
 #define HP_LD220TA_PRODUCT_ID	0x4349
 #define HP_LD960TA_PRODUCT_ID	0x4439
 #define HP_LM940_PRODUCT_ID	0x5039
diff -Naurp a/linux-6.6.38.igel/drivers/video/console/vgacon.c b/linux-6.6.38.igel/drivers/video/console/vgacon.c
--- a/linux-6.6.38.igel/drivers/video/console/vgacon.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/video/console/vgacon.c	2024-08-02 15:41:31.563491776 +0200
@@ -92,6 +92,31 @@ static unsigned int 	vga_rolled_over; /*
 static bool vga_hardscroll_enabled;
 static bool vga_hardscroll_user_enable = true;
 
+#ifdef CONFIG_IGEL_SPLASH_FIX
+/* lang@igel.de: splash=<modenr> is set by our bootcode if splash is active */
+static int splash_mode = 0;
+
+static int __init setup_splash_mode(char *str)
+{
+	if (splash_mode == 0)
+		get_option(&str, &splash_mode);
+	return 1;
+}
+__setup("splash=", setup_splash_mode);
+
+/* gottwald@igel.com : make it possible to disable the splash fix with boot
+ *                     options as this could cause some problem in virtualized
+ *                     environments */
+
+static int __init no_splash_fix(char *str)
+{
+	splash_mode = -1;
+	return 1;
+}
+
+__setup("no_igel_splash_fix", no_splash_fix);
+#endif
+
 static int __init no_scroll(char *str)
 {
 	/*
@@ -164,6 +189,14 @@ static const char *vgacon_startup(void)
 #endif
 	}
 
+#ifdef CONFIG_IGEL_SPLASH_FIX
+	/* lang@igel.de: if splash is active do not configure a VGA console,
+	   because the boot splash is corrupted by a VGA console */
+	if (splash_mode > 0) {
+		goto no_vga;
+	}
+#endif
+
 	/* boot_params.screen_info reasonably initialized? */
 	if ((screen_info.orig_video_lines == 0) ||
 	    (screen_info.orig_video_cols  == 0))
diff -Naurp a/linux-6.6.38.igel/drivers/video/fbdev/core/fbcon.c b/linux-6.6.38.igel/drivers/video/fbdev/core/fbcon.c
--- a/linux-6.6.38.igel/drivers/video/fbdev/core/fbcon.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/drivers/video/fbdev/core/fbcon.c	2024-08-02 15:41:31.563491776 +0200
@@ -270,10 +270,39 @@ static int fbcon_get_rotate(struct fb_in
 	return (ops) ? ops->rotate : 0;
 }
 
+#ifdef CONFIG_IGEL_SPLASH_FIX
+static int igel_splash_fix = 1;
+
+/* lang@igel: our bootcode shows a boot splash, the splash
+   should not be destroyed by a frame buffer console */
+static inline int fbcon_fix_igel_splash(struct vc_data *vc)
+{
+	if (vc->vc_num != 0 || fg_console != 0 || ! (*vc->vc_display_fg == vc))
+		return 0;
+	/* remove splash fix after x server was started */
+	if (vc->vc_mode == KD_GRAPHICS) {
+		igel_splash_fix = 0;
+		printk("fbcon: remove igel boot splash fix\n");
+		return 0;
+	}
+	/* show the message only once ! */
+	if (igel_splash_fix == 1) {
+		printk("fbcon: fix igel boot splash\n");
+		igel_splash_fix = 2;
+	}
+	return (1);
+}
+#endif
+
 static inline int fbcon_is_inactive(struct vc_data *vc, struct fb_info *info)
 {
 	struct fbcon_ops *ops = info->fbcon_par;
 
+#ifdef CONFIG_IGEL_SPLASH_FIX
+	if (igel_splash_fix && fbcon_fix_igel_splash(vc))
+		return 1;
+#endif
+
 	return (info->state != FBINFO_STATE_RUNNING ||
 		vc->vc_mode != KD_TEXT || ops->graphics);
 }
diff -Naurp a/linux-6.6.38.igel/fs/namei.c b/linux-6.6.38.igel/fs/namei.c
--- a/linux-6.6.38.igel/fs/namei.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/namei.c	2024-08-02 15:41:31.563491776 +0200
@@ -1027,9 +1027,15 @@ static inline void put_link(struct namei
 	if (!(nd->flags & LOOKUP_RCU))
 		path_put(&last->link);
 }
-
+#ifdef CONFIG_IGEL_SYSCTL_PROTECT_SYMLINKS_AND_HARDLINKS
+/* gottwald@igel.com : Enable Link security restrictions by default
+ * Patch taken from debian Change some defaults for security reasons */
+static int sysctl_protected_symlinks __read_mostly = 1;
+static int sysctl_protected_hardlinks __read_mostly = 1;
+#else
 static int sysctl_protected_symlinks __read_mostly;
 static int sysctl_protected_hardlinks __read_mostly;
+#endif
 static int sysctl_protected_fifos __read_mostly;
 static int sysctl_protected_regular __read_mostly;
 
diff -Naurp a/linux-6.6.38.igel/fs/namespace.c b/linux-6.6.38.igel/fs/namespace.c
--- a/linux-6.6.38.igel/fs/namespace.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/namespace.c	2024-08-02 15:41:31.563491776 +0200
@@ -2791,6 +2791,7 @@ static void set_mount_attributes(struct
 
 static void mnt_warn_timestamp_expiry(struct path *mountpoint, struct vfsmount *mnt)
 {
+#ifndef CONFIG_IGEL_NO_TIMESTAMP_WARNING
 	struct super_block *sb = mnt->mnt_sb;
 
 	if (!__mnt_is_readonly(mnt) &&
@@ -2808,6 +2809,9 @@ static void mnt_warn_timestamp_expiry(st
 		free_page((unsigned long)buf);
 		sb->s_iflags |= SB_I_TS_EXPIRY_WARNED;
 	}
+#else
+	return;
+#endif
 }
 
 /*
diff -Naurp a/linux-6.6.38.igel/fs/nfs/nfs4proc.c b/linux-6.6.38.igel/fs/nfs/nfs4proc.c
--- a/linux-6.6.38.igel/fs/nfs/nfs4proc.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/nfs/nfs4proc.c	2024-08-02 15:41:31.567491872 +0200
@@ -3893,8 +3893,14 @@ static int _nfs4_server_capabilities(str
 		if (res.attr_bitmask[2] & FATTR4_WORD2_SECURITY_LABEL)
 			server->caps |= NFS_CAP_SECURITY_LABEL;
 #endif
+#ifdef CONFIG_IGEL_NFS_QNAP_WORKAROUND
+		/* Restrict FS_LOCATIONS to NFS v4.3+ to work aroundi Qnap knfsd-3.4.6 bug */
+		if (minorversion >= 3 && (res.attr_bitmask[0] & FATTR4_WORD0_FS_LOCATIONS))
+			server->caps |= NFS_CAP_FS_LOCATIONS;
+#else
 		if (res.attr_bitmask[0] & FATTR4_WORD0_FS_LOCATIONS)
 			server->caps |= NFS_CAP_FS_LOCATIONS;
+#endif
 		if (!(res.attr_bitmask[0] & FATTR4_WORD0_FILEID))
 			server->fattr_valid &= ~NFS_ATTR_FATTR_FILEID;
 		if (!(res.attr_bitmask[1] & FATTR4_WORD1_MODE))
diff -Naurp a/linux-6.6.38.igel/fs/proc/base.c b/linux-6.6.38.igel/fs/proc/base.c
--- a/linux-6.6.38.igel/fs/proc/base.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/proc/base.c	2024-08-02 15:41:31.567491872 +0200
@@ -2858,6 +2858,10 @@ static const struct pid_entry attr_dir_s
 	ATTR(NULL, "fscreate",		0666),
 	ATTR(NULL, "keycreate",		0666),
 	ATTR(NULL, "sockcreate",	0666),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	ATTR(NULL, "display",		0666),
+	ATTR(NULL, "context",		0444),
+#endif
 #ifdef CONFIG_SECURITY_SMACK
 	DIR("smack",			0555,
 	    proc_smack_attr_dir_inode_ops, proc_smack_attr_dir_ops),
diff -Naurp a/linux-6.6.38.igel/fs/proc/Makefile b/linux-6.6.38.igel/fs/proc/Makefile
--- a/linux-6.6.38.igel/fs/proc/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/proc/Makefile	2024-08-02 15:41:31.567491872 +0200
@@ -34,3 +34,4 @@ proc-$(CONFIG_PROC_VMCORE)	+= vmcore.o
 proc-$(CONFIG_PRINTK)	+= kmsg.o
 proc-$(CONFIG_PROC_PAGE_MONITOR)	+= page.o
 proc-$(CONFIG_BOOT_CONFIG)	+= bootconfig.o
+proc-$(CONFIG_IGEL_USE_VERSION_SIGNATURE)	+= version_signature.o
diff -Naurp a/linux-6.6.38.igel/fs/proc/version_signature.c b/linux-6.6.38.igel/fs/proc/version_signature.c
--- a/linux-6.6.38.igel/fs/proc/version_signature.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/fs/proc/version_signature.c	2024-08-02 15:41:31.567491872 +0200
@@ -0,0 +1,35 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/utsname.h>
+
+#ifdef CONFIG_IGEL_VERSION_SIGNATURE
+static int version_signature_proc_show(struct seq_file *m, void *v)
+{
+	seq_printf(m, "%s\n", CONFIG_IGEL_VERSION_SIGNATURE);
+	return 0;
+}
+
+static int version_signature_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, version_signature_proc_show, NULL);
+}
+
+static const struct proc_ops version_signature_proc_fops = {
+	.proc_open		= version_signature_proc_open,
+	.proc_read		= seq_read,
+	.proc_lseek		= seq_lseek,
+	.proc_release	= single_release,
+};
+
+static int __init proc_version_signature_init(void)
+{
+	proc_create("version_signature", 0, NULL, &version_signature_proc_fops);
+	return 0;
+}
+
+module_init(proc_version_signature_init);
+#endif
diff -Naurp a/linux-6.6.38.igel/fs/squashfs/super.c b/linux-6.6.38.igel/fs/squashfs/super.c
--- a/linux-6.6.38.igel/fs/squashfs/super.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/fs/squashfs/super.c	2024-08-02 15:41:31.567491872 +0200
@@ -316,6 +316,14 @@ static int squashfs_fill_super(struct su
 
 	err = -ENOMEM;
 
+#ifdef CONFIG_IGEL_GENERATE_UUID_FOR_SQUASHFS
+	memcpy(&sb->s_uuid.b[0], &sblk->inodes, 4);
+	memcpy(&sb->s_uuid.b[4], &sblk->mkfs_time, 4);
+	memcpy(&sb->s_uuid.b[8], &sblk->fragments, 4);
+	memcpy(&sb->s_uuid.b[12], &sblk->compression, 2);
+	memcpy(&sb->s_uuid.b[14], &sblk->block_log, 2);
+#endif
+
 	msblk->block_cache = squashfs_cache_init("metadata",
 			SQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);
 	if (msblk->block_cache == NULL)
diff -Naurp a/linux-6.6.38.igel/include/crypto/public_key.h b/linux-6.6.38.igel/include/crypto/public_key.h
--- a/linux-6.6.38.igel/include/crypto/public_key.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/crypto/public_key.h	2024-08-02 15:41:31.567491872 +0200
@@ -108,6 +108,11 @@ extern int decrypt_blob(struct kernel_pk
 extern int create_signature(struct kernel_pkey_params *, const void *, void *);
 extern int verify_signature(const struct key *,
 			    const struct public_key_signature *);
+#ifdef CONFIG_IGEL_VERIFY_SIGNATURE_AGAINST_KEYRING
+extern int verify_signature_igel(const struct key *,
+				 const struct public_key_signature *,
+				 uint32_t *serial);
+#endif
 
 #if IS_REACHABLE(CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE)
 int public_key_verify_signature(const struct public_key *pkey,
diff -Naurp a/linux-6.6.38.igel/include/drm/drm_client.h b/linux-6.6.38.igel/include/drm/drm_client.h
--- a/linux-6.6.38.igel/include/drm/drm_client.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/drm/drm_client.h	2024-08-02 15:41:31.567491872 +0200
@@ -165,7 +165,11 @@ void drm_client_buffer_vunmap(struct drm
 
 int drm_client_modeset_create(struct drm_client_dev *client);
 void drm_client_modeset_free(struct drm_client_dev *client);
+#ifdef CONFIG_IGEL_USE_BEST_MODE_FRAMEBUFFER
+int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height, bool use_best_mode, unsigned int m_width, unsigned int m_height);
+#else
 int drm_client_modeset_probe(struct drm_client_dev *client, unsigned int width, unsigned int height);
+#endif
 bool drm_client_rotation(struct drm_mode_set *modeset, unsigned int *rotation);
 int drm_client_modeset_check(struct drm_client_dev *client);
 int drm_client_modeset_commit_locked(struct drm_client_dev *client);
diff -Naurp a/linux-6.6.38.igel/include/drm/drm_connector.h b/linux-6.6.38.igel/include/drm/drm_connector.h
--- a/linux-6.6.38.igel/include/drm/drm_connector.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/drm/drm_connector.h	2024-08-02 15:41:31.567491872 +0200
@@ -1335,6 +1335,15 @@ struct drm_connector_funcs {
 	 * Allows connectors to create connector-specific debugfs files.
 	 */
 	void (*debugfs_init)(struct drm_connector *connector, struct dentry *root);
+
+#ifdef CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO
+	/* schneider@igel.com SDVO register save function */
+	/* Save CRTC state */
+	void (*save)(struct drm_connector *connector); /* suspend? */
+	/* schneider@igel.com SDVO register restore function */
+	/* Restore CRTC state */
+	void (*restore)(struct drm_connector *connector); /* resume? */
+#endif /* CONFIG_IGEL_DRM_I915_SAVE_RESTORE_SDVO */
 };
 
 /**
diff -Naurp a/linux-6.6.38.igel/include/linux/audit.h b/linux-6.6.38.igel/include/linux/audit.h
--- a/linux-6.6.38.igel/include/linux/audit.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/linux/audit.h	2024-08-02 15:41:31.567491872 +0200
@@ -12,6 +12,9 @@
 #include <linux/sched.h>
 #include <linux/ptrace.h>
 #include <linux/audit_arch.h>
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include <linux/security.h>
+#endif
 #include <uapi/linux/audit.h>
 #include <uapi/linux/netfilter/nf_tables.h>
 #include <uapi/linux/fanotify.h>
@@ -66,10 +69,18 @@ struct audit_field {
 		u32			val;
 		kuid_t			uid;
 		kgid_t			gid;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		struct {
+			bool		lsm_isset;
+			char		*lsm_str;
+			void		*lsm_rules[LSMBLOB_ENTRIES];
+		};
+#else
 		struct {
 			char		*lsm_str;
 			void		*lsm_rule;
 		};
+#endif
 	};
 	u32				op;
 };
diff -Naurp a/linux-6.6.38.igel/include/linux/lsm_hooks.h b/linux-6.6.38.igel/include/linux/lsm_hooks.h
--- a/linux-6.6.38.igel/include/linux/lsm_hooks.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/linux/lsm_hooks.h	2024-08-02 15:41:31.567491872 +0200
@@ -42,6 +42,16 @@ struct security_hook_heads {
 	#undef LSM_HOOK
 } __randomize_layout;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/*
+ * Information that identifies a security module.
+ */
+struct lsm_id {
+	const char	*lsm;	/* Name of the LSM */
+	int		slot;	/* Slot in lsmblob if one is allocated */
+};
+#endif
+
 /*
  * Security module hook list structure.
  * For use with generic list macros for common operations.
@@ -50,7 +60,11 @@ struct security_hook_list {
 	struct hlist_node		list;
 	struct hlist_head		*head;
 	union security_list_options	hook;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct lsm_id			*lsmid;
+#else
 	const char			*lsm;
+#endif
 } __randomize_layout;
 
 /*
@@ -61,6 +75,9 @@ struct lsm_blob_sizes {
 	int	lbs_file;
 	int	lbs_inode;
 	int	lbs_superblock;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int	lbs_sock;
+#endif
 	int	lbs_ipc;
 	int	lbs_msg_msg;
 	int	lbs_task;
@@ -103,8 +120,13 @@ static inline struct xattr *lsm_get_xatt
 extern struct security_hook_heads security_hook_heads;
 extern char *lsm_names;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+extern void security_add_hooks(struct security_hook_list *hooks, int count,
+			       struct lsm_id *lsmid);
+#else
 extern void security_add_hooks(struct security_hook_list *hooks, int count,
 				const char *lsm);
+#endif
 
 #define LSM_FLAG_LEGACY_MAJOR	BIT(0)
 #define LSM_FLAG_EXCLUSIVE	BIT(1)
@@ -139,4 +161,23 @@ extern struct lsm_info __start_early_lsm
 
 extern int lsm_inode_alloc(struct inode *inode);
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * lsm_task_display - the "display" LSM for this task
+ * @task: The task to report on
+ *
+ * Returns the task's display LSM slot.
+ */
+static inline int lsm_task_display(struct task_struct *task)
+{
+#ifdef CONFIG_SECURITY
+	int *display = task->security;
+
+	if (display)
+		return *display;
+#endif
+	return LSMBLOB_INVALID;
+}
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
+
 #endif /* ! __LINUX_LSM_HOOKS_H */
diff -Naurp a/linux-6.6.38.igel/include/linux/security.h b/linux-6.6.38.igel/include/linux/security.h
--- a/linux-6.6.38.igel/include/linux/security.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/linux/security.h	2024-08-02 15:41:31.567491872 +0200
@@ -139,6 +139,67 @@ enum lockdown_reason {
 
 extern const char *const lockdown_reasons[LOCKDOWN_CONFIDENTIALITY_MAX+1];
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/*
+ * Data exported by the security modules
+ *
+ * Any LSM that provides secid or secctx based hooks must be included.
+ */
+#define LSMBLOB_ENTRIES ( \
+	(IS_ENABLED(CONFIG_SECURITY_SELINUX) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_SECURITY_SMACK) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_SECURITY_APPARMOR) ? 1 : 0) + \
+	(IS_ENABLED(CONFIG_BPF_LSM) ? 1 : 0))
+
+struct lsmblob {
+	u32     secid[LSMBLOB_ENTRIES];
+};
+
+#define LSMBLOB_INVALID		-1	/* Not a valid LSM slot number */
+#define LSMBLOB_NEEDED		-2	/* Slot requested on initialization */
+#define LSMBLOB_NOT_NEEDED	-3	/* Slot not requested */
+
+/**
+ * lsmblob_init - initialize an lsmblob structure.
+ * @blob: Pointer to the data to initialize
+ * @secid: The initial secid value
+ *
+ * Set all secid for all modules to the specified value.
+ */
+static inline void lsmblob_init(struct lsmblob *blob, u32 secid)
+{
+	int i;
+
+	for (i = 0; i < LSMBLOB_ENTRIES; i++)
+		blob->secid[i] = secid;
+}
+
+/**
+ * lsmblob_is_set - report if there is an value in the lsmblob
+ * @blob: Pointer to the exported LSM data
+ *
+ * Returns true if there is a secid set, false otherwise
+ */
+static inline bool lsmblob_is_set(struct lsmblob *blob)
+{
+	struct lsmblob empty = {};
+
+	return !!memcmp(blob, &empty, sizeof(*blob));
+}
+
+/**
+ * lsmblob_equal - report if the two lsmblob's are equal
+ * @bloba: Pointer to one LSM data
+ * @blobb: Pointer to the other LSM data
+ *
+ * Returns true if all entries in the two are equal, false otherwise
+ */
+static inline bool lsmblob_equal(struct lsmblob *bloba, struct lsmblob *blobb)
+{
+	return !memcmp(bloba, blobb, sizeof(*bloba));
+}
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
+
 /* These functions are in security/commoncap.c */
 extern int cap_capable(const struct cred *cred, struct user_namespace *ns,
 		       int cap, unsigned int opts);
@@ -1955,8 +2016,13 @@ static inline int security_key_getsecuri
 #ifdef CONFIG_SECURITY
 int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule);
 int security_audit_rule_known(struct audit_krule *krule);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+int security_audit_rule_match(u32 secid, u32 field, u32 op, void **lsmrule);
+void security_audit_rule_free(void **lsmrule);
+#else
 int security_audit_rule_match(u32 secid, u32 field, u32 op, void *lsmrule);
 void security_audit_rule_free(void *lsmrule);
+#endif
 
 #else
 
@@ -1971,13 +2037,22 @@ static inline int security_audit_rule_kn
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static inline int security_audit_rule_match(u32 secid, u32 field, u32 op,
+					    void **lsmrule)
+#else
 static inline int security_audit_rule_match(u32 secid, u32 field, u32 op,
 					    void *lsmrule)
+#endif
 {
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static inline void security_audit_rule_free(void **lsmrule)
+#else
 static inline void security_audit_rule_free(void *lsmrule)
+#endif
 { }
 
 #endif /* CONFIG_SECURITY */
diff -Naurp a/linux-6.6.38.igel/include/linux/usb.h b/linux-6.6.38.igel/include/linux/usb.h
--- a/linux-6.6.38.igel/include/linux/usb.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/linux/usb.h	2024-08-02 15:41:31.567491872 +0200
@@ -729,6 +729,10 @@ struct usb_device {
 
 	u16 hub_delay;
 	unsigned use_generic_driver:1;
+#ifdef CONFIG_IGEL_USB_DISABLE_DISCONNECT
+	/* IGEL to prevent driver disconnect */
+	unsigned disable_disconnect:1;
+#endif
 };
 
 #define to_usb_device(__dev)	container_of_const(__dev, struct usb_device, dev)
diff -Naurp a/linux-6.6.38.igel/include/linux/writeback.h b/linux-6.6.38.igel/include/linux/writeback.h
--- a/linux-6.6.38.igel/include/linux/writeback.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/linux/writeback.h	2024-08-02 15:41:31.567491872 +0200
@@ -177,7 +177,7 @@ static inline void wb_domain_size_change
 
 /*
  * fs/fs-writeback.c
- */	
+ */
 struct bdi_writeback;
 void writeback_inodes_sb(struct super_block *, enum wb_reason reason);
 void writeback_inodes_sb_nr(struct super_block *, unsigned long nr,
diff -Naurp a/linux-6.6.38.igel/include/sound/jack.h b/linux-6.6.38.igel/include/sound/jack.h
--- a/linux-6.6.38.igel/include/sound/jack.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/sound/jack.h	2024-08-02 15:41:31.567491872 +0200
@@ -73,6 +73,21 @@ struct snd_jack {
 	void (*private_free)(struct snd_jack *);
 };
 
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES) || defined(CONFIG_IGEL_LENOVO_M600_SOUND_FIXES)
+/* gottwald@igel.com moved here from sound/core/jack.c */
+
+struct snd_jack_kctl {
+	struct snd_kcontrol *kctl;
+	struct list_head list;  /* list of controls belong to the same jack */
+	unsigned int mask_bits; /* only masked status bits are reported via kctl */
+        struct snd_jack *jack;  /* pointer to struct snd_jack */
+	bool sw_inject_enable;  /* allow to inject plug event via debugfs */
+#ifdef CONFIG_SND_JACK_INJECTION_DEBUG
+	struct dentry *jack_debugfs_root; /* jack_kctl debugfs root */
+#endif
+};
+#endif
+
 #ifdef CONFIG_SND_JACK
 
 int snd_jack_new(struct snd_card *card, const char *id, int type,
diff -Naurp a/linux-6.6.38.igel/include/uapi/linux/major.h b/linux-6.6.38.igel/include/uapi/linux/major.h
--- a/linux-6.6.38.igel/include/uapi/linux/major.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/include/uapi/linux/major.h	2024-08-02 15:41:31.567491872 +0200
@@ -75,6 +75,9 @@
 #define IDE4_MAJOR		56
 #define IDE5_MAJOR		57
 
+#define IGEL_FLASH_MAJOR	61   /* /dev/igf... */
+#define IGEL_V5_FLASH_MAJOR	62   /* /dev/igl... */
+#define IGEL_V10_FLASH_MAJOR	63   /* /dev/igb... */
 #define SCSI_DISK1_MAJOR	65
 #define SCSI_DISK2_MAJOR	66
 #define SCSI_DISK3_MAJOR	67
diff -Naurp a/linux-6.6.38.igel/init/version-timestamp.c b/linux-6.6.38.igel/init/version-timestamp.c
--- a/linux-6.6.38.igel/init/version-timestamp.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/init/version-timestamp.c	2024-08-02 15:41:31.567491872 +0200
@@ -25,6 +25,14 @@ struct uts_namespace init_uts_ns = {
 };
 
 /* FIXED STRINGS! Don't touch! */
+#ifdef CONFIG_IGEL_VERSION_SIGNATURE
+const char linux_banner[] =
+	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
+	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION
+	" (" CONFIG_IGEL_VERSION_SIGNATURE ")"
+	"\n";
+#else
 const char linux_banner[] =
 	"Linux version " UTS_RELEASE " (" LINUX_COMPILE_BY "@"
 	LINUX_COMPILE_HOST ") (" LINUX_COMPILER ") " UTS_VERSION "\n";
+#endif
diff -Naurp a/linux-6.6.38.igel/Kconfig b/linux-6.6.38.igel/Kconfig
--- a/linux-6.6.38.igel/Kconfig	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Kconfig	2024-08-02 15:41:31.527490917 +0200
@@ -5,6 +5,8 @@
 #
 mainmenu "Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration"
 
+source "IGEL/Kconfig.igel"
+
 source "scripts/Kconfig.include"
 
 source "init/Kconfig"
diff -Naurp a/linux-6.6.38.igel/kernel/auditfilter.c b/linux-6.6.38.igel/kernel/auditfilter.c
--- a/linux-6.6.38.igel/kernel/auditfilter.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/kernel/auditfilter.c	2024-08-02 15:41:31.567491872 +0200
@@ -76,7 +76,11 @@ static void audit_free_lsm_field(struct
 	case AUDIT_OBJ_LEV_LOW:
 	case AUDIT_OBJ_LEV_HIGH:
 		kfree(f->lsm_str);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		security_audit_rule_free(f->lsm_rules);
+#else
 		security_audit_rule_free(f->lsm_rule);
+#endif
 	}
 }
 
@@ -527,9 +531,17 @@ static struct audit_entry *audit_data_to
 				goto exit_free;
 			}
 			entry->rule.buflen += f_val;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			f->lsm_isset = true;
+#endif
 			f->lsm_str = str;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			err = security_audit_rule_init(f->type, f->op, str,
+						       f->lsm_rules);
+#else
 			err = security_audit_rule_init(f->type, f->op, str,
 						       (void **)&f->lsm_rule);
+#endif
 			/* Keep currently invalid fields around in case they
 			 * become valid after a policy reload. */
 			if (err == -EINVAL) {
@@ -797,9 +809,15 @@ static inline int audit_dupe_lsm_field(s
 		return -ENOMEM;
 	df->lsm_str = lsm_str;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	/* our own (refreshed) copy of lsm_rules */
+	ret = security_audit_rule_init(df->type, df->op, df->lsm_str,
+				       df->lsm_rules);
+#else
 	/* our own (refreshed) copy of lsm_rule */
 	ret = security_audit_rule_init(df->type, df->op, df->lsm_str,
 				       (void **)&df->lsm_rule);
+#endif
 	/* Keep currently invalid fields around in case they
 	 * become valid after a policy reload. */
 	if (ret == -EINVAL) {
@@ -1368,10 +1386,20 @@ int audit_filter(int msgtype, unsigned i
 			case AUDIT_SUBJ_TYPE:
 			case AUDIT_SUBJ_SEN:
 			case AUDIT_SUBJ_CLR:
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+				if (f->lsm_isset) {
+#else
 				if (f->lsm_rule) {
+#endif
 					security_current_getsecid_subj(&sid);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+					result = security_audit_rule_match(sid,
+						   f->type, f->op,
+						   f->lsm_rules);
+#else
 					result = security_audit_rule_match(sid,
 						   f->type, f->op, f->lsm_rule);
+#endif
 				}
 				break;
 			case AUDIT_EXE:
@@ -1398,7 +1426,11 @@ unlock_and_return:
 	return ret;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static int update_lsm_rules(struct audit_krule *r)
+#else
 static int update_lsm_rule(struct audit_krule *r)
+#endif
 {
 	struct audit_entry *entry = container_of(r, struct audit_entry, rule);
 	struct audit_entry *nentry;
@@ -1445,7 +1477,11 @@ int audit_update_lsm_rules(void)
 
 	for (i = 0; i < AUDIT_NR_FILTERS; i++) {
 		list_for_each_entry_safe(r, n, &audit_rules_list[i], list) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			int res = update_lsm_rules(r);
+#else
 			int res = update_lsm_rule(r);
+#endif
 			if (!err)
 				err = res;
 		}
diff -Naurp a/linux-6.6.38.igel/kernel/auditsc.c b/linux-6.6.38.igel/kernel/auditsc.c
--- a/linux-6.6.38.igel/kernel/auditsc.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/kernel/auditsc.c	2024-08-02 15:41:31.567491872 +0200
@@ -667,7 +667,11 @@ static int audit_filter_rules(struct tas
 			   match for now to avoid losing information that
 			   may be wanted.   An error message will also be
 			   logged upon error */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			if (f->lsm_isset) {
+#else
 			if (f->lsm_rule) {
+#endif
 				if (need_sid) {
 					/* @tsk should always be equal to
 					 * @current with the exception of
@@ -681,9 +685,15 @@ static int audit_filter_rules(struct tas
 					security_current_getsecid_subj(&sid);
 					need_sid = 0;
 				}
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+				result = security_audit_rule_match(sid, f->type,
+								   f->op,
+								   f->lsm_rules);
+#else
 				result = security_audit_rule_match(sid, f->type,
 								   f->op,
 								   f->lsm_rule);
+#endif
 			}
 			break;
 		case AUDIT_OBJ_USER:
@@ -693,21 +703,41 @@ static int audit_filter_rules(struct tas
 		case AUDIT_OBJ_LEV_HIGH:
 			/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR
 			   also applies here */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			if (f->lsm_isset) {
+#else
 			if (f->lsm_rule) {
+#endif
 				/* Find files that match */
 				if (name) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+					result = security_audit_rule_match(
+								name->osid,
+								f->type,
+								f->op,
+								f->lsm_rules);
+#else
 					result = security_audit_rule_match(
 								name->osid,
 								f->type,
 								f->op,
 								f->lsm_rule);
+#endif
 				} else if (ctx) {
 					list_for_each_entry(n, &ctx->names_list, list) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+						if (security_audit_rule_match(
+								n->osid,
+								f->type,
+								f->op,
+								f->lsm_rules)) {
+#else
 						if (security_audit_rule_match(
 								n->osid,
 								f->type,
 								f->op,
 								f->lsm_rule)) {
+#endif
 							++result;
 							break;
 						}
@@ -716,9 +746,15 @@ static int audit_filter_rules(struct tas
 				/* Find ipc objects that match */
 				if (!ctx || ctx->type != AUDIT_IPC)
 					break;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+				if (security_audit_rule_match(ctx->ipc.osid,
+							      f->type, f->op,
+							      f->lsm_rules))
+#else
 				if (security_audit_rule_match(ctx->ipc.osid,
 							      f->type, f->op,
 							      f->lsm_rule))
+#endif
 					++result;
 			}
 			break;
diff -Naurp a/linux-6.6.38.igel/MAINTAINERS b/linux-6.6.38.igel/MAINTAINERS
--- a/linux-6.6.38.igel/MAINTAINERS	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/MAINTAINERS	2024-08-02 15:41:31.531491012 +0200
@@ -6302,6 +6302,13 @@ T:	git git://linuxtv.org/media_tree.git
 F:	drivers/media/i2c/dw9719.c
 
 DONGWOON DW9768 LENS VOICE COIL DRIVER
+M:	Dongchun Zhu <dongchun.zhu@mediatek.com>
+L:	linux-media@vger.kernel.org
+S:	Maintained
+T:	git git://linuxtv.org/media_tree.git
+F:	drivers/media/i2c/dw9719.c
+
+DONGWOON DW9768 LENS VOICE COIL DRIVER
 L:	linux-media@vger.kernel.org
 S:	Orphan
 T:	git git://linuxtv.org/media_tree.git
diff -Naurp a/linux-6.6.38.igel/Makefile b/linux-6.6.38.igel/Makefile
--- a/linux-6.6.38.igel/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/Makefile	2024-08-02 15:41:31.531491012 +0200
@@ -1167,11 +1167,8 @@ vmlinux: vmlinux.o $(KBUILD_LDS) modpost
 # make sure no implicit rule kicks in
 $(sort $(KBUILD_LDS) $(KBUILD_VMLINUX_OBJS) $(KBUILD_VMLINUX_LIBS)): . ;
 
-ifeq ($(origin KERNELRELEASE),file)
-filechk_kernel.release = $(srctree)/scripts/setlocalversion $(srctree)
-else
-filechk_kernel.release = echo $(KERNELRELEASE)
-endif
+filechk_kernel.release = \
+	echo "$(KERNELVERSION)$$($(CONFIG_SHELL) $(srctree)/scripts/setlocalversion $(srctree))"
 
 # Store (new) KERNELRELEASE string in include/config/kernel.release
 include/config/kernel.release: FORCE
diff -Naurp a/linux-6.6.38.igel/net/dccp/ipv4.c b/linux-6.6.38.igel/net/dccp/ipv4.c
--- a/linux-6.6.38.igel/net/dccp/ipv4.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/net/dccp/ipv4.c	2024-08-02 15:41:31.567491872 +0200
@@ -1096,8 +1096,12 @@ module_exit(dccp_v4_exit);
  * values directly, Also cover the case where the protocol is not specified,
  * i.e. net-pf-PF_INET-proto-0-type-SOCK_DCCP
  */
+/* gottwald@igel.com : Disable auto loading as mitigation against local exploits.
+ * Patch taken from debian Change some defaults for security reasons */
+#ifndef CONFIG_IGEL_DISABLE_AUTOLOADING_OF_NON_SECURE_NET_MODULES
 MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 33, 6);
 MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET, 0, 6);
+#endif
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Arnaldo Carvalho de Melo <acme@mandriva.com>");
 MODULE_DESCRIPTION("DCCP - Datagram Congestion Controlled Protocol");
diff -Naurp a/linux-6.6.38.igel/net/dccp/ipv6.c b/linux-6.6.38.igel/net/dccp/ipv6.c
--- a/linux-6.6.38.igel/net/dccp/ipv6.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/net/dccp/ipv6.c	2024-08-02 15:41:31.567491872 +0200
@@ -1178,8 +1178,12 @@ module_exit(dccp_v6_exit);
  * values directly, Also cover the case where the protocol is not specified,
  * i.e. net-pf-PF_INET6-proto-0-type-SOCK_DCCP
  */
+/* gottwald@igel.com : Disable auto loading as mitigation against local exploits.
+ * Patch taken from debian Change some defaults for security reasons */
+#ifndef CONFIG_IGEL_DISABLE_AUTOLOADING_OF_NON_SECURE_NET_MODULES
 MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 33, 6);
 MODULE_ALIAS_NET_PF_PROTO_TYPE(PF_INET6, 0, 6);
+#endif
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Arnaldo Carvalho de Melo <acme@mandriva.com>");
 MODULE_DESCRIPTION("DCCPv6 - Datagram Congestion Controlled Protocol");
diff -Naurp a/linux-6.6.38.igel/net/ieee802154/socket.c b/linux-6.6.38.igel/net/ieee802154/socket.c
--- a/linux-6.6.38.igel/net/ieee802154/socket.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/net/ieee802154/socket.c	2024-08-02 15:41:31.567491872 +0200
@@ -1137,4 +1137,8 @@ module_init(af_ieee802154_init);
 module_exit(af_ieee802154_remove);
 
 MODULE_LICENSE("GPL");
+/* gottwald@igel.com : Disable auto loading as mitigation against local exploits.
+ * Patch taken from debian Change some defaults for security reasons */
+#ifndef CONFIG_IGEL_DISABLE_AUTOLOADING_OF_NON_SECURE_NET_MODULES
 MODULE_ALIAS_NETPROTO(PF_IEEE802154);
+#endif
diff -Naurp a/linux-6.6.38.igel/net/rds/af_rds.c b/linux-6.6.38.igel/net/rds/af_rds.c
--- a/linux-6.6.38.igel/net/rds/af_rds.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/net/rds/af_rds.c	2024-08-02 15:41:31.567491872 +0200
@@ -959,4 +959,8 @@ MODULE_DESCRIPTION("RDS: Reliable Datagr
 		   " v" DRV_VERSION " (" DRV_RELDATE ")");
 MODULE_VERSION(DRV_VERSION);
 MODULE_LICENSE("Dual BSD/GPL");
+/* gottwald@igel.com : Disable auto loading as mitigation against local exploits.
+ * Patch taken from debian Change some defaults for security reasons */
+#ifndef CONFIG_IGEL_DISABLE_AUTOLOADING_OF_NON_SECURE_NET_MODULES
 MODULE_ALIAS_NETPROTO(PF_RDS);
+#endif
diff -Naurp a/linux-6.6.38.igel/net/rfkill/rfkill-gpio.c b/linux-6.6.38.igel/net/rfkill/rfkill-gpio.c
--- a/linux-6.6.38.igel/net/rfkill/rfkill-gpio.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/net/rfkill/rfkill-gpio.c	2024-08-02 15:41:31.567491872 +0200
@@ -170,6 +170,11 @@ static int rfkill_gpio_remove(struct pla
 static const struct acpi_device_id rfkill_acpi_match[] = {
 	{ "BCM4752", RFKILL_TYPE_GPS },
 	{ "LNV4752", RFKILL_TYPE_GPS },
+#ifdef CONFIG_IGEL_ADD_RTL8723BS_RFKILL_SWITCH_SUPPORT
+	/* gottwald@igel.com Added RFKILL switch support for realtek rtl8723bs driver
+	 * Patch taken from: https://patchwork.kernel.org/patch/9671285/ */
+	{ "OBDA8723", RFKILL_TYPE_BLUETOOTH },
+#endif
 	{ },
 };
 MODULE_DEVICE_TABLE(acpi, rfkill_acpi_match);
diff -Naurp a/linux-6.6.38.igel/remotes b/linux-6.6.38.igel/remotes
--- a/linux-6.6.38.igel/remotes	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/remotes	2024-08-02 15:41:31.567491872 +0200
@@ -0,0 +1 @@
+linux-stable	git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git
diff -Naurp a/linux-6.6.38.igel/scripts/mkcompile_h b/linux-6.6.38.igel/scripts/mkcompile_h
--- a/linux-6.6.38.igel/scripts/mkcompile_h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/scripts/mkcompile_h	2024-08-02 15:41:31.567491872 +0200
@@ -6,12 +6,12 @@ CC_VERSION="$2"
 LD=$3
 
 if test -z "$KBUILD_BUILD_USER"; then
-	LINUX_COMPILE_BY=$(whoami | sed 's/\\/\\\\/')
+	LINUX_COMPILE_BY="IGEL"
 else
 	LINUX_COMPILE_BY=$KBUILD_BUILD_USER
 fi
 if test -z "$KBUILD_BUILD_HOST"; then
-	LINUX_COMPILE_HOST=`uname -n`
+	LINUX_COMPILE_HOST="ITGA"
 else
 	LINUX_COMPILE_HOST=$KBUILD_BUILD_HOST
 fi
diff -Naurp a/linux-6.6.38.igel/scripts/setlocalversion b/linux-6.6.38.igel/scripts/setlocalversion
--- a/linux-6.6.38.igel/scripts/setlocalversion	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/scripts/setlocalversion	2024-08-02 15:41:31.567491872 +0200
@@ -29,7 +29,7 @@ fi
 if test $# -gt 0 -o ! -d "$srctree"; then
 	usage
 fi
-
+exit 0
 scm_version()
 {
 	local short=false
diff -Naurp a/linux-6.6.38.igel/security/apparmor/af_unix.c b/linux-6.6.38.igel/security/apparmor/af_unix.c
--- a/linux-6.6.38.igel/security/apparmor/af_unix.c	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/security/apparmor/af_unix.c	2024-08-02 15:41:31.571491967 +0200
@@ -0,0 +1,652 @@
+/*
+ * AppArmor security module
+ *
+ * This file contains AppArmor af_unix fine grained mediation
+ *
+ * Copyright 2018 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ */
+
+#include <net/tcp_states.h>
+
+#include "include/audit.h"
+#include "include/af_unix.h"
+#include "include/apparmor.h"
+#include "include/file.h"
+#include "include/label.h"
+#include "include/path.h"
+#include "include/policy.h"
+#include "include/cred.h"
+
+static inline struct sock *aa_unix_sk(struct unix_sock *u)
+{
+	return &u->sk;
+}
+
+static inline int unix_fs_perm(const char *op, u32 mask, struct aa_label *label,
+			       struct unix_sock *u, int flags)
+{
+	AA_BUG(!label);
+	AA_BUG(!u);
+	AA_BUG(!UNIX_FS(aa_unix_sk(u)));
+
+	if (unconfined(label) || !LABEL_MEDIATES(label, AA_CLASS_FILE))
+		return 0;
+
+	mask &= NET_FS_PERMS;
+	if (!u->path.dentry) {
+		struct path_cond cond = { };
+		struct aa_perms perms = { };
+		struct aa_profile *profile;
+
+		/* socket path has been cleared because it is being shutdown
+		 * can only fall back to original sun_path request
+		 */
+		struct aa_sk_ctx *ctx = aa_sock(&u->sk);
+		if (ctx->path.dentry)
+			return aa_path_perm(op, label, &ctx->path, flags, mask,
+					    &cond);
+		return fn_for_each_confined(label, profile,
+			((flags | profile->path_flags) & PATH_MEDIATE_DELETED) ?
+				__aa_path_perm(op, profile,
+					       u->addr->name->sun_path, mask,
+					       &cond, flags, &perms) :
+				aa_audit_file(profile, &nullperms, op, mask,
+					      u->addr->name->sun_path, NULL,
+					      NULL, cond.uid,
+					      "Failed name lookup - "
+					      "deleted entry", -EACCES));
+	} else {
+		/* the sunpath may not be valid for this ns so use the path */
+		struct path_cond cond = { u->path.dentry->d_inode->i_uid,
+					  u->path.dentry->d_inode->i_mode
+		};
+
+		return aa_path_perm(op, label, &u->path, flags, mask, &cond);
+	}
+
+	return 0;
+}
+
+/* passing in state returned by PROFILE_MEDIATES_AF */
+static unsigned int match_to_prot(struct aa_profile *profile,
+				  unsigned int state, int type, int protocol,
+				  const char **info)
+{
+	__be16 buffer[2];
+	buffer[0] = cpu_to_be16(type);
+	buffer[1] = cpu_to_be16(protocol);
+	state = aa_dfa_match_len(profile->policy.dfa, state, (char *) &buffer,
+				 4);
+	if (!state)
+		*info = "failed type and protocol match";
+	return state;
+}
+
+static unsigned int match_addr(struct aa_profile *profile, unsigned int state,
+			       struct sockaddr_un *addr, int addrlen)
+{
+	if (addr)
+		/* include leading \0 */
+		state = aa_dfa_match_len(profile->policy.dfa, state,
+					 addr->sun_path,
+					 unix_addr_len(addrlen));
+	else
+		/* anonymous end point */
+		state = aa_dfa_match_len(profile->policy.dfa, state, "\x01",
+					 1);
+	/* todo change to out of band */
+	state = aa_dfa_null_transition(profile->policy.dfa, state);
+	return state;
+}
+
+static unsigned int match_to_local(struct aa_profile *profile,
+				   unsigned int state, int type, int protocol,
+				   struct sockaddr_un *addr, int addrlen,
+				   const char **info)
+{
+	state = match_to_prot(profile, state, type, protocol, info);
+	if (state) {
+		state = match_addr(profile, state, addr, addrlen);
+		if (state) {
+			/* todo: local label matching */
+			state = aa_dfa_null_transition(profile->policy.dfa,
+						       state);
+			if (!state)
+				*info = "failed local label match";
+		} else
+			*info = "failed local address match";
+	}
+
+	return state;
+}
+
+static unsigned int match_to_sk(struct aa_profile *profile,
+				unsigned int state, struct unix_sock *u,
+				const char **info)
+{
+	struct sockaddr_un *addr = NULL;
+	int addrlen = 0;
+
+	if (u->addr) {
+		addr = u->addr->name;
+		addrlen = u->addr->len;
+	}
+
+	return match_to_local(profile, state, u->sk.sk_type, u->sk.sk_protocol,
+			      addr, addrlen, info);
+}
+
+#define CMD_ADDR	1
+#define CMD_LISTEN	2
+#define CMD_OPT		4
+
+static inline unsigned int match_to_cmd(struct aa_profile *profile,
+					unsigned int state, struct unix_sock *u,
+					char cmd, const char **info)
+{
+	state = match_to_sk(profile, state, u, info);
+	if (state) {
+		state = aa_dfa_match_len(profile->policy.dfa, state, &cmd, 1);
+		if (!state)
+			*info = "failed cmd selection match";
+	}
+
+	return state;
+}
+
+static inline unsigned int match_to_peer(struct aa_profile *profile,
+					 unsigned int state,
+					 struct unix_sock *u,
+					 struct sockaddr_un *peer_addr,
+					 int peer_addrlen,
+					 const char **info)
+{
+	state = match_to_cmd(profile, state, u, CMD_ADDR, info);
+	if (state) {
+		state = match_addr(profile, state, peer_addr, peer_addrlen);
+		if (!state)
+			*info = "failed peer address match";
+	}
+	return state;
+}
+
+static int do_perms(struct aa_profile *profile, unsigned int state, u32 request,
+		    struct common_audit_data *sa)
+{
+	struct aa_perms perms;
+
+	AA_BUG(!profile);
+
+	aa_compute_perms(profile->policy.dfa, state, &perms);
+	aa_apply_modes_to_perms(profile, &perms);
+	return aa_check_perms(profile, &perms, request, sa,
+			      audit_net_cb);
+}
+
+static int match_label(struct aa_profile *profile, struct aa_profile *peer,
+			      unsigned int state, u32 request,
+			      struct common_audit_data *sa)
+{
+	AA_BUG(!profile);
+	AA_BUG(!peer);
+
+	aad(sa)->peer = &peer->label;
+
+	if (state) {
+		state = aa_dfa_match(profile->policy.dfa, state,
+				     peer->base.hname);
+		if (!state)
+			aad(sa)->info = "failed peer label match";
+	}
+	return do_perms(profile, state, request, sa);
+}
+
+
+/* unix sock creation comes before we know if the socket will be an fs
+ * socket
+ * v6 - semantics are handled by mapping in profile load
+ * v7 - semantics require sock create for tasks creating an fs socket.
+ */
+static int profile_create_perm(struct aa_profile *profile, int family,
+			       int type, int protocol)
+{
+	unsigned int state;
+	DEFINE_AUDIT_NET(sa, OP_CREATE, NULL, family, type, protocol);
+
+	AA_BUG(!profile);
+	AA_BUG(profile_unconfined(profile));
+
+	if ((state = PROFILE_MEDIATES_AF(profile, AF_UNIX))) {
+		state = match_to_prot(profile, state, type, protocol,
+				      &aad(&sa)->info);
+		return do_perms(profile, state, AA_MAY_CREATE, &sa);
+	}
+
+	return aa_profile_af_perm(profile, &sa, AA_MAY_CREATE, family, type);
+}
+
+int aa_unix_create_perm(struct aa_label *label, int family, int type,
+			int protocol)
+{
+	struct aa_profile *profile;
+
+	if (unconfined(label))
+		return 0;
+
+	return fn_for_each_confined(label, profile,
+			profile_create_perm(profile, family, type, protocol));
+}
+
+
+static inline int profile_sk_perm(struct aa_profile *profile, const char *op,
+				  u32 request, struct sock *sk)
+{
+	unsigned int state;
+	DEFINE_AUDIT_SK(sa, op, sk);
+
+	AA_BUG(!profile);
+	AA_BUG(!sk);
+	AA_BUG(UNIX_FS(sk));
+	AA_BUG(profile_unconfined(profile));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		state = match_to_sk(profile, state, unix_sk(sk),
+				    &aad(&sa)->info);
+		return do_perms(profile, state, request, &sa);
+	}
+
+	return aa_profile_af_sk_perm(profile, &sa, request, sk);
+}
+
+int aa_unix_label_sk_perm(struct aa_label *label, const char *op, u32 request,
+			  struct sock *sk)
+{
+	struct aa_profile *profile;
+
+	return fn_for_each_confined(label, profile,
+			profile_sk_perm(profile, op, request, sk));
+}
+
+static int unix_label_sock_perm(struct aa_label *label, const char *op, u32 request,
+				struct socket *sock)
+{
+	if (unconfined(label))
+		return 0;
+	if (UNIX_FS(sock->sk))
+		return unix_fs_perm(op, request, label, unix_sk(sock->sk), 0);
+
+	return aa_unix_label_sk_perm(label, op, request, sock->sk);
+}
+
+/* revaliation, get/set attr */
+int aa_unix_sock_perm(const char *op, u32 request, struct socket *sock)
+{
+	struct aa_label *label;
+	int error;
+
+	label = begin_current_label_crit_section();
+	error = unix_label_sock_perm(label, op, request, sock);
+	end_current_label_crit_section(label);
+
+	return error;
+}
+
+static int profile_bind_perm(struct aa_profile *profile, struct sock *sk,
+			     struct sockaddr *addr, int addrlen)
+{
+	unsigned int state;
+	DEFINE_AUDIT_SK(sa, OP_BIND, sk);
+
+	AA_BUG(!profile);
+	AA_BUG(!sk);
+	AA_BUG(addr->sa_family != AF_UNIX);
+	AA_BUG(profile_unconfined(profile));
+	AA_BUG(unix_addr_fs(addr, addrlen));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		/* bind for abstract socket */
+		aad(&sa)->net.addr = unix_addr(addr);
+		aad(&sa)->net.addrlen = addrlen;
+
+		state = match_to_local(profile, state,
+				       sk->sk_type, sk->sk_protocol,
+				       unix_addr(addr), addrlen,
+				       &aad(&sa)->info);
+		return do_perms(profile, state, AA_MAY_BIND, &sa);
+	}
+
+	return aa_profile_af_sk_perm(profile, &sa, AA_MAY_BIND, sk);
+}
+
+int aa_unix_bind_perm(struct socket *sock, struct sockaddr *address,
+		      int addrlen)
+{
+	struct aa_profile *profile;
+	struct aa_label *label;
+	int error = 0;
+
+	 label = begin_current_label_crit_section();
+	 /* fs bind is handled by mknod */
+	if (!(unconfined(label) || unix_addr_fs(address, addrlen)))
+		error = fn_for_each_confined(label, profile,
+				profile_bind_perm(profile, sock->sk, address,
+						  addrlen));
+	end_current_label_crit_section(label);
+
+	return error;
+}
+
+int aa_unix_connect_perm(struct socket *sock, struct sockaddr *address,
+			 int addrlen)
+{
+	/* unix connections are covered by the
+	 * - unix_stream_connect (stream) and unix_may_send hooks (dgram)
+	 * - fs connect is handled by open
+	 */
+	return 0;
+}
+
+static int profile_listen_perm(struct aa_profile *profile, struct sock *sk,
+			       int backlog)
+{
+	unsigned int state;
+	DEFINE_AUDIT_SK(sa, OP_LISTEN, sk);
+
+	AA_BUG(!profile);
+	AA_BUG(!sk);
+	AA_BUG(UNIX_FS(sk));
+	AA_BUG(profile_unconfined(profile));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		__be16 b = cpu_to_be16(backlog);
+
+		state = match_to_cmd(profile, state, unix_sk(sk), CMD_LISTEN,
+				     &aad(&sa)->info);
+		if (state) {
+			state = aa_dfa_match_len(profile->policy.dfa, state,
+						 (char *) &b, 2);
+			if (!state)
+				aad(&sa)->info = "failed listen backlog match";
+		}
+		return do_perms(profile, state, AA_MAY_LISTEN, &sa);
+	}
+
+	return aa_profile_af_sk_perm(profile, &sa, AA_MAY_LISTEN, sk);
+}
+
+int aa_unix_listen_perm(struct socket *sock, int backlog)
+{
+	struct aa_profile *profile;
+	struct aa_label *label;
+	int error = 0;
+
+	label = begin_current_label_crit_section();
+	if (!(unconfined(label) || UNIX_FS(sock->sk)))
+		error = fn_for_each_confined(label, profile,
+				profile_listen_perm(profile, sock->sk,
+						    backlog));
+	end_current_label_crit_section(label);
+
+	return error;
+}
+
+
+static inline int profile_accept_perm(struct aa_profile *profile,
+				      struct sock *sk,
+				      struct sock *newsk)
+{
+	unsigned int state;
+	DEFINE_AUDIT_SK(sa, OP_ACCEPT, sk);
+
+	AA_BUG(!profile);
+	AA_BUG(!sk);
+	AA_BUG(UNIX_FS(sk));
+	AA_BUG(profile_unconfined(profile));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		state = match_to_sk(profile, state, unix_sk(sk),
+				    &aad(&sa)->info);
+		return do_perms(profile, state, AA_MAY_ACCEPT, &sa);
+	}
+
+	return aa_profile_af_sk_perm(profile, &sa, AA_MAY_ACCEPT, sk);
+}
+
+/* ability of sock to connect, not peer address binding */
+int aa_unix_accept_perm(struct socket *sock, struct socket *newsock)
+{
+	struct aa_profile *profile;
+	struct aa_label *label;
+	int error = 0;
+
+	label = begin_current_label_crit_section();
+	if (!(unconfined(label) || UNIX_FS(sock->sk)))
+		error = fn_for_each_confined(label, profile,
+				profile_accept_perm(profile, sock->sk,
+						    newsock->sk));
+	end_current_label_crit_section(label);
+
+	return error;
+}
+
+
+/* dgram handled by unix_may_sendmsg, right to send on stream done at connect
+ * could do per msg unix_stream here
+ */
+/* sendmsg, recvmsg */
+int aa_unix_msg_perm(const char *op, u32 request, struct socket *sock,
+		     struct msghdr *msg, int size)
+{
+	return 0;
+}
+
+
+static int profile_opt_perm(struct aa_profile *profile, const char *op, u32 request,
+			    struct sock *sk, int level, int optname)
+{
+	unsigned int state;
+	DEFINE_AUDIT_SK(sa, op, sk);
+
+	AA_BUG(!profile);
+	AA_BUG(!sk);
+	AA_BUG(UNIX_FS(sk));
+	AA_BUG(profile_unconfined(profile));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		__be16 b = cpu_to_be16(optname);
+
+		state = match_to_cmd(profile, state, unix_sk(sk), CMD_OPT,
+				     &aad(&sa)->info);
+		if (state) {
+			state = aa_dfa_match_len(profile->policy.dfa, state,
+						 (char *) &b, 2);
+			if (!state)
+				aad(&sa)->info = "failed sockopt match";
+		}
+		return do_perms(profile, state, request, &sa);
+	}
+
+	return aa_profile_af_sk_perm(profile, &sa, request, sk);
+}
+
+int aa_unix_opt_perm(const char *op, u32 request, struct socket *sock, int level,
+		     int optname)
+{
+	struct aa_profile *profile;
+	struct aa_label *label;
+	int error = 0;
+
+	label = begin_current_label_crit_section();
+	if (!(unconfined(label) || UNIX_FS(sock->sk)))
+		error = fn_for_each_confined(label, profile,
+				profile_opt_perm(profile, op, request,
+						 sock->sk, level, optname));
+	end_current_label_crit_section(label);
+
+	return error;
+}
+
+/* null peer_label is allowed, in which case the peer_sk label is used */
+static int profile_peer_perm(struct aa_profile *profile, const char *op, u32 request,
+			     struct sock *sk, struct sock *peer_sk,
+			     struct aa_label *peer_label,
+			     struct common_audit_data *sa)
+{
+	unsigned int state;
+
+	AA_BUG(!profile);
+	AA_BUG(profile_unconfined(profile));
+	AA_BUG(!sk);
+	AA_BUG(!peer_sk);
+	AA_BUG(UNIX_FS(peer_sk));
+
+	state = PROFILE_MEDIATES_AF(profile, AF_UNIX);
+	if (state) {
+		struct aa_sk_ctx *peer_ctx = aa_sock(peer_sk);
+		struct aa_profile *peerp;
+		struct sockaddr_un *addr = NULL;
+		int len = 0;
+		if (unix_sk(peer_sk)->addr) {
+			addr = unix_sk(peer_sk)->addr->name;
+			len = unix_sk(peer_sk)->addr->len;
+		}
+		state = match_to_peer(profile, state, unix_sk(sk),
+				      addr, len, &aad(sa)->info);
+		if (!peer_label)
+			peer_label = peer_ctx->label;
+		return fn_for_each_in_ns(peer_label, peerp,
+				   match_label(profile, peerp, state, request,
+					       sa));
+	}
+
+	return aa_profile_af_sk_perm(profile, sa, request, sk);
+}
+
+/**
+ *
+ * Requires: lock held on both @sk and @peer_sk
+ */
+int aa_unix_peer_perm(struct aa_label *label, const char *op, u32 request,
+		      struct sock *sk, struct sock *peer_sk,
+		      struct aa_label *peer_label)
+{
+	struct unix_sock *peeru = unix_sk(peer_sk);
+	struct unix_sock *u = unix_sk(sk);
+
+	AA_BUG(!label);
+	AA_BUG(!sk);
+	AA_BUG(!peer_sk);
+
+	if (UNIX_FS(aa_unix_sk(peeru)))
+		return unix_fs_perm(op, request, label, peeru, 0);
+	else if (UNIX_FS(aa_unix_sk(u)))
+		return unix_fs_perm(op, request, label, u, 0);
+	else {
+		struct aa_profile *profile;
+		DEFINE_AUDIT_SK(sa, op, sk);
+		aad(&sa)->net.peer_sk = peer_sk;
+
+		/* TODO: ns!!! */
+		if (!net_eq(sock_net(sk), sock_net(peer_sk))) {
+			;
+		}
+
+		if (unconfined(label))
+			return 0;
+
+		return fn_for_each_confined(label, profile,
+				profile_peer_perm(profile, op, request, sk,
+						  peer_sk, peer_label, &sa));
+	}
+}
+
+
+/* from net/unix/af_unix.c */
+static void unix_state_double_lock(struct sock *sk1, struct sock *sk2)
+{
+	if (unlikely(sk1 == sk2) || !sk2) {
+		unix_state_lock(sk1);
+		return;
+	}
+	if (sk1 < sk2) {
+		unix_state_lock(sk1);
+		unix_state_lock_nested(sk2);
+	} else {
+		unix_state_lock(sk2);
+		unix_state_lock_nested(sk1);
+	}
+}
+
+static void unix_state_double_unlock(struct sock *sk1, struct sock *sk2)
+{
+	if (unlikely(sk1 == sk2) || !sk2) {
+		unix_state_unlock(sk1);
+		return;
+	}
+	unix_state_unlock(sk1);
+	unix_state_unlock(sk2);
+}
+
+int aa_unix_file_perm(struct aa_label *label, const char *op, u32 request,
+		      struct socket *sock)
+{
+	struct sock *peer_sk = NULL;
+	u32 sk_req = request & ~NET_PEER_MASK;
+	int error = 0;
+
+	AA_BUG(!label);
+	AA_BUG(!sock);
+	AA_BUG(!sock->sk);
+	AA_BUG(sock->sk->sk_family != AF_UNIX);
+
+	/* TODO: update sock label with new task label */
+	unix_state_lock(sock->sk);
+	peer_sk = unix_peer(sock->sk);
+	if (peer_sk)
+		sock_hold(peer_sk);
+	if (!unix_connected(sock) && sk_req) {
+		error = unix_label_sock_perm(label, op, sk_req, sock);
+		if (!error) {
+			// update label
+		}
+	}
+	unix_state_unlock(sock->sk);
+	if (!peer_sk)
+		return error;
+
+	unix_state_double_lock(sock->sk, peer_sk);
+	if (UNIX_FS(sock->sk)) {
+		error = unix_fs_perm(op, request, label, unix_sk(sock->sk),
+				     PATH_SOCK_COND);
+	} else if (UNIX_FS(peer_sk)) {
+		error = unix_fs_perm(op, request, label, unix_sk(peer_sk),
+				     PATH_SOCK_COND);
+	} else {
+		struct aa_sk_ctx *pctx = aa_sock(peer_sk);
+		if (sk_req)
+			error = aa_unix_label_sk_perm(label, op, sk_req,
+						      sock->sk);
+		last_error(error,
+			xcheck(aa_unix_peer_perm(label, op,
+						 MAY_READ | MAY_WRITE,
+						 sock->sk, peer_sk, NULL),
+			       aa_unix_peer_perm(pctx->label, op,
+						 MAY_READ | MAY_WRITE,
+						 peer_sk, sock->sk, label)));
+	}
+
+	unix_state_double_unlock(sock->sk, peer_sk);
+	sock_put(peer_sk);
+
+	return error;
+}
diff -Naurp a/linux-6.6.38.igel/security/apparmor/apparmorfs.c b/linux-6.6.38.igel/security/apparmor/apparmorfs.c
--- a/linux-6.6.38.igel/security/apparmor/apparmorfs.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/apparmorfs.c	2024-08-02 15:41:31.571491967 +0200
@@ -2374,6 +2374,13 @@ static struct aa_sfs_entry aa_sfs_entry_
 	{ }
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct aa_sfs_entry aa_sfs_entry_dbus[] = {
+	AA_SFS_FILE_STRING("mask", "acquire send receive"),
+	{ }
+};
+#endif
+
 static struct aa_sfs_entry aa_sfs_entry_query_label[] = {
 	AA_SFS_FILE_STRING("perms", "allow deny audit quiet"),
 	AA_SFS_FILE_BOOLEAN("data",		1),
@@ -2390,6 +2397,9 @@ static struct aa_sfs_entry aa_sfs_entry_
 	AA_SFS_DIR("domain",			aa_sfs_entry_domain),
 	AA_SFS_DIR("file",			aa_sfs_entry_file),
 	AA_SFS_DIR("network_v8",		aa_sfs_entry_network),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	AA_SFS_DIR("network",			aa_sfs_entry_network_compat),
+#endif
 	AA_SFS_DIR("mount",			aa_sfs_entry_mount),
 	AA_SFS_DIR("namespaces",		aa_sfs_entry_ns),
 	AA_SFS_FILE_U64("capability",		VFS_CAP_FLAGS_MASK),
@@ -2397,6 +2407,9 @@ static struct aa_sfs_entry aa_sfs_entry_
 	AA_SFS_DIR("caps",			aa_sfs_entry_caps),
 	AA_SFS_DIR("ptrace",			aa_sfs_entry_ptrace),
 	AA_SFS_DIR("signal",			aa_sfs_entry_signal),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	AA_SFS_DIR("dbus",			aa_sfs_entry_dbus),
+#endif
 	AA_SFS_DIR("query",			aa_sfs_entry_query),
 	{ }
 };
diff -Naurp a/linux-6.6.38.igel/security/apparmor/crypto.c b/linux-6.6.38.igel/security/apparmor/crypto.c
--- a/linux-6.6.38.igel/security/apparmor/crypto.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/crypto.c	2024-08-02 15:41:31.571491967 +0200
@@ -25,6 +25,27 @@ unsigned int aa_hash_size(void)
 	return apparmor_hash_size;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+void aa_snprint_hashstr(char *out, unsigned char *hash, unsigned int hsize)
+{
+       unsigned int i;
+
+       for (i = 0; i < hsize; i++)
+               sprintf(out + i*2, "%.2x", hash[i]);
+       out[hsize*2] = 0;
+}
+
+char *aa_asprint_hashstr(unsigned char *hash, unsigned int hsize, gfp_t gfp)
+{
+	char *buffer = kmalloc(hsize*2 + 1, gfp);
+	if (!buffer)
+		return NULL;
+	aa_snprint_hashstr(buffer, hash, hsize);
+
+	return buffer;
+}
+#endif
+
 char *aa_calc_hash(void *data, size_t len)
 {
 	SHASH_DESC_ON_STACK(desc, apparmor_tfm);
diff -Naurp a/linux-6.6.38.igel/security/apparmor/file.c b/linux-6.6.38.igel/security/apparmor/file.c
--- a/linux-6.6.38.igel/security/apparmor/file.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/file.c	2024-08-02 15:41:31.571491967 +0200
@@ -14,6 +14,9 @@
 #include <linux/fs.h>
 #include <linux/mount.h>
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include "include/af_unix.h"
+#endif
 #include "include/apparmor.h"
 #include "include/audit.h"
 #include "include/cred.h"
@@ -234,7 +237,12 @@ static int __aa_path_perm(const char *op
 						    typeof(*rules), list);
 	int e = 0;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (profile_unconfined(profile) ||
+	    ((flags & PATH_SOCK_COND) && !PROFILE_MEDIATES_AF(profile, AF_UNIX)))
+#else
 	if (profile_unconfined(profile))
+#endif
 		return 0;
 	aa_str_perms(&(rules->file), rules->file.start[AA_CLASS_FILE],
 		     name, cond, perms);
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/af_unix.h b/linux-6.6.38.igel/security/apparmor/include/af_unix.h
--- a/linux-6.6.38.igel/security/apparmor/include/af_unix.h	1970-01-01 01:00:00.000000000 +0100
+++ b/linux-6.6.38.igel/security/apparmor/include/af_unix.h	2024-08-02 15:41:31.571491967 +0200
@@ -0,0 +1,114 @@
+/*
+ * AppArmor security module
+ *
+ * This file contains AppArmor af_unix fine grained mediation
+ *
+ * Copyright 2014 Canonical Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ */
+#ifndef __AA_AF_UNIX_H
+
+#include <net/af_unix.h>
+
+#include "label.h"
+//#include "include/net.h"
+
+#define unix_addr_len(L) ((L) - sizeof(sa_family_t))
+#define unix_abstract_name_len(L) (unix_addr_len(L) - 1)
+#define unix_abstract_len(U) (unix_abstract_name_len((U)->addr->len))
+#define addr_unix_abstract_name(B) ((B)[0] == 0)
+#define addr_unix_anonymous(U) (addr_unix_len(U) <= 0)
+#define addr_unix_abstract(U) (!addr_unix_anonymous(U) && addr_unix_abstract_name((U)->addr))
+//#define unix_addr_fs(U) (!unix_addr_anonymous(U) && !unix_addr_abstract_name((U)->addr))
+
+#define unix_addr(A) ((struct sockaddr_un *)(A))
+#define unix_addr_anon(A, L) ((A) && unix_addr_len(L) <= 0)
+#define unix_addr_fs(A, L) (!unix_addr_anon(A, L) && !addr_unix_abstract_name(unix_addr(A)->sun_path))
+
+#define UNIX_ANONYMOUS(U) (!unix_sk(U)->addr)
+/* from net/unix/af_unix.c */
+#define UNIX_ABSTRACT(U) (!UNIX_ANONYMOUS(U) &&				\
+			  unix_sk(U)->addr->hash < UNIX_HASH_SIZE)
+#define UNIX_FS(U) (!UNIX_ANONYMOUS(U) && unix_sk(U)->addr->name->sun_path[0])
+#define unix_peer(sk) (unix_sk(sk)->peer)
+#define unix_connected(S) ((S)->state == SS_CONNECTED)
+
+static inline void print_unix_addr(struct sockaddr_un *A, int L)
+{
+	char *buf = (A) ? (char *) &(A)->sun_path : NULL;
+	int len = unix_addr_len(L);
+	if (!buf || len <= 0)
+		printk(" <anonymous>");
+	else if (buf[0])
+		printk(" %s", buf);
+	else
+		/* abstract name len includes leading \0 */
+		printk(" %d @%.*s", len - 1, len - 1, buf+1);
+};
+
+/*
+	printk("%s: %s: f %d, t %d, p %d", __FUNCTION__,		\
+	       #SK ,							\
+*/
+#define print_unix_sk(SK)						\
+do {									\
+	struct unix_sock *u = unix_sk(SK);				\
+	printk("%s: f %d, t %d, p %d",	#SK ,				\
+	       (SK)->sk_family, (SK)->sk_type, (SK)->sk_protocol);	\
+	if (u->addr)							\
+		print_unix_addr(u->addr->name, u->addr->len);		\
+	else								\
+		print_unix_addr(NULL, sizeof(sa_family_t));		\
+	/* printk("\n");*/						\
+} while (0)
+
+#define print_sk(SK)							\
+do {									\
+	if (!(SK)) {							\
+		printk("%s: %s is null\n", __FUNCTION__, #SK);		\
+	} else if ((SK)->sk_family == PF_UNIX) {			\
+		print_unix_sk(SK);					\
+		printk("\n");						\
+	} else {							\
+		printk("%s: %s: family %d\n", __FUNCTION__, #SK ,	\
+		       (SK)->sk_family);				\
+	}								\
+} while (0)
+
+#define print_sock_addr(U) \
+do {			       \
+	printk("%s:\n", __FUNCTION__);					\
+	printk("    sock %s:", sock_ctx && sock_ctx->label ? aa_label_printk(sock_ctx->label, GFP_ATOMIC); : "<null>"); print_sk(sock); \
+	printk("    other %s:", other_ctx && other_ctx->label ? aa_label_printk(other_ctx->label, GFP_ATOMIC); : "<null>"); print_sk(other); \
+	printk("    new %s", new_ctx && new_ctx->label ? aa_label_printk(new_ctx->label, GFP_ATOMIC); : "<null>"); print_sk(newsk); \
+} while (0)
+
+
+
+
+int aa_unix_peer_perm(struct aa_label *label, const char *op, u32 request,
+		      struct sock *sk, struct sock *peer_sk,
+		      struct aa_label *peer_label);
+int aa_unix_label_sk_perm(struct aa_label *label, const char *op, u32 request,
+			  struct sock *sk);
+int aa_unix_sock_perm(const char *op, u32 request, struct socket *sock);
+int aa_unix_create_perm(struct aa_label *label, int family, int type,
+			int protocol);
+int aa_unix_bind_perm(struct socket *sock, struct sockaddr *address,
+		      int addrlen);
+int aa_unix_connect_perm(struct socket *sock, struct sockaddr *address,
+			 int addrlen);
+int aa_unix_listen_perm(struct socket *sock, int backlog);
+int aa_unix_accept_perm(struct socket *sock, struct socket *newsock);
+int aa_unix_msg_perm(const char *op, u32 request, struct socket *sock,
+		     struct msghdr *msg, int size);
+int aa_unix_opt_perm(const char *op, u32 request, struct socket *sock, int level,
+		     int optname);
+int aa_unix_file_perm(struct aa_label *label, const char *op, u32 request,
+		      struct socket *sock);
+
+#endif /* __AA_AF_UNIX_H */
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/apparmor.h b/linux-6.6.38.igel/security/apparmor/include/apparmor.h
--- a/linux-6.6.38.igel/security/apparmor/include/apparmor.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/apparmor.h	2024-08-02 15:41:31.571491967 +0200
@@ -20,7 +20,11 @@
 #define AA_CLASS_UNKNOWN	1
 #define AA_CLASS_FILE		2
 #define AA_CLASS_CAP		3
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#define AA_CLASS_NET_COMPAT	4
+#else
 #define AA_CLASS_DEPRECATED	4
+#endif
 #define AA_CLASS_RLIMITS	5
 #define AA_CLASS_DOMAIN		6
 #define AA_CLASS_MOUNT		7
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/crypto.h b/linux-6.6.38.igel/security/apparmor/include/crypto.h
--- a/linux-6.6.38.igel/security/apparmor/include/crypto.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/crypto.h	2024-08-02 15:41:31.571491967 +0200
@@ -14,6 +14,10 @@
 
 #ifdef CONFIG_SECURITY_APPARMOR_HASH
 unsigned int aa_hash_size(void);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+void aa_snprint_hashstr(char *out, unsigned char *hash, unsigned int hsize);
+char *aa_asprint_hashstr(unsigned char *hash, unsigned int hsize, gfp_t gfp);
+#endif
 char *aa_calc_hash(void *data, size_t len);
 int aa_calc_profile_hash(struct aa_profile *profile, u32 version, void *start,
 			 size_t len);
@@ -32,6 +36,17 @@ static inline unsigned int aa_hash_size(
 {
 	return 0;
 }
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+void aa_snprint_hashstr(char *out, unsigned char *hash, unsigned int hsize)
+{
+}
+
+char *aa_asprint_hashstr(unsigned char *hash, unsigned int hsize, gfp_t gfp);
+{
+	return NULL;
+}
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 #endif
 
 #endif /* __APPARMOR_CRYPTO_H */
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/net.h b/linux-6.6.38.igel/security/apparmor/include/net.h
--- a/linux-6.6.38.igel/security/apparmor/include/net.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/net.h	2024-08-02 15:41:31.571491967 +0200
@@ -49,9 +49,19 @@
 struct aa_sk_ctx {
 	struct aa_label *label;
 	struct aa_label *peer;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct path path;
+#endif
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static inline struct aa_sk_ctx *aa_sock(const struct sock *sk)
+{
+	return sk->sk_security + apparmor_blob_sizes.lbs_sock;
+}
+#else
 #define SK_CTX(X) ((X)->sk_security)
+#endif
 #define SOCK_ctx(X) SOCK_INODE(X)->i_security
 #define DEFINE_AUDIT_NET(NAME, OP, SK, F, T, P)				  \
 	struct lsm_network_audit NAME ## _net = { .sk = (SK),		  \
@@ -69,7 +79,33 @@ struct aa_sk_ctx {
 	DEFINE_AUDIT_NET(NAME, OP, SK, (SK)->sk_family, (SK)->sk_type,	\
 			 (SK)->sk_protocol)
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/* struct aa_net - network confinement data
+ * @allow: basic network families permissions
+ * @audit: which network permissions to force audit
+ * @quiet: which network permissions to quiet rejects
+ */
+struct aa_net_compat {
+	u16 allow[AF_MAX];
+	u16 audit[AF_MAX];
+	u16 quiet[AF_MAX];
+};
+#endif
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#define af_select(FAMILY, FN, DEF_FN)		\
+({						\
+	int __e;				\
+	switch ((FAMILY)) {			\
+	case AF_UNIX:				\
+		__e = aa_unix_ ## FN;		\
+		break;				\
+	default:				\
+		__e = DEF_FN;			\
+	}					\
+	__e;					\
+})
+#else
 #define af_select(FAMILY, FN, DEF_FN)		\
 ({						\
 	int __e;				\
@@ -79,6 +115,7 @@ struct aa_sk_ctx {
 	}					\
 	__e;					\
 })
+#endif
 
 struct aa_secmark {
 	u8 audit;
@@ -88,6 +125,9 @@ struct aa_secmark {
 };
 
 extern struct aa_sfs_entry aa_sfs_entry_network[];
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+extern struct aa_sfs_entry aa_sfs_entry_network_compat[];
+#endif
 
 void audit_net_cb(struct audit_buffer *ab, void *va);
 int aa_profile_af_perm(struct aa_profile *profile,
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/path.h b/linux-6.6.38.igel/security/apparmor/include/path.h
--- a/linux-6.6.38.igel/security/apparmor/include/path.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/path.h	2024-08-02 15:41:31.571491967 +0200
@@ -13,6 +13,9 @@
 
 enum path_flags {
 	PATH_IS_DIR = 0x1,		/* path is a directory */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	PATH_SOCK_COND = 0x2,
+#endif
 	PATH_CONNECT_PATH = 0x4,	/* connect disconnected paths to / */
 	PATH_CHROOT_REL = 0x8,		/* do path lookup relative to chroot */
 	PATH_CHROOT_NSCONNECT = 0x10,	/* connect paths that are at ns root */
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/policy.h b/linux-6.6.38.igel/security/apparmor/include/policy.h
--- a/linux-6.6.38.igel/security/apparmor/include/policy.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/policy.h	2024-08-02 15:41:31.571491967 +0200
@@ -177,6 +177,7 @@ struct aa_attachment {
  * @path_flags: flags controlling path generation behavior
  * @disconnected: what to prepend if attach_disconnected is specified
  * @attach: attachment rules for the profile
+ * @net_compat: v2 compat network controls for the profile
  * @rules: rules to be enforced
  *
  * @dents: dentries for the profiles file entries in apparmorfs
@@ -287,9 +288,19 @@ static inline aa_state_t RULE_MEDIATES_A
 	aa_state_t state = RULE_MEDIATES(rules, AA_CLASS_NET);
 	__be16 be_af = cpu_to_be16(AF);
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (!state) {
+		state = PROFILE_MEDIATES(rules, AA_CLASS_NET_COMPAT);
+		if (!state)
+			return DFA_NOMATCH;
+	}
+	state = aa_dfa_match_len(rules->policy.dfa, state, (char *) &be_af, 2);
+	return state;
+#else
 	if (!state)
 		return DFA_NOMATCH;
 	return aa_dfa_match_len(rules->policy.dfa, state, (char *) &be_af, 2);
+#endif
 }
 
 static inline aa_state_t ANY_RULE_MEDIATES(struct list_head *head,
diff -Naurp a/linux-6.6.38.igel/security/apparmor/include/procattr.h b/linux-6.6.38.igel/security/apparmor/include/procattr.h
--- a/linux-6.6.38.igel/security/apparmor/include/procattr.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/include/procattr.h	2024-08-02 15:41:31.571491967 +0200
@@ -11,7 +11,11 @@
 #ifndef __AA_PROCATTR_H
 #define __AA_PROCATTR_H
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+int aa_getprocattr(struct aa_label *label, char **string, bool newline);
+#else
 int aa_getprocattr(struct aa_label *label, char **string);
+#endif
 int aa_setprocattr_changehat(char *args, size_t size, int flags);
 
 #endif /* __AA_PROCATTR_H */
diff -Naurp a/linux-6.6.38.igel/security/apparmor/label.c b/linux-6.6.38.igel/security/apparmor/label.c
--- a/linux-6.6.38.igel/security/apparmor/label.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/label.c	2024-08-02 15:41:31.571491967 +0200
@@ -1632,6 +1632,12 @@ int aa_label_snxprint(char *str, size_t
 	AA_BUG(!str && size != 0);
 	AA_BUG(!label);
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (AA_DEBUG_LABEL && (flags & FLAG_ABS_ROOT))
+		ns = root_ns;
+	else if (!ns)
+		ns = labels_ns(label);
+#else
 	if (AA_DEBUG_LABEL && (flags & FLAG_ABS_ROOT)) {
 		ns = root_ns;
 		len = snprintf(str, size, "_");
@@ -1639,6 +1645,7 @@ int aa_label_snxprint(char *str, size_t
 	} else if (!ns) {
 		ns = labels_ns(label);
 	}
+#endif
 
 	label_for_each(i, label, profile) {
 		if (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {
diff -Naurp a/linux-6.6.38.igel/security/apparmor/lsm.c b/linux-6.6.38.igel/security/apparmor/lsm.c
--- a/linux-6.6.38.igel/security/apparmor/lsm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/lsm.c	2024-08-02 15:41:31.571491967 +0200
@@ -25,6 +25,9 @@
 #include <net/sock.h>
 #include <uapi/linux/mount.h>
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include "include/af_unix.h"
+#endif
 #include "include/apparmor.h"
 #include "include/apparmorfs.h"
 #include "include/audit.h"
@@ -668,6 +671,9 @@ static int apparmor_getprocattr(struct t
 	const struct cred *cred = get_task_cred(task);
 	struct aa_task_ctx *ctx = task_ctx(current);
 	struct aa_label *label = NULL;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	bool newline = true;
+#endif
 
 	if (strcmp(name, "current") == 0)
 		label = aa_get_newest_label(cred_label(cred));
@@ -675,11 +681,22 @@ static int apparmor_getprocattr(struct t
 		label = aa_get_newest_label(ctx->previous);
 	else if (strcmp(name, "exec") == 0 && ctx->onexec)
 		label = aa_get_newest_label(ctx->onexec);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	else if (strcmp(name, "context") == 0) {
+		label = aa_get_newest_label(cred_label(cred));
+		newline = false;
+	} else
+#else
 	else
+#endif
 		error = -EINVAL;
 
 	if (label)
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		error = aa_getprocattr(label, value, newline);
+#else
 		error = aa_getprocattr(label, value);
+#endif
 
 	aa_put_label(label);
 	put_cred(cred);
@@ -687,6 +704,26 @@ static int apparmor_getprocattr(struct t
 	return error;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static int profile_display_lsm(struct aa_profile *profile,
+			       struct common_audit_data *sa)
+{
+	struct aa_perms perms = { };
+	unsigned int state;
+
+	state = PROFILE_MEDIATES(profile, AA_CLASS_DISPLAY_LSM);
+	if (state) {
+		aa_compute_perms(profile->policy.dfa, state, &perms);
+		aa_apply_modes_to_perms(profile, &perms);
+		aad(sa)->label = &profile->label;
+
+		return aa_check_perms(profile, &perms, AA_MAY_WRITE, sa, NULL);
+	}
+
+	return 0;
+}
+#endif
+
 static int apparmor_setprocattr(const char *name, void *value,
 				size_t size)
 {
@@ -699,6 +736,21 @@ static int apparmor_setprocattr(const ch
 	if (size == 0)
 		return -EINVAL;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	/* LSM infrastructure does actual setting of display if allowed */
+	if (!strcmp(name, "display")) {
+		struct aa_profile *profile;
+		struct aa_label *label;
+
+		aad(&sa)->info = "set display lsm";
+		label = begin_current_label_crit_section();
+		error = fn_for_each_confined(label, profile,
+					     profile_display_lsm(profile, &sa));
+		end_current_label_crit_section(label);
+		return error;
+	}
+#endif
+
 	/* AppArmor requires that the buffer must be null terminated atm */
 	if (args[size - 1] != '\0') {
 		/* null terminate */
@@ -850,6 +902,7 @@ static int apparmor_task_kill(struct tas
 	return error;
 }
 
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 /**
  * apparmor_sk_alloc_security - allocate and attach the sk_security field
  */
@@ -865,18 +918,27 @@ static int apparmor_sk_alloc_security(st
 
 	return 0;
 }
+#endif
 
 /**
  * apparmor_sk_free_security - free the sk_security field
  */
 static void apparmor_sk_free_security(struct sock *sk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+
+	aa_put_label(ctx->label);
+	aa_put_label(ctx->peer);
+	path_put(&ctx->path);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
 
 	SK_CTX(sk) = NULL;
 	aa_put_label(ctx->label);
 	aa_put_label(ctx->peer);
 	kfree(ctx);
+#endif
 }
 
 /**
@@ -885,8 +947,13 @@ static void apparmor_sk_free_security(st
 static void apparmor_sk_clone_security(const struct sock *sk,
 				       struct sock *newsk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+	struct aa_sk_ctx *new = aa_sock(newsk);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
 	struct aa_sk_ctx *new = SK_CTX(newsk);
+#endif
 
 	if (new->label)
 		aa_put_label(new->label);
@@ -895,9 +962,106 @@ static void apparmor_sk_clone_security(c
 	if (new->peer)
 		aa_put_label(new->peer);
 	new->peer = aa_get_label(ctx->peer);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	new->path = ctx->path;
+	path_get(&new->path);
+#endif
+}
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct path *UNIX_FS_CONN_PATH(struct sock *sk, struct sock *newsk)
+{
+	if (sk->sk_family == PF_UNIX && UNIX_FS(sk))
+		return &unix_sk(sk)->path;
+	else if (newsk->sk_family == PF_UNIX && UNIX_FS(newsk))
+		return &unix_sk(newsk)->path;
+	return NULL;
+}
+
+/**
+ * apparmor_unix_stream_connect - check perms before making unix domain conn
+ *
+ * peer is locked when this hook is called
+ */
+static int apparmor_unix_stream_connect(struct sock *sk, struct sock *peer_sk,
+					struct sock *newsk)
+{
+	struct aa_sk_ctx *sk_ctx = aa_sock(sk);
+	struct aa_sk_ctx *peer_ctx = aa_sock(peer_sk);
+	struct aa_sk_ctx *new_ctx = aa_sock(newsk);
+	struct aa_label *label;
+	struct path *path;
+	int error;
+
+	label = __begin_current_label_crit_section();
+	error = aa_unix_peer_perm(label, OP_CONNECT,
+				(AA_MAY_CONNECT | AA_MAY_SEND | AA_MAY_RECEIVE),
+				  sk, peer_sk, NULL);
+	if (!UNIX_FS(peer_sk)) {
+		last_error(error,
+			aa_unix_peer_perm(peer_ctx->label, OP_CONNECT,
+				(AA_MAY_ACCEPT | AA_MAY_SEND | AA_MAY_RECEIVE),
+				peer_sk, sk, label));
+	}
+	__end_current_label_crit_section(label);
+
+	if (error)
+		return error;
+
+	/* label newsk if it wasn't labeled in post_create. Normally this
+	 * would be done in sock_graft, but because we are directly looking
+	 * at the peer_sk to obtain peer_labeling for unix socks this
+	 * does not work
+	 */
+	if (!new_ctx->label)
+		new_ctx->label = aa_get_label(peer_ctx->label);
+
+	/* Cross reference the peer labels for SO_PEERSEC */
+	if (new_ctx->peer)
+		aa_put_label(new_ctx->peer);
+
+	if (sk_ctx->peer)
+		aa_put_label(sk_ctx->peer);
+
+	new_ctx->peer = aa_get_label(sk_ctx->label);
+	sk_ctx->peer = aa_get_label(peer_ctx->label);
+
+	path = UNIX_FS_CONN_PATH(sk, peer_sk);
+	if (path) {
+		new_ctx->path = *path;
+		sk_ctx->path = *path;
+		path_get(path);
+		path_get(path);
+	}
+	return 0;
 }
 
 /**
+ * apparmor_unix_may_send - check perms before conn or sending unix dgrams
+ *
+ * other is locked when this hook is called
+ *
+ * dgram connect calls may_send, peer setup but path not copied?????
+ */
+static int apparmor_unix_may_send(struct socket *sock, struct socket *peer)
+{
+	struct aa_sk_ctx *peer_ctx = aa_sock(peer->sk);
+	struct aa_label *label;
+	int error;
+
+	label = __begin_current_label_crit_section();
+	error = xcheck(aa_unix_peer_perm(label, OP_SENDMSG, AA_MAY_SEND,
+					 sock->sk, peer->sk, NULL),
+		       aa_unix_peer_perm(peer_ctx->label, OP_SENDMSG,
+					 AA_MAY_RECEIVE,
+					 peer->sk, sock->sk, label));
+	__end_current_label_crit_section(label);
+
+	return error;
+}
+#endif
+
+/**
  * apparmor_socket_create - check perms before creating a new socket
  */
 static int apparmor_socket_create(int family, int type, int protocol, int kern)
@@ -940,7 +1104,11 @@ static int apparmor_socket_post_create(s
 		label = aa_get_current_label();
 
 	if (sock->sk) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		struct aa_sk_ctx *ctx = aa_sock(sock->sk);
+#else
 		struct aa_sk_ctx *ctx = SK_CTX(sock->sk);
+#endif
 
 		aa_put_label(ctx->label);
 		ctx->label = aa_get_label(label);
@@ -1125,7 +1293,11 @@ static int apparmor_socket_shutdown(stru
  */
 static int apparmor_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+#endif
 
 	if (!skb->secmark)
 		return 0;
@@ -1138,12 +1310,37 @@ static int apparmor_socket_sock_rcv_skb(
 
 static struct aa_label *sk_peer_label(struct sock *sk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sock *peer_sk;
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+	struct aa_label *label = ERR_PTR(-ENOPROTOOPT);
+
+	if (ctx->peer)
+		return aa_get_label(ctx->peer);
+
+	if (sk->sk_family != PF_UNIX)
+		return ERR_PTR(-ENOPROTOOPT);
+
+	/* check for sockpair peering which does not go through
+	 * security_unix_stream_connect
+	 */
+	peer_sk = unix_peer_get(sk);
+	if (peer_sk) {
+		ctx = aa_sock(peer_sk);
+		if (ctx->label)
+			label = aa_get_label(ctx->label);
+		sock_put(peer_sk);
+	}
+
+	return label;
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
 
 	if (ctx->peer)
 		return ctx->peer;
 
 	return ERR_PTR(-ENOPROTOOPT);
+#endif
 }
 
 /**
@@ -1181,6 +1378,10 @@ static int apparmor_socket_getpeersec_st
 
 	if (copy_to_sockptr(optval, name, slen))
 		error = -EFAULT;
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	aa_put_label(peer);
+#endif
 done_len:
 	if (copy_to_sockptr(optlen, &slen, sizeof(slen)))
 		error = -EFAULT;
@@ -1190,6 +1391,7 @@ done:
 	return error;
 }
 
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 /**
  * apparmor_socket_getpeersec_dgram - get security label of packet
  * @sock: the peer socket
@@ -1205,6 +1407,7 @@ static int apparmor_socket_getpeersec_dg
 	/* TODO: requires secid support */
 	return -ENOPROTOOPT;
 }
+#endif
 
 /**
  * apparmor_sock_graft - Initialize newly created socket
@@ -1219,7 +1422,11 @@ static int apparmor_socket_getpeersec_dg
  */
 static void apparmor_sock_graft(struct sock *sk, struct socket *parent)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+#endif
 
 	if (!ctx->label)
 		ctx->label = aa_get_current_label();
@@ -1229,7 +1436,11 @@ static void apparmor_sock_graft(struct s
 static int apparmor_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				      struct request_sock *req)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+#endif
 
 	if (!skb->secmark)
 		return 0;
@@ -1246,8 +1457,18 @@ struct lsm_blob_sizes apparmor_blob_size
 	.lbs_cred = sizeof(struct aa_label *),
 	.lbs_file = sizeof(struct aa_file_ctx),
 	.lbs_task = sizeof(struct aa_task_ctx),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	.lbs_sock = sizeof(struct aa_sk_ctx),
+#endif
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id apparmor_lsmid __lsm_ro_after_init = {
+	.lsm  = "apparmor",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 static struct security_hook_list apparmor_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, apparmor_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, apparmor_ptrace_traceme),
@@ -1284,10 +1505,17 @@ static struct security_hook_list apparmo
 	LSM_HOOK_INIT(getprocattr, apparmor_getprocattr),
 	LSM_HOOK_INIT(setprocattr, apparmor_setprocattr),
 
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 	LSM_HOOK_INIT(sk_alloc_security, apparmor_sk_alloc_security),
+#endif
 	LSM_HOOK_INIT(sk_free_security, apparmor_sk_free_security),
 	LSM_HOOK_INIT(sk_clone_security, apparmor_sk_clone_security),
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	LSM_HOOK_INIT(unix_stream_connect, apparmor_unix_stream_connect),
+	LSM_HOOK_INIT(unix_may_send, apparmor_unix_may_send),
+#endif
+
 	LSM_HOOK_INIT(socket_create, apparmor_socket_create),
 	LSM_HOOK_INIT(socket_post_create, apparmor_socket_post_create),
 	LSM_HOOK_INIT(socket_bind, apparmor_socket_bind),
@@ -1306,8 +1534,10 @@ static struct security_hook_list apparmo
 #endif
 	LSM_HOOK_INIT(socket_getpeersec_stream,
 		      apparmor_socket_getpeersec_stream),
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 	LSM_HOOK_INIT(socket_getpeersec_dgram,
 		      apparmor_socket_getpeersec_dgram),
+#endif
 	LSM_HOOK_INIT(sock_graft, apparmor_sock_graft),
 #ifdef CONFIG_NETWORK_SECMARK
 	LSM_HOOK_INIT(inet_conn_request, apparmor_inet_conn_request),
@@ -1843,7 +2073,11 @@ static unsigned int apparmor_ip_postrout
 	if (sk == NULL)
 		return NF_ACCEPT;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	ctx = aa_sock(sk);
+#else
 	ctx = SK_CTX(sk);
+#endif
 	if (!apparmor_secmark_check(ctx->label, OP_SENDMSG, AA_MAY_SEND,
 				    skb->secmark, sk))
 		return NF_ACCEPT;
@@ -1937,8 +2171,13 @@ static int __init apparmor_init(void)
 		aa_free_root_ns();
 		goto buffers_out;
 	}
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),
+				&apparmor_lsmid);
+#else
 	security_add_hooks(apparmor_hooks, ARRAY_SIZE(apparmor_hooks),
 				"apparmor");
+#endif
 
 	/* Report that AppArmor successfully initialized */
 	apparmor_initialized = 1;
@@ -1963,7 +2202,11 @@ alloc_out:
 
 DEFINE_LSM(apparmor) = {
 	.name = "apparmor",
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	.flags = LSM_FLAG_LEGACY_MAJOR,
+#else
 	.flags = LSM_FLAG_LEGACY_MAJOR | LSM_FLAG_EXCLUSIVE,
+#endif
 	.enabled = &apparmor_enabled,
 	.blobs = &apparmor_blob_sizes,
 	.init = apparmor_init,
diff -Naurp a/linux-6.6.38.igel/security/apparmor/Makefile b/linux-6.6.38.igel/security/apparmor/Makefile
--- a/linux-6.6.38.igel/security/apparmor/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/Makefile	2024-08-02 15:41:31.567491872 +0200
@@ -7,6 +7,7 @@ apparmor-y := apparmorfs.o audit.o capab
               path.o domain.o policy.o policy_unpack.o procattr.o lsm.o \
               resource.o secid.o file.o policy_ns.o label.o mount.o net.o \
               policy_compat.o
+apparmor-$(CONFIG_IGEL_APPARMOR_DBUS_SUPPORT) += af_unix.o
 apparmor-$(CONFIG_SECURITY_APPARMOR_HASH) += crypto.o
 
 obj-$(CONFIG_SECURITY_APPARMOR_KUNIT_TEST) += apparmor_policy_unpack_test.o
diff -Naurp a/linux-6.6.38.igel/security/apparmor/net.c b/linux-6.6.38.igel/security/apparmor/net.c
--- a/linux-6.6.38.igel/security/apparmor/net.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/net.c	2024-08-02 15:41:31.571491967 +0200
@@ -8,6 +8,9 @@
  * Copyright 2009-2017 Canonical Ltd.
  */
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include "include/af_unix.h"
+#endif
 #include "include/apparmor.h"
 #include "include/audit.h"
 #include "include/cred.h"
@@ -24,6 +27,14 @@ struct aa_sfs_entry aa_sfs_entry_network
 	{ }
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+struct aa_sfs_entry aa_sfs_entry_network_compat[] = {
+	AA_SFS_FILE_STRING("af_mask",	AA_SFS_AF_MASK),
+	AA_SFS_FILE_BOOLEAN("af_unix",	1),
+	{ }
+};
+#endif
+
 static const char * const net_mask_names[] = {
 	"unknown",
 	"send",
@@ -66,6 +77,38 @@ static const char * const net_mask_names
 	"unknown",
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static void audit_unix_addr(struct audit_buffer *ab, const char *str,
+			    struct sockaddr_un *addr, int addrlen)
+{
+	int len = unix_addr_len(addrlen);
+
+	if (!addr || len <= 0) {
+		audit_log_format(ab, " %s=none", str);
+	} else if (addr->sun_path[0]) {
+		audit_log_format(ab, " %s=", str);
+		audit_log_untrustedstring(ab, addr->sun_path);
+	} else {
+		audit_log_format(ab, " %s=\"@", str);
+		if (audit_string_contains_control(&addr->sun_path[1], len - 1))
+			audit_log_n_hex(ab, &addr->sun_path[1], len - 1);
+		else
+			audit_log_format(ab, "%.*s", len - 1,
+					 &addr->sun_path[1]);
+		audit_log_format(ab, "\"");
+	}
+}
+
+static void audit_unix_sk_addr(struct audit_buffer *ab, const char *str,
+			       const struct sock *sk)
+{
+	struct unix_sock *u = unix_sk(sk);
+	if (u && u->addr)
+		audit_unix_addr(ab, str, u->addr->name, u->addr->len);
+	else
+		audit_unix_addr(ab, str, NULL, 0);
+}
+#endif
 
 /* audit callback for net specific fields */
 void audit_net_cb(struct audit_buffer *ab, void *va)
@@ -98,6 +141,25 @@ void audit_net_cb(struct audit_buffer *a
 					   net_mask_names, NET_PERMS_MASK);
 		}
 	}
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (sa->u.net->family == AF_UNIX) {
+		if ((ad->request & ~NET_PEER_MASK) && ad->net.addr)
+			audit_unix_addr(ab, "addr",
+					unix_addr(ad->net.addr),
+					ad->net.addrlen);
+		else
+			audit_unix_sk_addr(ab, "addr", sa->u.net->sk);
+		if (ad->request & NET_PEER_MASK) {
+			if (ad->net.addr)
+				audit_unix_addr(ab, "peer_addr",
+						unix_addr(ad->net.addr),
+						ad->net.addrlen);
+			else
+				audit_unix_sk_addr(ab, "peer_addr",
+						   ad->net.peer_sk);
+		}
+	}
+#endif
 	if (ad->peer) {
 		audit_log_format(ab, " peer=");
 		aa_label_xaudit(ab, labels_ns(ad->subj_label), ad->peer,
@@ -122,6 +184,26 @@ int aa_profile_af_perm(struct aa_profile
 	if (profile_unconfined(profile))
 		return 0;
 	state = RULE_MEDIATES(rules, AA_CLASS_NET);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (state) {
+		buffer[0] = cpu_to_be16(family);
+		buffer[1] = cpu_to_be16((u16) type);
+		state = aa_dfa_match_len(profile->policy.dfa, state,
+					 (char *) &buffer, 4);
+		perms = *aa_lookup_perms(&rules->policy, state);
+	} else if (profile->net_compat) {
+		/* 2.x socket mediation compat */
+		perms.allow = (profile->net_compat->allow[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+		perms.audit = (profile->net_compat->audit[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+		perms.quiet = (profile->net_compat->quiet[family] & (1 << type)) ?
+			ALL_PERMS_MASK : 0;
+
+	} else {
+		return 0;
+	}
+#else
 	if (!state)
 		return 0;
 
@@ -130,6 +212,7 @@ int aa_profile_af_perm(struct aa_profile
 	state = aa_dfa_match_len(rules->policy.dfa, state, (char *) &buffer,
 				 4);
 	perms = *aa_lookup_perms(&rules->policy, state);
+#endif
 	aa_apply_modes_to_perms(profile, &perms);
 
 	return aa_check_perms(profile, &perms, request, ad, audit_net_cb);
@@ -151,7 +234,11 @@ static int aa_label_sk_perm(const struct
 			    const char *op, u32 request,
 			    struct sock *sk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct aa_sk_ctx *ctx = aa_sock(sk);
+#else
 	struct aa_sk_ctx *ctx = SK_CTX(sk);
+#endif
 	int error = 0;
 
 	AA_BUG(!label);
@@ -193,7 +280,13 @@ int aa_sock_file_perm(const struct cred
 	AA_BUG(!sock);
 	AA_BUG(!sock->sk);
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	return af_select(sock->sk->sk_family,
+			 file_perm(label, op, request, sock),
+			 aa_label_sk_perm(subj_cred, label, op, request, sock->sk));
+#else
 	return aa_label_sk_perm(subj_cred, label, op, request, sock->sk);
+#endif
 }
 
 #ifdef CONFIG_NETWORK_SECMARK
diff -Naurp a/linux-6.6.38.igel/security/apparmor/policy.c b/linux-6.6.38.igel/security/apparmor/policy.c
--- a/linux-6.6.38.igel/security/apparmor/policy.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/policy.c	2024-08-02 15:41:31.571491967 +0200
@@ -258,6 +258,9 @@ void aa_free_profile(struct aa_profile *
 	kfree_sensitive(profile->disconnected);
 
 	free_attachment(&profile->attach);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	kfree_sensitive(profile->net_compat);
+#endif
 
 	/*
 	 * at this point there are no tasks that can have a reference
diff -Naurp a/linux-6.6.38.igel/security/apparmor/policy_unpack.c b/linux-6.6.38.igel/security/apparmor/policy_unpack.c
--- a/linux-6.6.38.igel/security/apparmor/policy_unpack.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/policy_unpack.c	2024-08-02 15:41:31.571491967 +0200
@@ -270,6 +270,21 @@ fail:
 	return false;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static bool unpack_u16(struct aa_ext *e, u16 *data, const char *name)
+{
+	if (unpack_nameX(e, AA_U16, name)) {
+		if (!inbounds(e, sizeof(u16)))
+			return 0;
+		if (data)
+			*data = le16_to_cpu(get_unaligned((__le16 *) e->pos));
+		e->pos += sizeof(u16);
+		return 1;
+	}
+	return 0;
+}
+#endif
+
 VISIBLE_IF_KUNIT bool aa_unpack_u32(struct aa_ext *e, u32 *data, const char *name)
 {
 	void *pos = e->pos;
@@ -805,7 +820,11 @@ static struct aa_profile *unpack_profile
 	struct aa_profile *profile = NULL;
 	const char *tmpname, *tmpns = NULL, *name = NULL;
 	const char *info = "failed to unpack profile";
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	size_t size = 0, ns_len;
+#else
 	size_t ns_len;
+#endif
 	struct rhashtable_params params = { 0 };
 	char *key = NULL, *disconnected = NULL;
 	struct aa_data *data;
@@ -977,6 +996,44 @@ static struct aa_profile *unpack_profile
 		goto fail;
 	}
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	size = unpack_array(e, "net_allowed_af");
+	if (size || VERSION_LT(e->version, v8)) {
+		profile->net_compat = kzalloc(sizeof(struct aa_net_compat), GFP_KERNEL);
+		if (!profile->net_compat) {
+			info = "out of memory";
+			goto fail;
+		}
+		for (i = 0; i < size; i++) {
+			/* discard extraneous rules that this kernel will
+			 * never request
+			 */
+			if (i >= AF_MAX) {
+				u16 tmp;
+
+				if (!unpack_u16(e, &tmp, NULL) ||
+				    !unpack_u16(e, &tmp, NULL) ||
+				    !unpack_u16(e, &tmp, NULL))
+					goto fail;
+				continue;
+			}
+			if (!unpack_u16(e, &profile->net_compat->allow[i], NULL))
+				goto fail;
+			if (!unpack_u16(e, &profile->net_compat->audit[i], NULL))
+				goto fail;
+			if (!unpack_u16(e, &profile->net_compat->quiet[i], NULL))
+				goto fail;
+		}
+		if (size && !aa_unpack_nameX(e, AA_ARRAYEND, NULL))
+			goto fail;
+		if (VERSION_LT(e->version, v7)) {
+			/* pre v7 policy always allowed these */
+			profile->net_compat->allow[AF_UNIX] = 0xffff;
+			profile->net_compat->allow[AF_NETLINK] = 0xffff;
+		}
+	}
+#endif
+
 	if (aa_unpack_nameX(e, AA_STRUCT, "policydb")) {
 		/* generic policy dfa - optional and may be NULL */
 		info = "failed to unpack policydb";
diff -Naurp a/linux-6.6.38.igel/security/apparmor/procattr.c b/linux-6.6.38.igel/security/apparmor/procattr.c
--- a/linux-6.6.38.igel/security/apparmor/procattr.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/apparmor/procattr.c	2024-08-02 15:41:31.571491967 +0200
@@ -16,6 +16,60 @@
 #include "include/procattr.h"
 
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * aa_getprocattr - Return the profile information for @profile
+ * @profile: the profile to print profile info about  (NOT NULL)
+ * @string: Returns - string containing the profile info (NOT NULL)
+ * @newline: Should a newline be added to @string.
+ *
+ * Returns: length of @string on success else error on failure
+ *
+ * Requires: profile != NULL
+ *
+ * Creates a string containing the namespace_name://profile_name for
+ * @profile.
+ *
+ * Returns: size of string placed in @string else error code on failure
+ */
+int aa_getprocattr(struct aa_label *label, char **string, bool newline)
+{
+	struct aa_ns *ns = labels_ns(label);
+	struct aa_ns *current_ns = aa_get_current_ns();
+	int flags = FLAG_VIEW_SUBNS | FLAG_HIDDEN_UNCONFINED;
+	int len;
+
+	if (!aa_ns_visible(current_ns, ns, true)) {
+		aa_put_ns(current_ns);
+		return -EACCES;
+	}
+	if (newline)
+		flags |= FLAG_SHOW_MODE;
+
+	len = aa_label_snxprint(NULL, 0, current_ns, label, flags);
+	AA_BUG(len < 0);
+
+	*string = kmalloc(len + 2, GFP_KERNEL);
+	if (!*string) {
+		aa_put_ns(current_ns);
+		return -ENOMEM;
+	}
+
+	len = aa_label_snxprint(*string, len + 2, current_ns, label, flags);
+	if (len < 0) {
+		aa_put_ns(current_ns);
+		return len;
+	}
+
+	if (newline) {
+		(*string)[len] = '\n';
+		(*string)[++len] = 0;
+	}
+
+	aa_put_ns(current_ns);
+	return len;
+}
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * aa_getprocattr - Return the label information for @label
  * @label: the label to print label info about  (NOT NULL)
@@ -63,6 +117,7 @@ int aa_getprocattr(struct aa_label *labe
 	aa_put_ns(current_ns);
 	return len + 1;
 }
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 
 /**
  * split_token_from_name - separate a string of form  <token>^<name>
diff -Naurp a/linux-6.6.38.igel/security/bpf/hooks.c b/linux-6.6.38.igel/security/bpf/hooks.c
--- a/linux-6.6.38.igel/security/bpf/hooks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/bpf/hooks.c	2024-08-02 15:41:31.571491967 +0200
@@ -15,9 +15,25 @@ static struct security_hook_list bpf_lsm
 	LSM_HOOK_INIT(task_free, bpf_task_storage_free),
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/*
+ * slot has to be LSMBLOB_NEEDED because some of the hooks
+ * supplied by this module require a slot.
+ */
+struct lsm_id bpf_lsmid __lsm_ro_after_init = {
+	.lsm = "bpf",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 static int __init bpf_lsm_init(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(bpf_lsm_hooks, ARRAY_SIZE(bpf_lsm_hooks),
+			   &bpf_lsmid);
+#else
 	security_add_hooks(bpf_lsm_hooks, ARRAY_SIZE(bpf_lsm_hooks), "bpf");
+#endif
 	pr_info("LSM support for eBPF active\n");
 	return 0;
 }
diff -Naurp a/linux-6.6.38.igel/security/commoncap.c b/linux-6.6.38.igel/security/commoncap.c
--- a/linux-6.6.38.igel/security/commoncap.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/commoncap.c	2024-08-02 15:41:31.571491967 +0200
@@ -1440,6 +1440,13 @@ int cap_mmap_file(struct file *file, uns
 
 #ifdef CONFIG_SECURITY
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id capability_lsmid __lsm_ro_after_init = {
+	.lsm  = "capability",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 static struct security_hook_list capability_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(capable, cap_capable),
 	LSM_HOOK_INIT(settime, cap_settime),
@@ -1463,8 +1470,13 @@ static struct security_hook_list capabil
 
 static int __init capability_init(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),
+			   &capability_lsmid);
+#else
 	security_add_hooks(capability_hooks, ARRAY_SIZE(capability_hooks),
 				"capability");
+#endif
 	return 0;
 }
 
diff -Naurp a/linux-6.6.38.igel/security/integrity/ima/ima_policy.c b/linux-6.6.38.igel/security/integrity/ima/ima_policy.c
--- a/linux-6.6.38.igel/security/integrity/ima/ima_policy.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/integrity/ima/ima_policy.c	2024-08-02 15:41:31.571491967 +0200
@@ -114,7 +114,11 @@ struct ima_rule_entry {
 	int pcr;
 	unsigned int allowed_algos; /* bitfield of allowed hash algorithms */
 	struct {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		void *rules[LSMBLOB_ENTRIES]; /* LSM file metadata specific */
+#else
 		void *rule;	/* LSM file metadata specific */
+#endif
 		char *args_p;	/* audit value */
 		int type;	/* audit type */
 	} lsm[MAX_LSM_RULES];
@@ -124,6 +128,24 @@ struct ima_rule_entry {
 	struct ima_template_desc *template;
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * ima_lsm_isset - Is a rule set for any of the active security modules
+ * @rules: The set of IMA rules to check.
+ *
+ * If a rule is set for any LSM return true, otherwise return false.
+ */
+static inline bool ima_lsm_isset(void *rules[])
+{
+	int i;
+
+	for (i = 0; i < LSMBLOB_ENTRIES; i++)
+		if (rules[i])
+			return true;
+	return false;
+}
+#endif
+
 /*
  * sanity check in case the kernels gains more hash algorithms that can
  * fit in an unsigned int
@@ -378,9 +400,17 @@ static void ima_free_rule_opt_list(struc
 static void ima_lsm_free_rule(struct ima_rule_entry *entry)
 {
 	int i;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int r;
+#endif
 
 	for (i = 0; i < MAX_LSM_RULES; i++) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		for (r = 0; r < LSMBLOB_ENTRIES; r++)
+			ima_filter_rule_free(entry->lsm[i].rules);
+#else
 		ima_filter_rule_free(entry->lsm[i].rule);
+#endif
 		kfree(entry->lsm[i].args_p);
 	}
 }
@@ -423,10 +453,17 @@ static struct ima_rule_entry *ima_lsm_co
 		nentry->lsm[i].type = entry->lsm[i].type;
 		nentry->lsm[i].args_p = entry->lsm[i].args_p;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		ima_filter_rule_init(nentry->lsm[i].type, Audit_equal,
+				     nentry->lsm[i].args_p,
+				     &nentry->lsm[i].rules[0]);
+		if (!ima_lsm_isset(nentry->lsm[i].rules))
+#else
 		ima_filter_rule_init(nentry->lsm[i].type, Audit_equal,
 				     nentry->lsm[i].args_p,
 				     &nentry->lsm[i].rule);
 		if (!nentry->lsm[i].rule)
+#endif
 			pr_warn("rule for LSM \'%s\' is undefined\n",
 				nentry->lsm[i].args_p);
 	}
@@ -635,7 +672,11 @@ static bool ima_match_rules(struct ima_r
 		int rc = 0;
 		u32 osid;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		if (!ima_lsm_isset(lsm_rule->lsm[i].rules)) {
+#else
 		if (!lsm_rule->lsm[i].rule) {
+#endif
 			if (!lsm_rule->lsm[i].args_p)
 				continue;
 			else
@@ -648,16 +689,28 @@ retry:
 		case LSM_OBJ_ROLE:
 		case LSM_OBJ_TYPE:
 			security_inode_getsecid(inode, &osid);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			rc = ima_filter_rule_match(osid, lsm_rule->lsm[i].type,
+						   Audit_equal,
+						   lsm_rule->lsm[i].rules);
+#else
 			rc = ima_filter_rule_match(osid, lsm_rule->lsm[i].type,
 						   Audit_equal,
 						   lsm_rule->lsm[i].rule);
+#endif
 			break;
 		case LSM_SUBJ_USER:
 		case LSM_SUBJ_ROLE:
 		case LSM_SUBJ_TYPE:
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			rc = ima_filter_rule_match(secid, lsm_rule->lsm[i].type,
+						   Audit_equal,
+						   lsm_rule->lsm[i].rules);
+#else
 			rc = ima_filter_rule_match(secid, lsm_rule->lsm[i].type,
 						   Audit_equal,
 						   lsm_rule->lsm[i].rule);
+#endif
 			break;
 		default:
 			break;
@@ -1130,7 +1183,11 @@ static int ima_lsm_rule_init(struct ima_
 {
 	int result;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (ima_lsm_isset(entry->lsm[lsm_rule].rules))
+#else
 	if (entry->lsm[lsm_rule].rule)
+#endif
 		return -EINVAL;
 
 	entry->lsm[lsm_rule].args_p = match_strdup(args);
@@ -1138,10 +1195,17 @@ static int ima_lsm_rule_init(struct ima_
 		return -ENOMEM;
 
 	entry->lsm[lsm_rule].type = audit_type;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	result = ima_filter_rule_init(entry->lsm[lsm_rule].type, Audit_equal,
+				      entry->lsm[lsm_rule].args_p,
+				      &entry->lsm[lsm_rule].rules[0]);
+	if (!ima_lsm_isset(entry->lsm[lsm_rule].rules)) {
+#else
 	result = ima_filter_rule_init(entry->lsm[lsm_rule].type, Audit_equal,
 				      entry->lsm[lsm_rule].args_p,
 				      &entry->lsm[lsm_rule].rule);
 	if (!entry->lsm[lsm_rule].rule) {
+#endif
 		pr_warn("rule for LSM \'%s\' is undefined\n",
 			entry->lsm[lsm_rule].args_p);
 
@@ -2224,7 +2288,11 @@ int ima_policy_show(struct seq_file *m,
 	}
 
 	for (i = 0; i < MAX_LSM_RULES; i++) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		if (ima_lsm_isset(entry->lsm[i].rules)) {
+#else
 		if (entry->lsm[i].rule) {
+#endif
 			switch (i) {
 			case LSM_OBJ_USER:
 				seq_printf(m, pt(Opt_obj_user),
diff -Naurp a/linux-6.6.38.igel/security/landlock/cred.c b/linux-6.6.38.igel/security/landlock/cred.c
--- a/linux-6.6.38.igel/security/landlock/cred.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/landlock/cred.c	2024-08-02 15:41:31.571491967 +0200
@@ -14,6 +14,13 @@
 #include "ruleset.h"
 #include "setup.h"
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id landlock_lsmid __lsm_ro_after_init = {
+	.lsm  = "landlock",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 static int hook_cred_prepare(struct cred *const new,
 			     const struct cred *const old, const gfp_t gfp)
 {
@@ -41,6 +48,11 @@ static struct security_hook_list landloc
 
 __init void landlock_add_cred_hooks(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
+			   &landlock_lsmid);
+#else
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
 			   LANDLOCK_NAME);
+#endif
 }
diff -Naurp a/linux-6.6.38.igel/security/landlock/fs.c b/linux-6.6.38.igel/security/landlock/fs.c
--- a/linux-6.6.38.igel/security/landlock/fs.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/landlock/fs.c	2024-08-02 15:41:31.571491967 +0200
@@ -38,6 +38,13 @@
 #include "ruleset.h"
 #include "setup.h"
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id landlock_lsmid __lsm_ro_after_init = {
+	.lsm  = "landlock",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 /* Underlying object management */
 
 static void release_inode(struct landlock_object *const object)
@@ -1315,6 +1322,11 @@ static struct security_hook_list landloc
 
 __init void landlock_add_fs_hooks(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
+			   &landlock_lsmid);
+#else
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
 			   LANDLOCK_NAME);
+#endif
 }
diff -Naurp a/linux-6.6.38.igel/security/landlock/ptrace.c b/linux-6.6.38.igel/security/landlock/ptrace.c
--- a/linux-6.6.38.igel/security/landlock/ptrace.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/landlock/ptrace.c	2024-08-02 15:41:31.571491967 +0200
@@ -20,6 +20,13 @@
 #include "ruleset.h"
 #include "setup.h"
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id landlock_lsmid __lsm_ro_after_init = {
+       .lsm  = "landlock",
+       .slot = LSMBLOB_NEEDED
+};
+#endif
+
 /**
  * domain_scope_le - Checks domain ordering for scoped ptrace
  *
@@ -115,6 +122,11 @@ static struct security_hook_list landloc
 
 __init void landlock_add_ptrace_hooks(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
+			   &landlock_lsmid);
+#else
 	security_add_hooks(landlock_hooks, ARRAY_SIZE(landlock_hooks),
 			   LANDLOCK_NAME);
+#endif
 }
diff -Naurp a/linux-6.6.38.igel/security/loadpin/loadpin.c b/linux-6.6.38.igel/security/loadpin/loadpin.c
--- a/linux-6.6.38.igel/security/loadpin/loadpin.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/loadpin/loadpin.c	2024-08-02 15:41:31.571491967 +0200
@@ -208,6 +208,13 @@ static int loadpin_load_data(enum kernel
 	return loadpin_check(NULL, (enum kernel_read_file_id) id);
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id loadpin_lsmid __lsm_ro_after_init = {
+	.lsm  = "loadpin",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 static struct security_hook_list loadpin_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(sb_free_security, loadpin_sb_free_security),
 	LSM_HOOK_INIT(kernel_read_file, loadpin_read_file),
@@ -259,7 +266,13 @@ static int __init loadpin_init(void)
 	if (!register_sysctl("kernel/loadpin", loadpin_sysctl_table))
 		pr_notice("sysctl registration failed!\n");
 #endif
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks),
+			   &loadpin_lsmid);
+#else
 	security_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), "loadpin");
+#endif
 
 	return 0;
 }
diff -Naurp a/linux-6.6.38.igel/security/lockdown/lockdown.c b/linux-6.6.38.igel/security/lockdown/lockdown.c
--- a/linux-6.6.38.igel/security/lockdown/lockdown.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/lockdown/lockdown.c	2024-08-02 15:41:31.571491967 +0200
@@ -75,6 +75,13 @@ static struct security_hook_list lockdow
 	LSM_HOOK_INIT(locked_down, lockdown_is_locked_down),
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id lockdown_lsmid __lsm_ro_after_init = {
+	.lsm = "lockdown",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 static int __init lockdown_lsm_init(void)
 {
 #if defined(CONFIG_LOCK_DOWN_KERNEL_FORCE_INTEGRITY)
@@ -82,8 +89,13 @@ static int __init lockdown_lsm_init(void
 #elif defined(CONFIG_LOCK_DOWN_KERNEL_FORCE_CONFIDENTIALITY)
 	lock_kernel_down("Kernel configuration", LOCKDOWN_CONFIDENTIALITY_MAX);
 #endif
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(lockdown_hooks, ARRAY_SIZE(lockdown_hooks),
+			   &lockdown_lsmid);
+#else
 	security_add_hooks(lockdown_hooks, ARRAY_SIZE(lockdown_hooks),
 			   "lockdown");
+#endif
 	return 0;
 }
 
diff -Naurp a/linux-6.6.38.igel/security/safesetid/lsm.c b/linux-6.6.38.igel/security/safesetid/lsm.c
--- a/linux-6.6.38.igel/security/safesetid/lsm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/safesetid/lsm.c	2024-08-02 15:41:31.571491967 +0200
@@ -261,6 +261,13 @@ static int safesetid_task_fix_setgroups(
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id safesetid_lsmid __lsm_ro_after_init = {
+	.lsm  = "safesetid",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 static struct security_hook_list safesetid_security_hooks[] = {
 	LSM_HOOK_INIT(task_fix_setuid, safesetid_task_fix_setuid),
 	LSM_HOOK_INIT(task_fix_setgid, safesetid_task_fix_setgid),
@@ -270,9 +277,16 @@ static struct security_hook_list safeset
 
 static int __init safesetid_security_init(void)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(safesetid_security_hooks,
+			   ARRAY_SIZE(safesetid_security_hooks),
+			   &safesetid_lsmid);
+#else
 	security_add_hooks(safesetid_security_hooks,
 			   ARRAY_SIZE(safesetid_security_hooks), "safesetid");
 
+#endif
+
 	/* Report that SafeSetID successfully initialized */
 	safesetid_initialized = 1;
 
diff -Naurp a/linux-6.6.38.igel/security/security.c b/linux-6.6.38.igel/security/security.c
--- a/linux-6.6.38.igel/security/security.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/security.c	2024-08-02 15:41:31.571491967 +0200
@@ -30,6 +30,9 @@
 #include <linux/string.h>
 #include <linux/msg.h>
 #include <net/flow.h>
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include <net/sock.h>
+#endif
 
 /* How many LSMs were built into the kernel? */
 #define LSM_COUNT (__end_lsm_info - __start_lsm_info)
@@ -80,7 +83,18 @@ static struct kmem_cache *lsm_file_cache
 static struct kmem_cache *lsm_inode_cache;
 
 char *lsm_names;
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/*
+ * The task blob includes the "display" slot used for
+ * chosing which module presents contexts.
+ */
+static struct lsm_blob_sizes blob_sizes __lsm_ro_after_init = {
+	.lbs_task = sizeof(int),
+};
+#else
 static struct lsm_blob_sizes blob_sizes __ro_after_init;
+#endif
 
 /* Boot-time LSM user choice */
 static __initdata const char *chosen_lsm_order;
@@ -209,6 +223,9 @@ static void __init lsm_set_blob_sizes(st
 	lsm_set_blob_size(&needed->lbs_ipc, &blob_sizes.lbs_ipc);
 	lsm_set_blob_size(&needed->lbs_msg_msg, &blob_sizes.lbs_msg_msg);
 	lsm_set_blob_size(&needed->lbs_superblock, &blob_sizes.lbs_superblock);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	lsm_set_blob_size(&needed->lbs_sock, &blob_sizes.lbs_sock);
+#endif
 	lsm_set_blob_size(&needed->lbs_task, &blob_sizes.lbs_task);
 	lsm_set_blob_size(&needed->lbs_xattr_count,
 			  &blob_sizes.lbs_xattr_count);
@@ -377,7 +394,13 @@ static void __init ordered_lsm_init(void
 	init_debug("ipc blob size        = %d\n", blob_sizes.lbs_ipc);
 	init_debug("msg_msg blob size    = %d\n", blob_sizes.lbs_msg_msg);
 	init_debug("superblock blob size = %d\n", blob_sizes.lbs_superblock);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	init_debug("sock blob size       = %d\n", blob_sizes.lbs_sock);
+#endif
 	init_debug("task blob size       = %d\n", blob_sizes.lbs_task);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	init_debug("lsmblob size       = %zu\n", sizeof(struct lsmblob));
+#endif
 	init_debug("xattr slots          = %d\n", blob_sizes.lbs_xattr_count);
 
 	/*
@@ -509,6 +532,53 @@ static int lsm_append(const char *new, c
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/*
+ * Current index to use while initializing the lsmblob secid list.
+ * Pointers to the LSM id structures for local use.
+ */
+static int lsm_slot __lsm_ro_after_init;
+static struct lsm_id *lsm_slotlist[LSMBLOB_ENTRIES];
+
+/**
+ * security_add_hooks - Add a modules hooks to the hook lists.
+ * @hooks: the hooks to add
+ * @count: the number of hooks to add
+ * @lsmid: the the identification information for the security module
+ *
+ * Each LSM has to register its hooks with the infrastructure.
+ * If the LSM is using hooks that export secids allocate a slot
+ * for it in the lsmblob.
+ */
+void __init security_add_hooks(struct security_hook_list *hooks, int count,
+			       struct lsm_id *lsmid)
+{
+	int i;
+
+	if (lsmid->slot == LSMBLOB_NEEDED) {
+		if (lsm_slot >= LSMBLOB_ENTRIES)
+			panic("%s Too many LSMs registered.\n", __func__);
+		lsm_slotlist[lsm_slot] = lsmid;
+		lsmid->slot = lsm_slot++;
+		init_debug("%s assigned lsmblob slot %d\n", lsmid->lsm,
+			   lsmid->slot);
+	}
+
+	for (i = 0; i < count; i++) {
+		hooks[i].lsmid = lsmid;
+		hlist_add_tail_rcu(&hooks[i].list, hooks[i].head);
+	}
+
+	/*
+	 * Don't try to append during early_security_init(), we'll come back
+	 * and fix this up afterwards.
+	 */
+	if (slab_is_available()) {
+		if (lsm_append(lsmid->lsm, &lsm_names) < 0)
+			panic("%s - Cannot get early memory.\n", __func__);
+	}
+}
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * security_add_hooks - Add a modules hooks to the hook lists.
  * @hooks: the hooks to add
@@ -536,6 +606,7 @@ void __init security_add_hooks(struct se
 			panic("%s - Cannot get early memory.\n", __func__);
 	}
 }
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 
 int call_blocking_lsm_notifier(enum lsm_event event, void *data)
 {
@@ -646,6 +717,9 @@ int lsm_inode_alloc(struct inode *inode)
  */
 static int lsm_task_alloc(struct task_struct *task)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int *display;
+#endif
 	if (blob_sizes.lbs_task == 0) {
 		task->security = NULL;
 		return 0;
@@ -654,6 +728,17 @@ static int lsm_task_alloc(struct task_st
 	task->security = kzalloc(blob_sizes.lbs_task, GFP_KERNEL);
 	if (task->security == NULL)
 		return -ENOMEM;
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	/*
+	 * The start of the task blob contains the "display" LSM slot number.
+	 * Start with it set to the invalid slot number, indicating that the
+	 * default first registered LSM be displayed.
+	 */
+	display = task->security;
+	*display = LSMBLOB_INVALID;
+#endif
+
 	return 0;
 }
 
@@ -699,6 +784,30 @@ static int lsm_msg_msg_alloc(struct msg_
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * lsm_sock_alloc - allocate a composite sock blob
+ * @sock: the sock that needs a blob
+ * @priority: allocation mode
+ *
+ * Allocate the sock blob for all the modules
+ *
+ * Returns 0, or -ENOMEM if memory can't be allocated.
+ */
+static int lsm_sock_alloc(struct sock *sock, gfp_t priority)
+{
+	if (blob_sizes.lbs_sock == 0) {
+		sock->sk_security = NULL;
+		return 0;
+	}
+
+	sock->sk_security = kzalloc(blob_sizes.lbs_sock, priority);
+	if (sock->sk_security == NULL)
+		return -ENOMEM;
+	return 0;
+}
+#endif
+
 /**
  * lsm_early_task - during initialization allocate a composite task blob
  * @task: the task that needs a blob
@@ -713,6 +822,59 @@ static void __init lsm_early_task(struct
 		panic("%s: Early task alloc failed.\n", __func__);
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * append_ctx - append a lsm/context pair to a compound context
+ * @ctx: the existing compound context
+ * @ctxlen: size of the old context, including terminating nul byte
+ * @lsm: new lsm name, nul terminated
+ * @new: new context, possibly nul terminated
+ * @newlen: maximum size of @new
+ *
+ * replace @ctx with a new compound context, appending @newlsm and @new
+ * to @ctx. On exit the new data replaces the old, which is freed.
+ * @ctxlen is set to the new size, which includes a trailing nul byte.
+ *
+ * Returns 0 on success, -ENOMEM if no memory is available.
+ */
+static int append_ctx(char **ctx, int *ctxlen, const char *lsm, char *new,
+		      int newlen)
+{
+	char *final;
+	size_t llen;
+	size_t nlen;
+	size_t flen;
+
+	llen = strlen(lsm) + 1;
+	/*
+	 * A security module may or may not provide a trailing nul on
+	 * when returning a security context. There is no definition
+	 * of which it should be, and there are modules that do it
+	 * each way.
+	 */
+	nlen = strnlen(new, newlen);
+
+	flen = *ctxlen + llen + nlen + 1;
+	final = kzalloc(flen, GFP_KERNEL);
+
+	if (final == NULL)
+		return -ENOMEM;
+
+	if (*ctxlen)
+		memcpy(final, *ctx, *ctxlen);
+
+	memcpy(final + *ctxlen, lsm, llen);
+	memcpy(final + *ctxlen + llen, new, nlen);
+
+	kfree(*ctx);
+
+	*ctx = final;
+	*ctxlen = flen;
+
+	return 0;
+}
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
+
 /**
  * lsm_superblock_alloc - allocate a composite superblock blob
  * @sb: the superblock that needs a blob
@@ -2873,6 +3035,31 @@ int security_file_truncate(struct file *
 	return call_int_hook(file_truncate, 0, file);
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+int security_task_alloc(struct task_struct *task, unsigned long clone_flags)
+{
+	int *odisplay = current->security;
+	int *ndisplay;
+	int rc = lsm_task_alloc(task);
+
+	if (unlikely(rc))
+		return rc;
+
+	rc = call_int_hook(task_alloc, 0, task, clone_flags);
+	if (unlikely(rc)) {
+		security_task_free(task);
+		return rc;
+	}
+
+	if (odisplay) {
+		ndisplay = task->security;
+		if (ndisplay)
+			*ndisplay = *odisplay;
+	}
+
+	return 0;
+}
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * security_task_alloc() - Allocate a task's LSM blob
  * @task: the task
@@ -2893,6 +3080,7 @@ int security_task_alloc(struct task_stru
 		security_task_free(task);
 	return rc;
 }
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 
 /**
  * security_task_free() - Free a task's LSM blob and related resources
@@ -3833,15 +4021,149 @@ int security_getprocattr(struct task_str
 			 const char *name, char **value)
 {
 	struct security_hook_list *hp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	char *final = NULL;
+	char *cp;
+	int rc = 0;
+	int finallen = 0;
+	int display = lsm_task_display(current);
+	int slot = 0;
+
+	if (!strcmp(name, "display")) {
+		/*
+		 * lsm_slot will be 0 if there are no displaying modules.
+		 */
+		if (lsm_slot == 0)
+			return -EINVAL;
+
+		/*
+		 * Only allow getting the current process' display.
+		 * There are too few reasons to get another process'
+		 * display and too many LSM policy issues.
+		 */
+		if (current != p)
+			return -EINVAL;
+
+		display = lsm_task_display(p);
+		if (display != LSMBLOB_INVALID)
+			slot = display;
+		*value = kstrdup(lsm_slotlist[slot]->lsm, GFP_KERNEL);
+		if (*value)
+			return strlen(*value);
+		return -ENOMEM;
+	}
+
+	if (!strcmp(name, "context")) {
+		hlist_for_each_entry(hp, &security_hook_heads.getprocattr,
+				     list) {
+			rc = hp->hook.getprocattr(p, "context", &cp);
+			if (rc == -EINVAL)
+				continue;
+			if (rc < 0) {
+				kfree(final);
+				return rc;
+			}
+			rc = append_ctx(&final, &finallen, hp->lsmid->lsm,
+					cp, rc);
+			kfree(cp);
+			if (rc < 0) {
+				kfree(final);
+				return rc;
+			}
+		}
+		if (final == NULL)
+			return -EINVAL;
+		*value = final;
+		return finallen;
+	}
 
 	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
+		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
+			continue;
+		if (lsm == NULL && display != LSMBLOB_INVALID &&
+		    display != hp->lsmid->slot)
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
+	hlist_for_each_entry(hp, &security_hook_heads.getprocattr, list) {
 		if (lsm != NULL && strcmp(lsm, hp->lsm))
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 			continue;
 		return hp->hook.getprocattr(p, name, value);
 	}
 	return LSM_RET_DEFAULT(getprocattr);
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+/**
+ * security_setprocattr - Set process attributes via /proc
+ * @lsm: name of module involved, or NULL
+ * @name: name of the attribute
+ * @value: value to set the attribute to
+ * @size: size of the value
+ *
+ * Set the process attribute for the specified security module
+ * to the specified value. Note that this can only be used to set
+ * the process attributes for the current, or "self" process.
+ * The /proc code has already done this check.
+ *
+ * Returns 0 on success, an appropriate code otherwise.
+ */
+int security_setprocattr(const char *lsm, const char *name, void *value,
+			 size_t size)
+{
+	struct security_hook_list *hp;
+	char *termed;
+	char *copy;
+	int *display = current->security;
+	int rc = -EINVAL;
+	int slot = 0;
+
+	if (!strcmp(name, "display")) {
+		/*
+		 * Change the "display" value only if all the security
+		 * modules that support setting a procattr allow it.
+		 * It is assumed that all such security modules will be
+		 * cooperative.
+		 */
+		if (size == 0)
+			return -EINVAL;
+
+		hlist_for_each_entry(hp, &security_hook_heads.setprocattr,
+				     list) {
+			rc = hp->hook.setprocattr(name, value, size);
+			if (rc < 0)
+				return rc;
+		}
+
+		rc = -EINVAL;
+
+		copy = kmemdup_nul(value, size, GFP_KERNEL);
+		if (copy == NULL)
+			return -ENOMEM;
+
+		termed = strsep(&copy, " \n");
+
+		for (slot = 0; slot < lsm_slot; slot++)
+			if (!strcmp(termed, lsm_slotlist[slot]->lsm)) {
+				*display = lsm_slotlist[slot]->slot;
+				rc = size;
+				break;
+			}
+
+		kfree(termed);
+		return rc;
+	}
+
+	hlist_for_each_entry(hp, &security_hook_heads.setprocattr, list) {
+		if (lsm != NULL && strcmp(lsm, hp->lsmid->lsm))
+			continue;
+		if (lsm == NULL && *display != LSMBLOB_INVALID &&
+		    *display != hp->lsmid->slot)
+			continue;
+		return hp->hook.setprocattr(name, value, size);
+	}
+	return LSM_RET_DEFAULT(setprocattr);
+}
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * security_setprocattr() - Set an attribute for a task
  * @lsm: LSM name
@@ -3866,6 +4188,7 @@ int security_setprocattr(const char *lsm
 	}
 	return LSM_RET_DEFAULT(setprocattr);
 }
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 
 /**
  * security_netlink_send() - Save info and check if netlink sending is allowed
@@ -3915,16 +4238,25 @@ EXPORT_SYMBOL(security_ismaclabel);
 int security_secid_to_secctx(u32 secid, char **secdata, u32 *seclen)
 {
 	struct security_hook_list *hp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int display = lsm_task_display(current);
+#else
 	int rc;
+#endif
 
 	/*
 	 * Currently, only one LSM can implement secid_to_secctx (i.e this
 	 * LSM hook is not "stackable").
 	 */
 	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		if (display == LSMBLOB_INVALID || display == hp->lsmid->slot)
+			return hp->hook.secid_to_secctx(secid, secdata, seclen);
+#else
 		rc = hp->hook.secid_to_secctx(secid, secdata, seclen);
 		if (rc != LSM_RET_DEFAULT(secid_to_secctx))
 			return rc;
+#endif
 	}
 
 	return LSM_RET_DEFAULT(secid_to_secctx);
@@ -3943,8 +4275,20 @@ EXPORT_SYMBOL(security_secid_to_secctx);
  */
 int security_secctx_to_secid(const char *secdata, u32 seclen, u32 *secid)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct security_hook_list *hp;
+	int display = lsm_task_display(current);
+#endif
 	*secid = 0;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	hlist_for_each_entry(hp, &security_hook_heads.secid_to_secctx, list) {
+		if (display == LSMBLOB_INVALID || display == hp->lsmid->slot)
+			return call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);
+	}
+	return 0;
+#else
 	return call_int_hook(secctx_to_secid, 0, secdata, seclen, secid);
+#endif
 }
 EXPORT_SYMBOL(security_secctx_to_secid);
 
@@ -3957,7 +4301,18 @@ EXPORT_SYMBOL(security_secctx_to_secid);
  */
 void security_release_secctx(char *secdata, u32 seclen)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct security_hook_list *hp;
+	int display = lsm_task_display(current);
+
+	hlist_for_each_entry(hp, &security_hook_heads.release_secctx, list)
+		if (display == LSMBLOB_INVALID || display == hp->lsmid->slot) {
+			hp->hook.release_secctx(secdata, seclen);
+			return;
+		}
+#else
 	call_void_hook(release_secctx, secdata, seclen);
+#endif
 }
 EXPORT_SYMBOL(security_release_secctx);
 
@@ -4399,6 +4754,17 @@ EXPORT_SYMBOL(security_sock_rcv_skb);
 int security_socket_getpeersec_stream(struct socket *sock, sockptr_t optval,
 				      sockptr_t optlen, unsigned int len)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int display = lsm_task_display(current);
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.socket_getpeersec_stream,
+			     list)
+		if (display == LSMBLOB_INVALID || display == hp->lsmid->slot)
+			return hp->hook.socket_getpeersec_stream(sock, optval,
+								 optlen, len);
+	return -ENOPROTOOPT;
+#else
 	struct security_hook_list *hp;
 	int rc;
 
@@ -4413,6 +4779,7 @@ int security_socket_getpeersec_stream(st
 			return rc;
 	}
 	return LSM_RET_DEFAULT(socket_getpeersec_stream);
+#endif
 }
 
 /**
@@ -4461,7 +4828,18 @@ EXPORT_SYMBOL(security_socket_getpeersec
  */
 int security_sk_alloc(struct sock *sk, int family, gfp_t priority)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	int rc = lsm_sock_alloc(sk, priority);
+
+	if (unlikely(rc))
+		return rc;
+	rc = call_int_hook(sk_alloc_security, 0, sk, family, priority);
+	if (unlikely(rc))
+		security_sk_free(sk);
+	return rc;
+#else
 	return call_int_hook(sk_alloc_security, 0, sk, family, priority);
+#endif
 }
 
 /**
@@ -4473,6 +4851,10 @@ int security_sk_alloc(struct sock *sk, i
 void security_sk_free(struct sock *sk)
 {
 	call_void_hook(sk_free_security, sk);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	kfree(sk->sk_security);
+	sk->sk_security = NULL;
+#endif
 }
 
 /**
@@ -5124,7 +5506,28 @@ int security_key_getsecurity(struct key
  */
 int security_audit_rule_init(u32 field, u32 op, char *rulestr, void **lsmrule)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct security_hook_list *hp;
+	bool one_is_good = false;
+	int rc = 0;
+	int trc;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_init, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		trc = hp->hook.audit_rule_init(field, op, rulestr,
+					       &lsmrule[hp->lsmid->slot]);
+		if (trc == 0)
+			one_is_good = true;
+		else
+			rc = trc;
+	}
+	if (one_is_good)
+		return 0;
+	return rc;
+#else
 	return call_int_hook(audit_rule_init, 0, field, op, rulestr, lsmrule);
+#endif
 }
 
 /**
@@ -5141,6 +5544,34 @@ int security_audit_rule_known(struct aud
 	return call_int_hook(audit_rule_known, 0, krule);
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+void security_audit_rule_free(void **lsmrule)
+{
+	struct security_hook_list *hp;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_free, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		hp->hook.audit_rule_free(lsmrule[hp->lsmid->slot]);
+	}
+}
+
+int security_audit_rule_match(u32 secid, u32 field, u32 op, void **lsmrule)
+{
+	struct security_hook_list *hp;
+	int rc;
+
+	hlist_for_each_entry(hp, &security_hook_heads.audit_rule_match, list) {
+		if (WARN_ON(hp->lsmid->slot < 0 || hp->lsmid->slot >= lsm_slot))
+			continue;
+		rc = hp->hook.audit_rule_match(secid, field, op,
+					       &lsmrule[hp->lsmid->slot]);
+		if (rc)
+			return rc;
+	}
+	return 0;
+}
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * security_audit_rule_free() - Free an LSM audit rule struct
  * @lsmrule: audit rule struct
@@ -5170,6 +5601,7 @@ int security_audit_rule_match(u32 secid,
 {
 	return call_int_hook(audit_rule_match, 0, secid, field, op, lsmrule);
 }
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 #endif /* CONFIG_AUDIT */
 
 #ifdef CONFIG_BPF_SYSCALL
diff -Naurp a/linux-6.6.38.igel/security/selinux/hooks.c b/linux-6.6.38.igel/security/selinux/hooks.c
--- a/linux-6.6.38.igel/security/selinux/hooks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/selinux/hooks.c	2024-08-02 15:41:31.575492063 +0200
@@ -4567,7 +4567,11 @@ static int socket_sockcreate_sid(const s
 
 static int sock_has_perm(struct sock *sk, u32 perms)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct common_audit_data ad;
 	struct lsm_network_audit net;
 
@@ -4620,7 +4624,11 @@ static int selinux_socket_post_create(st
 	isec->initialized = LABEL_INITIALIZED;
 
 	if (sock->sk) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		sksec = selinux_sock(sock->sk);
+#else
 		sksec = sock->sk->sk_security;
+#endif
 		sksec->sclass = sclass;
 		sksec->sid = sid;
 		/* Allows detection of the first association on this socket */
@@ -4636,8 +4644,13 @@ static int selinux_socket_post_create(st
 static int selinux_socket_socketpair(struct socket *socka,
 				     struct socket *sockb)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec_a = selinux_sock(socka->sk);
+	struct sk_security_struct *sksec_b = selinux_sock(sockb->sk);
+#else
 	struct sk_security_struct *sksec_a = socka->sk->sk_security;
 	struct sk_security_struct *sksec_b = sockb->sk->sk_security;
+#endif
 
 	sksec_a->peer_sid = sksec_b->sid;
 	sksec_b->peer_sid = sksec_a->sid;
@@ -4652,7 +4665,11 @@ static int selinux_socket_socketpair(str
 static int selinux_socket_bind(struct socket *sock, struct sockaddr *address, int addrlen)
 {
 	struct sock *sk = sock->sk;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	u16 family;
 	int err;
 
@@ -4792,7 +4809,11 @@ static int selinux_socket_connect_helper
 					 struct sockaddr *address, int addrlen)
 {
 	struct sock *sk = sock->sk;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	int err;
 
 	err = sock_has_perm(sk, SOCKET__CONNECT);
@@ -4970,9 +4991,15 @@ static int selinux_socket_unix_stream_co
 					      struct sock *other,
 					      struct sock *newsk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec_sock = selinux_sock(sock);
+	struct sk_security_struct *sksec_other = selinux_sock(other);
+	struct sk_security_struct *sksec_new = selinux_sock(newsk);
+#else
 	struct sk_security_struct *sksec_sock = sock->sk_security;
 	struct sk_security_struct *sksec_other = other->sk_security;
 	struct sk_security_struct *sksec_new = newsk->sk_security;
+#endif
 	struct common_audit_data ad;
 	struct lsm_network_audit net;
 	int err;
@@ -5001,8 +5028,13 @@ static int selinux_socket_unix_stream_co
 static int selinux_socket_unix_may_send(struct socket *sock,
 					struct socket *other)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *ssec = selinux_sock(sock->sk);
+	struct sk_security_struct *osec = selinux_sock(other->sk);
+#else
 	struct sk_security_struct *ssec = sock->sk->sk_security;
 	struct sk_security_struct *osec = other->sk->sk_security;
+#endif
 	struct common_audit_data ad;
 	struct lsm_network_audit net;
 
@@ -5039,7 +5071,11 @@ static int selinux_sock_rcv_skb_compat(s
 				       u16 family)
 {
 	int err = 0;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	u32 sk_sid = sksec->sid;
 	struct common_audit_data ad;
 	struct lsm_network_audit net;
@@ -5068,7 +5104,11 @@ static int selinux_sock_rcv_skb_compat(s
 static int selinux_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err, peerlbl_active, secmark_active;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	u16 family = sk->sk_family;
 	u32 sk_sid = sksec->sid;
 	struct common_audit_data ad;
@@ -5136,7 +5176,11 @@ static int selinux_socket_getpeersec_str
 	int err = 0;
 	char *scontext = NULL;
 	u32 scontext_len;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sock->sk);
+#else
 	struct sk_security_struct *sksec = sock->sk->sk_security;
+#endif
 	u32 peer_sid = SECSID_NULL;
 
 	if (sksec->sclass == SECCLASS_UNIX_STREAM_SOCKET ||
@@ -5194,34 +5238,51 @@ out:
 
 static int selinux_sk_alloc_security(struct sock *sk, int family, gfp_t priority)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec;
 
 	sksec = kzalloc(sizeof(*sksec), priority);
 	if (!sksec)
 		return -ENOMEM;
+#endif
 
 	sksec->peer_sid = SECINITSID_UNLABELED;
 	sksec->sid = SECINITSID_UNLABELED;
 	sksec->sclass = SECCLASS_SOCKET;
 	selinux_netlbl_sk_security_reset(sksec);
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 	sk->sk_security = sksec;
+#endif
 
 	return 0;
 }
 
 static void selinux_sk_free_security(struct sock *sk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+
+	selinux_netlbl_sk_security_free(sksec);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
 
 	sk->sk_security = NULL;
 	selinux_netlbl_sk_security_free(sksec);
 	kfree(sksec);
+#endif
 }
 
 static void selinux_sk_clone_security(const struct sock *sk, struct sock *newsk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
 	struct sk_security_struct *newsksec = newsk->sk_security;
+#endif
 
 	newsksec->sid = sksec->sid;
 	newsksec->peer_sid = sksec->peer_sid;
@@ -5235,8 +5296,11 @@ static void selinux_sk_getsecid(const st
 	if (!sk)
 		*secid = SECINITSID_ANY_SOCKET;
 	else {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		const struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 		const struct sk_security_struct *sksec = sk->sk_security;
-
+#endif
 		*secid = sksec->sid;
 	}
 }
@@ -5245,7 +5309,11 @@ static void selinux_sock_graft(struct so
 {
 	struct inode_security_struct *isec =
 		inode_security_novalidate(SOCK_INODE(parent));
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 	if (sk->sk_family == PF_INET || sk->sk_family == PF_INET6 ||
 	    sk->sk_family == PF_UNIX)
@@ -5262,7 +5330,11 @@ static int selinux_sctp_process_new_asso
 {
 	struct sock *sk = asoc->base.sk;
 	u16 family = sk->sk_family;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct common_audit_data ad;
 	struct lsm_network_audit net;
 	int err;
@@ -5449,8 +5521,13 @@ static int selinux_sctp_bind_connect(str
 static void selinux_sctp_sk_clone(struct sctp_association *asoc, struct sock *sk,
 				  struct sock *newsk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
 	struct sk_security_struct *newsksec = newsk->sk_security;
+#endif
 
 	/* If policy does not support SECCLASS_SCTP_SOCKET then call
 	 * the non-sctp clone version.
@@ -5482,7 +5559,11 @@ static int selinux_mptcp_add_subflow(str
 static int selinux_inet_conn_request(const struct sock *sk, struct sk_buff *skb,
 				     struct request_sock *req)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	int err;
 	u16 family = req->rsk_ops->family;
 	u32 connsid;
@@ -5503,7 +5584,11 @@ static int selinux_inet_conn_request(con
 static void selinux_inet_csk_clone(struct sock *newsk,
 				   const struct request_sock *req)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *newsksec = selinux_sock(newsk);
+#else
 	struct sk_security_struct *newsksec = newsk->sk_security;
+#endif
 
 	newsksec->sid = req->secid;
 	newsksec->peer_sid = req->peer_secid;
@@ -5520,7 +5605,11 @@ static void selinux_inet_csk_clone(struc
 static void selinux_inet_conn_established(struct sock *sk, struct sk_buff *skb)
 {
 	u16 family = sk->sk_family;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 	/* handle mapped IPv4 packets arriving via IPv6 sockets */
 	if (family == PF_INET6 && skb->protocol == htons(ETH_P_IP))
@@ -5601,7 +5690,11 @@ static int selinux_tun_dev_attach_queue(
 static int selinux_tun_dev_attach(struct sock *sk, void *security)
 {
 	struct tun_security_struct *tunsec = security;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 	/* we don't currently perform any NetLabel based labeling here and it
 	 * isn't clear that we would want to do so anyway; while we could apply
@@ -5724,7 +5817,11 @@ static unsigned int selinux_ip_output(vo
 			return NF_ACCEPT;
 
 		/* standard practice, label using the parent socket */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		sksec = selinux_sock(sk);
+#else
 		sksec = sk->sk_security;
+#endif
 		sid = sksec->sid;
 	} else
 		sid = SECINITSID_KERNEL;
@@ -5747,7 +5844,11 @@ static unsigned int selinux_ip_postroute
 	sk = skb_to_full_sk(skb);
 	if (sk == NULL)
 		return NF_ACCEPT;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	sksec = selinux_sock(sk);
+#else
 	sksec = sk->sk_security;
+#endif
 
 	ad_net_init_from_iif(&ad, &net, state->out->ifindex, state->pf);
 	if (selinux_parse_skb(skb, &ad, NULL, 0, &proto))
@@ -5836,7 +5937,11 @@ static unsigned int selinux_ip_postroute
 		u32 skb_sid;
 		struct sk_security_struct *sksec;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		sksec = selinux_sock(sk);
+#else
 		sksec = sk->sk_security;
+#endif
 		if (selinux_skb_peerlbl_sid(skb, family, &skb_sid))
 			return NF_DROP;
 		/* At this point, if the returned skb peerlbl is SECSID_NULL
@@ -5865,7 +5970,11 @@ static unsigned int selinux_ip_postroute
 	} else {
 		/* Locally generated packet, fetch the security label from the
 		 * associated socket. */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 		struct sk_security_struct *sksec = sk->sk_security;
+#endif
 		peer_sid = sksec->sid;
 		secmark_perm = PACKET__SEND;
 	}
@@ -5908,7 +6017,11 @@ static int selinux_netlink_send(struct s
 	unsigned int data_len = skb->len;
 	unsigned char *data = skb->data;
 	struct nlmsghdr *nlh;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	u16 sclass = sksec->sclass;
 	u32 perm;
 
@@ -6330,7 +6443,11 @@ static int selinux_getprocattr(struct ta
 			goto bad;
 	}
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (!strcmp(name, "current") || !strcmp(name, "context"))
+#else
 	if (!strcmp(name, "current"))
+#endif
 		sid = __tsec->sid;
 	else if (!strcmp(name, "prev"))
 		sid = __tsec->osid;
@@ -6372,6 +6489,18 @@ static int selinux_setprocattr(const cha
 	/*
 	 * Basic control over ability to set these attributes at all.
 	 */
+
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	/*
+	 * For setting display, we only perform a permission check;
+	 * the actual update to the display value is handled by the
+	 * LSM framework.
+	 */
+	if (!strcmp(name, "display"))
+		return avc_has_perm(&selinux_state,
+				    mysid, mysid, SECCLASS_PROCESS2,
+				    PROCESS2__SETDISPLAY, NULL);
+#endif
 	if (!strcmp(name, "exec"))
 		error = avc_has_perm(mysid, mysid, SECCLASS_PROCESS,
 				     PROCESS__SETEXEC, NULL);
@@ -6863,6 +6992,9 @@ struct lsm_blob_sizes selinux_blob_sizes
 	.lbs_ipc = sizeof(struct ipc_security_struct),
 	.lbs_msg_msg = sizeof(struct msg_security_struct),
 	.lbs_superblock = sizeof(struct superblock_security_struct),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	.lbs_sock = sizeof(struct sk_security_struct),
+#endif
 	.lbs_xattr_count = SELINUX_INODE_INIT_XATTRS,
 };
 
@@ -6978,6 +7110,13 @@ static int selinux_uring_cmd(struct io_u
 }
 #endif /* CONFIG_IO_URING */
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id selinux_lsmid __lsm_ro_after_init = {
+	.lsm  = "selinux",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 /*
  * IMPORTANT NOTE: When adding new hooks, please be careful to keep this order:
  * 1. any hooks that don't belong to (2.) or (3.) below,
@@ -7299,7 +7438,12 @@ static __init int selinux_init(void)
 
 	hashtab_cache_init();
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks),
+			   &selinux_lsmid);
+#else
 	security_add_hooks(selinux_hooks, ARRAY_SIZE(selinux_hooks), "selinux");
+#endif
 
 	if (avc_add_callback(selinux_netcache_avc_callback, AVC_CALLBACK_RESET))
 		panic("SELinux: Unable to register AVC netcache callback\n");
diff -Naurp a/linux-6.6.38.igel/security/selinux/include/classmap.h b/linux-6.6.38.igel/security/selinux/include/classmap.h
--- a/linux-6.6.38.igel/security/selinux/include/classmap.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/selinux/include/classmap.h	2024-08-02 15:41:31.575492063 +0200
@@ -53,7 +53,12 @@ const struct security_class_mapping secc
 	    "execmem", "execstack", "execheap", "setkeycreate",
 	    "setsockcreate", "getrlimit", NULL } },
 	{ "process2",
+	/* #ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT won't work here due to this is processed by genheaders */
+#if 1
+	  { "nnp_transition", "nosuid_transition", "setdisplay", NULL } },
+#else
 	  { "nnp_transition", "nosuid_transition", NULL } },
+#endif
 	{ "system",
 	  { "ipc_info", "syslog_read", "syslog_mod",
 	    "syslog_console", "module_request", "module_load", NULL } },
diff -Naurp a/linux-6.6.38.igel/security/selinux/include/objsec.h b/linux-6.6.38.igel/security/selinux/include/objsec.h
--- a/linux-6.6.38.igel/security/selinux/include/objsec.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/selinux/include/objsec.h	2024-08-02 15:41:31.575492063 +0200
@@ -194,4 +194,11 @@ static inline struct superblock_security
 	return superblock->s_security + selinux_blob_sizes.lbs_superblock;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static inline struct sk_security_struct *selinux_sock(const struct sock *sock)
+{
+	return sock->sk_security + selinux_blob_sizes.lbs_sock;
+}
+#endif
+
 #endif /* _SELINUX_OBJSEC_H_ */
diff -Naurp a/linux-6.6.38.igel/security/selinux/netlabel.c b/linux-6.6.38.igel/security/selinux/netlabel.c
--- a/linux-6.6.38.igel/security/selinux/netlabel.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/selinux/netlabel.c	2024-08-02 15:41:31.575492063 +0200
@@ -17,6 +17,9 @@
 #include <linux/gfp.h>
 #include <linux/ip.h>
 #include <linux/ipv6.h>
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#include <linux/lsm_hooks.h>
+#endif
 #include <net/sock.h>
 #include <net/netlabel.h>
 #include <net/ip.h>
@@ -68,7 +71,11 @@ static int selinux_netlbl_sidlookup_cach
 static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)
 {
 	int rc;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct netlbl_lsm_secattr *secattr;
 
 	if (sksec->nlbl_secattr != NULL)
@@ -100,7 +107,11 @@ static struct netlbl_lsm_secattr *selinu
 							const struct sock *sk,
 							u32 sid)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;
 
 	if (secattr == NULL)
@@ -240,7 +251,11 @@ int selinux_netlbl_skbuff_setsid(struct
 	 * being labeled by it's parent socket, if it is just exit */
 	sk = skb_to_full_sk(skb);
 	if (sk != NULL) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 		struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 		if (sksec->nlbl_state != NLBL_REQSKB)
 			return 0;
@@ -277,7 +292,11 @@ int selinux_netlbl_sctp_assoc_request(st
 {
 	int rc;
 	struct netlbl_lsm_secattr secattr;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(asoc->base.sk);
+#else
 	struct sk_security_struct *sksec = asoc->base.sk->sk_security;
+#endif
 	struct sockaddr_in addr4;
 	struct sockaddr_in6 addr6;
 
@@ -356,7 +375,11 @@ inet_conn_request_return:
  */
 void selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 	if (family == PF_INET)
 		sksec->nlbl_state = NLBL_LABELED;
@@ -374,8 +397,13 @@ void selinux_netlbl_inet_csk_clone(struc
  */
 void selinux_netlbl_sctp_sk_clone(struct sock *sk, struct sock *newsk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+	struct sk_security_struct *newsksec = selinux_sock(newsk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
 	struct sk_security_struct *newsksec = newsk->sk_security;
+#endif
 
 	newsksec->nlbl_state = sksec->nlbl_state;
 }
@@ -393,7 +421,11 @@ void selinux_netlbl_sctp_sk_clone(struct
 int selinux_netlbl_socket_post_create(struct sock *sk, u16 family)
 {
 	int rc;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct netlbl_lsm_secattr *secattr;
 
 	if (family != PF_INET && family != PF_INET6)
@@ -507,7 +539,11 @@ int selinux_netlbl_socket_setsockopt(str
 {
 	int rc = 0;
 	struct sock *sk = sock->sk;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct netlbl_lsm_secattr secattr;
 
 	if (selinux_netlbl_option(level, optname) &&
@@ -545,7 +581,11 @@ static int selinux_netlbl_socket_connect
 						struct sockaddr *addr)
 {
 	int rc;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 	struct netlbl_lsm_secattr *secattr;
 
 	/* connected sockets are allowed to disconnect when the address family
@@ -584,7 +624,11 @@ static int selinux_netlbl_socket_connect
 int selinux_netlbl_socket_connect_locked(struct sock *sk,
 					 struct sockaddr *addr)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct sk_security_struct *sksec = selinux_sock(sk);
+#else
 	struct sk_security_struct *sksec = sk->sk_security;
+#endif
 
 	if (sksec->nlbl_state != NLBL_REQSKB &&
 	    sksec->nlbl_state != NLBL_CONNLABELED)
diff -Naurp a/linux-6.6.38.igel/security/smack/smack.h b/linux-6.6.38.igel/security/smack/smack.h
--- a/linux-6.6.38.igel/security/smack/smack.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/smack/smack.h	2024-08-02 15:41:31.575492063 +0200
@@ -355,6 +355,13 @@ static inline struct superblock_smack *s
 	return superblock->s_security + smack_blob_sizes.lbs_superblock;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static inline struct socket_smack *smack_sock(const struct sock *sock)
+{
+	return sock->sk_security + smack_blob_sizes.lbs_sock;
+}
+#endif
+
 /*
  * Is the directory transmuting?
  */
diff -Naurp a/linux-6.6.38.igel/security/smack/smack_lsm.c b/linux-6.6.38.igel/security/smack/smack_lsm.c
--- a/linux-6.6.38.igel/security/smack/smack_lsm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/smack/smack_lsm.c	2024-08-02 15:41:31.575492063 +0200
@@ -1572,7 +1572,11 @@ static int smack_inode_getsecurity(struc
 		if (sock == NULL || sock->sk == NULL)
 			return -EOPNOTSUPP;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		ssp = smack_sock(sock->sk);
+#else
 		ssp = sock->sk->sk_security;
+#endif
 
 		if (strcmp(name, XATTR_SMACK_IPIN) == 0)
 			isp = ssp->smk_in;
@@ -1960,7 +1964,11 @@ static int smack_file_receive(struct fil
 
 	if (inode->i_sb->s_magic == SOCKFS_MAGIC) {
 		sock = SOCKET_I(inode);
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		ssp = smack_sock(sock->sk);
+#else
 		ssp = sock->sk->sk_security;
+#endif
 		tsp = smack_cred(current_cred());
 		/*
 		 * If the receiving process can't write to the
@@ -2380,11 +2388,15 @@ static void smack_task_to_inode(struct t
 static int smack_sk_alloc_security(struct sock *sk, int family, gfp_t gfp_flags)
 {
 	struct smack_known *skp = smk_of_current();
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp;
 
 	ssp = kzalloc(sizeof(struct socket_smack), gfp_flags);
 	if (ssp == NULL)
 		return -ENOMEM;
+#endif
 
 	/*
 	 * Sockets created by kernel threads receive web label.
@@ -2398,11 +2410,38 @@ static int smack_sk_alloc_security(struc
 	}
 	ssp->smk_packet = NULL;
 
+#ifndef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
 	sk->sk_security = ssp;
+#endif
 
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#ifdef SMACK_IPV6_PORT_LABELING
+/**
+ * smack_sk_free_security - Free a socket blob
+ * @sk: the socket
+ *
+ * Clears the blob pointer
+ */
+static void smack_sk_free_security(struct sock *sk)
+{
+	struct smk_port_label *spp;
+
+	if (sk->sk_family == PF_INET6) {
+		rcu_read_lock();
+		list_for_each_entry_rcu(spp, &smk_ipv6_port_list, list) {
+			if (spp->smk_sock != sk)
+				continue;
+			spp->smk_can_reuse = 1;
+			break;
+		}
+		rcu_read_unlock();
+	}
+}
+#endif
+#else /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 /**
  * smack_sk_free_security - Free a socket blob
  * @sk: the socket
@@ -2427,6 +2466,7 @@ static void smack_sk_free_security(struc
 #endif
 	kfree(sk->sk_security);
 }
+#endif
 
 /**
  * smack_sk_clone_security - Copy security context
@@ -2554,7 +2594,11 @@ static struct smack_known *smack_ipv6hos
  */
 static int smack_netlbl_add(struct sock *sk)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct smack_known *skp = ssp->smk_out;
 	int rc;
 
@@ -2618,7 +2662,11 @@ static int smk_ipv4_check(struct sock *s
 	struct smack_known *skp;
 	int rc = 0;
 	struct smack_known *hkp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct smk_audit_info ad;
 
 	rcu_read_lock();
@@ -2691,7 +2739,11 @@ static void smk_ipv6_port_label(struct s
 {
 	struct sock *sk = sock->sk;
 	struct sockaddr_in6 *addr6;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sock->sk);
+#else
 	struct socket_smack *ssp = sock->sk->sk_security;
+#endif
 	struct smk_port_label *spp;
 	unsigned short port = 0;
 
@@ -2779,7 +2831,11 @@ static int smk_ipv6_port_check(struct so
 				int act)
 {
 	struct smk_port_label *spp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct smack_known *skp = NULL;
 	unsigned short port;
 	struct smack_known *object;
@@ -2882,7 +2938,11 @@ static int smack_inode_setsecurity(struc
 	if (sock == NULL || sock->sk == NULL)
 		return -EOPNOTSUPP;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	ssp = smack_sock(sock->sk);
+#else
 	ssp = sock->sk->sk_security;
+#endif
 
 	if (strcmp(name, XATTR_SMACK_IPIN) == 0)
 		ssp->smk_in = skp;
@@ -2930,7 +2990,11 @@ static int smack_socket_post_create(stru
 	 * Sockets created by kernel threads receive web label.
 	 */
 	if (unlikely(current->flags & PF_KTHREAD)) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		ssp = smack_sock(sock->sk);
+#else
 		ssp = sock->sk->sk_security;
+#endif
 		ssp->smk_in = &smack_known_web;
 		ssp->smk_out = &smack_known_web;
 	}
@@ -2955,8 +3019,13 @@ static int smack_socket_post_create(stru
 static int smack_socket_socketpair(struct socket *socka,
 		                   struct socket *sockb)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *asp = smack_sock(socka->sk);
+	struct socket_smack *bsp = smack_sock(sockb->sk);
+#else
 	struct socket_smack *asp = socka->sk->sk_security;
 	struct socket_smack *bsp = sockb->sk->sk_security;
+#endif
 
 	asp->smk_packet = bsp->smk_out;
 	bsp->smk_packet = asp->smk_out;
@@ -3019,7 +3088,11 @@ static int smack_socket_connect(struct s
 		if (__is_defined(SMACK_IPV6_SECMARK_LABELING))
 			rsp = smack_ipv6host_label(sip);
 		if (rsp != NULL) {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+			struct socket_smack *ssp = smack_sock(sock->sk);
+#else
 			struct socket_smack *ssp = sock->sk->sk_security;
+#endif
 
 			rc = smk_ipv6_check(ssp->smk_out, rsp, sip,
 					    SMK_CONNECTING);
@@ -3651,7 +3724,11 @@ static int smack_getprocattr(struct task
 	char *cp;
 	int slen;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (strcmp(name, "current") != 0 && strcmp(name, "context") != 0)
+#else
 	if (strcmp(name, "current") != 0)
+#endif
 		return -EINVAL;
 
 	cp = kstrdup(skp->smk_known, GFP_KERNEL);
@@ -3682,6 +3759,15 @@ static int smack_setprocattr(const char
 	struct smack_known_list_elem *sklep;
 	int rc;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	/*
+	 * Allow the /proc/.../attr/current and SO_PEERSEC "display"
+	 * to be reset at will.
+	 */
+	if (strcmp(name, "display") == 0)
+		return 0;
+#endif
+
 	if (!smack_privileged(CAP_MAC_ADMIN) && list_empty(&tsp->smk_relabel))
 		return -EPERM;
 
@@ -3742,9 +3828,15 @@ static int smack_unix_stream_connect(str
 {
 	struct smack_known *skp;
 	struct smack_known *okp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sock);
+	struct socket_smack *osp = smack_sock(other);
+	struct socket_smack *nsp = smack_sock(newsk);
+#else
 	struct socket_smack *ssp = sock->sk_security;
 	struct socket_smack *osp = other->sk_security;
 	struct socket_smack *nsp = newsk->sk_security;
+#endif
 	struct smk_audit_info ad;
 	int rc = 0;
 #ifdef CONFIG_AUDIT
@@ -3790,8 +3882,13 @@ static int smack_unix_stream_connect(str
  */
 static int smack_unix_may_send(struct socket *sock, struct socket *other)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sock->sk);
+	struct socket_smack *osp = smack_sock(other->sk);
+#else
 	struct socket_smack *ssp = sock->sk->sk_security;
 	struct socket_smack *osp = other->sk->sk_security;
+#endif
 	struct smk_audit_info ad;
 	int rc;
 
@@ -3828,7 +3925,11 @@ static int smack_socket_sendmsg(struct s
 	struct sockaddr_in6 *sap = (struct sockaddr_in6 *) msg->msg_name;
 #endif
 #ifdef SMACK_IPV6_SECMARK_LABELING
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sock->sk);
+#else
 	struct socket_smack *ssp = sock->sk->sk_security;
+#endif
 	struct smack_known *rsp;
 #endif
 	int rc = 0;
@@ -4062,7 +4163,11 @@ static struct smack_known *smack_from_ne
  */
 static int smack_socket_sock_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct smack_known *skp = NULL;
 	int rc = 0;
 	struct smk_audit_info ad;
@@ -4166,7 +4271,11 @@ static int smack_socket_getpeersec_strea
 	u32 slen = 1;
 	int rc = 0;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	ssp = smack_sock(sock->sk);
+#else
 	ssp = sock->sk->sk_security;
+#endif
 	if (ssp->smk_packet != NULL) {
 		rcp = ssp->smk_packet->smk_known;
 		slen = strlen(rcp) + 1;
@@ -4216,7 +4325,11 @@ static int smack_socket_getpeersec_dgram
 
 	switch (family) {
 	case PF_UNIX:
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+		ssp = smack_sock(sock->sk);
+#else
 		ssp = sock->sk->sk_security;
+#endif
 		s = ssp->smk_out->smk_secid;
 		break;
 	case PF_INET:
@@ -4265,7 +4378,11 @@ static void smack_sock_graft(struct sock
 	    (sk->sk_family != PF_INET && sk->sk_family != PF_INET6))
 		return;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	ssp = smack_sock(sk);
+#else
 	ssp = sk->sk_security;
+#endif
 	ssp->smk_in = skp;
 	ssp->smk_out = skp;
 	/* cssp->smk_packet is already set in smack_inet_csk_clone() */
@@ -4285,7 +4402,11 @@ static int smack_inet_conn_request(const
 {
 	u16 family = sk->sk_family;
 	struct smack_known *skp;
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct sockaddr_in addr;
 	struct iphdr *hdr;
 	struct smack_known *hskp;
@@ -4371,7 +4492,11 @@ static int smack_inet_conn_request(const
 static void smack_inet_csk_clone(struct sock *sk,
 				 const struct request_sock *req)
 {
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	struct socket_smack *ssp = smack_sock(sk);
+#else
 	struct socket_smack *ssp = sk->sk_security;
+#endif
 	struct smack_known *skp;
 
 	if (req->peer_secid != 0) {
@@ -4940,9 +5065,19 @@ struct lsm_blob_sizes smack_blob_sizes _
 	.lbs_ipc = sizeof(struct smack_known *),
 	.lbs_msg_msg = sizeof(struct smack_known *),
 	.lbs_superblock = sizeof(struct superblock_smack),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	.lbs_sock = sizeof(struct socket_smack),
+#endif
 	.lbs_xattr_count = SMACK_INODE_INIT_XATTRS,
 };
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id smack_lsmid __lsm_ro_after_init = {
+	.lsm  = "smack",
+	.slot = LSMBLOB_NEEDED
+};
+#endif
+
 static struct security_hook_list smack_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, smack_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, smack_ptrace_traceme),
@@ -5055,7 +5190,13 @@ static struct security_hook_list smack_h
 	LSM_HOOK_INIT(socket_getpeersec_stream, smack_socket_getpeersec_stream),
 	LSM_HOOK_INIT(socket_getpeersec_dgram, smack_socket_getpeersec_dgram),
 	LSM_HOOK_INIT(sk_alloc_security, smack_sk_alloc_security),
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+#ifdef SMACK_IPV6_PORT_LABELING
 	LSM_HOOK_INIT(sk_free_security, smack_sk_free_security),
+#endif
+#else
+	LSM_HOOK_INIT(sk_free_security, smack_sk_free_security),
+#endif /* CONFIG_IGEL_APPARMOR_DBUS_SUPPORT */
 	LSM_HOOK_INIT(sk_clone_security, smack_sk_clone_security),
 	LSM_HOOK_INIT(sock_graft, smack_sock_graft),
 	LSM_HOOK_INIT(inet_conn_request, smack_inet_conn_request),
@@ -5151,7 +5292,11 @@ static __init int smack_init(void)
 	/*
 	 * Register with LSM
 	 */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), &smack_lsmid);
+#else
 	security_add_hooks(smack_hooks, ARRAY_SIZE(smack_hooks), "smack");
+#endif
 	smack_enabled = 1;
 
 	pr_info("Smack:  Initializing.\n");
diff -Naurp a/linux-6.6.38.igel/security/smack/smack_netfilter.c b/linux-6.6.38.igel/security/smack/smack_netfilter.c
--- a/linux-6.6.38.igel/security/smack/smack_netfilter.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/smack/smack_netfilter.c	2024-08-02 15:41:31.575492063 +0200
@@ -26,8 +26,13 @@ static unsigned int smack_ip_output(void
 	struct socket_smack *ssp;
 	struct smack_known *skp;
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	if (sk && smack_sock(sk)) {
+		ssp = smack_sock(sk);
+#else
 	if (sk && sk->sk_security) {
 		ssp = sk->sk_security;
+#endif
 		skp = ssp->smk_out;
 		skb->secmark = skp->smk_secid;
 	}
diff -Naurp a/linux-6.6.38.igel/security/tomoyo/tomoyo.c b/linux-6.6.38.igel/security/tomoyo/tomoyo.c
--- a/linux-6.6.38.igel/security/tomoyo/tomoyo.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/tomoyo/tomoyo.c	2024-08-02 15:41:31.575492063 +0200
@@ -542,6 +542,13 @@ static void tomoyo_task_free(struct task
 	}
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id tomoyo_lsmid __lsm_ro_after_init = {
+	.lsm  = "tomoyo",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 /*
  * tomoyo_security_ops is a "struct security_operations" which is used for
  * registering TOMOYO.
@@ -596,7 +603,12 @@ static int __init tomoyo_init(void)
 	struct tomoyo_task *s = tomoyo_task(current);
 
 	/* register ourselves with the security framework */
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks),
+			   &tomoyo_lsmid);
+#else
 	security_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), "tomoyo");
+#endif
 	pr_info("TOMOYO Linux initialized\n");
 	s->domain_info = &tomoyo_kernel_domain;
 	atomic_inc(&tomoyo_kernel_domain.users);
diff -Naurp a/linux-6.6.38.igel/security/yama/yama_lsm.c b/linux-6.6.38.igel/security/yama/yama_lsm.c
--- a/linux-6.6.38.igel/security/yama/yama_lsm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/security/yama/yama_lsm.c	2024-08-02 15:41:31.575492063 +0200
@@ -421,6 +421,13 @@ static int yama_ptrace_traceme(struct ta
 	return rc;
 }
 
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+static struct lsm_id yama_lsmid __lsm_ro_after_init = {
+	.lsm  = "yama",
+	.slot = LSMBLOB_NOT_NEEDED
+};
+#endif
+
 static struct security_hook_list yama_hooks[] __ro_after_init = {
 	LSM_HOOK_INIT(ptrace_access_check, yama_ptrace_access_check),
 	LSM_HOOK_INIT(ptrace_traceme, yama_ptrace_traceme),
@@ -471,7 +478,11 @@ static inline void yama_init_sysctl(void
 static int __init yama_init(void)
 {
 	pr_info("Yama: becoming mindful.\n");
+#ifdef CONFIG_IGEL_APPARMOR_DBUS_SUPPORT
+	security_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), &yama_lsmid);
+#else
 	security_add_hooks(yama_hooks, ARRAY_SIZE(yama_hooks), "yama");
+#endif
 	yama_init_sysctl();
 	return 0;
 }
diff -Naurp a/linux-6.6.38.igel/sound/core/jack.c b/linux-6.6.38.igel/sound/core/jack.c
--- a/linux-6.6.38.igel/sound/core/jack.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/core/jack.c	2024-08-02 15:41:31.575492063 +0200
@@ -15,6 +15,9 @@
 #include <sound/core.h>
 #include <sound/control.h>
 
+#if !defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES) && !defined(CONFIG_IGEL_LENOVO_M600_SOUND_FIXES)
+/* gottwald@igel.com moved to include/sound/jack.h if SOUND FIXES are choosen
+ * because struct is also needed by sound/pci/hda/patch_realtek.c */
 struct snd_jack_kctl {
 	struct snd_kcontrol *kctl;
 	struct list_head list;  /* list of controls belong to the same jack */
@@ -25,6 +28,7 @@ struct snd_jack_kctl {
 	struct dentry *jack_debugfs_root; /* jack_kctl debugfs root */
 #endif
 };
+#endif
 
 #ifdef CONFIG_SND_JACK_INPUT_DEV
 static const int jack_switch_types[SND_JACK_SWITCH_TYPES] = {
diff -Naurp a/linux-6.6.38.igel/sound/pci/hda/hda_codec.c b/linux-6.6.38.igel/sound/pci/hda/hda_codec.c
--- a/linux-6.6.38.igel/sound/pci/hda/hda_codec.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/pci/hda/hda_codec.c	2024-08-02 15:41:31.575492063 +0200
@@ -23,6 +23,9 @@
 #include "hda_jack.h"
 #include <sound/hda_hwdep.h>
 #include <sound/hda_component.h>
+#ifdef CONFIG_IGEL_LG_LIMIT_VOLUME
+#include <linux/dmi.h>
+#endif
 
 #define codec_in_pm(codec)		snd_hdac_is_in_pm(&codec->core)
 #define hda_codec_is_power_on(codec)	snd_hdac_is_power_on(&codec->core)
@@ -1460,11 +1463,22 @@ int snd_hda_mixer_amp_volume_info(struct
 	u8 chs = get_amp_channels(kcontrol);
 	int dir = get_amp_direction(kcontrol);
 	unsigned int ofs = get_amp_offset(kcontrol);
+#ifdef CONFIG_IGEL_LG_LIMIT_VOLUME
+	const char *vendor = NULL;
+#endif
 
 	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
 	uinfo->count = chs == 3 ? 2 : 1;
 	uinfo->value.integer.min = 0;
+#ifdef CONFIG_IGEL_LG_LIMIT_VOLUME
+	vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+	if (vendor && strcmp(vendor, "LG Electronics") == 0 && nid == 0x03)
+		uinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs) - 11;
+	else
+		uinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);
+#else
 	uinfo->value.integer.max = get_amp_max_value(codec, nid, dir, ofs);
+#endif
 	if (!uinfo->value.integer.max) {
 		codec_warn(codec,
 			   "num_steps = 0 for NID=0x%x (ctl = %s)\n",
diff -Naurp a/linux-6.6.38.igel/sound/pci/hda/patch_realtek.c b/linux-6.6.38.igel/sound/pci/hda/patch_realtek.c
--- a/linux-6.6.38.igel/sound/pci/hda/patch_realtek.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/pci/hda/patch_realtek.c	2024-08-02 15:41:31.575492063 +0200
@@ -56,6 +56,14 @@ enum {
 	ALC_KEY_MICMUTE_INDEX,
 };
 
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+enum {
+	IGEL_OFF,
+	IGEL_M350,
+	IGEL_M250,
+};
+#endif
+
 struct alc_customize_define {
 	unsigned int  sku_cfg;
 	unsigned char port_connectivity;
@@ -136,6 +144,12 @@ struct alc_spec {
 	struct hda_component comps[HDA_MAX_COMPONENTS];
 };
 
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+int igel_thin_clients = IGEL_OFF;
+module_param(igel_thin_clients, int, 0644);
+MODULE_PARM_DESC(igel_thin_clients, "Set to 1 to fix microphone dead if plugged in during reboot issues");
+#endif
+
 /*
  * COEF access helper functions
  */
@@ -3581,6 +3595,9 @@ static void alc256_init(struct hda_codec
 	struct alc_spec *spec = codec->spec;
 	hda_nid_t hp_pin = alc_get_hp_pin(spec);
 	bool hp_pin_sense;
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+	const char *product = NULL, *vendor = NULL;
+#endif
 
 	if (spec->ultra_low_power) {
 		alc_update_coef_idx(codec, 0x03, 1<<1, 1<<1);
@@ -3626,6 +3643,23 @@ static void alc256_init(struct hda_codec
 	 * this register.
 	 */
 	alc_write_coef_idx(codec, 0x36, 0x5757);
+
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+	/*
+	 * Detect our IGEL supported hardware (M350)
+	 */
+	product = dmi_get_system_info(DMI_PRODUCT_NAME);
+	vendor = dmi_get_system_info(DMI_SYS_VENDOR); 
+	if (product != NULL && vendor != NULL) {
+		if (strstr(vendor, "IGEL Technology GmbH")) {
+			if (strstr(product, "M350C"))
+				igel_thin_clients = IGEL_M350;				
+			if (strstr(product, "M250C"))
+				igel_thin_clients = IGEL_M250;
+			pr_info("ALC256 detected: %s %s", vendor, product);
+		}
+	}
+#endif
 }
 
 static void alc256_shutup(struct hda_codec *codec)
@@ -3654,8 +3688,18 @@ static void alc256_shutup(struct hda_cod
 	/* If disable 3k pulldown control for alc257, the Mic detection will not work correctly
 	 * when booting with headset plugged. So skip setting it for the codec alc257
 	 */
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+	if (codec->core.vendor_id != 0x10ec0236 &&
+	    codec->core.vendor_id != 0x10ec0257 &&
+	    !igel_thin_clients)
+#else
 	if (spec->en_3kpull_low)
+#endif
 		alc_update_coef_idx(codec, 0x46, 0, 3 << 12);
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES)
+	else
+		pr_info("ALC256 detected, IGEL sound fix active");
+#endif
 
 	if (!spec->no_shutup_pins)
 		snd_hda_codec_write(codec, hp_pin, 0,
@@ -6418,6 +6462,53 @@ static void alc285_fixup_thinkpad_x1_gen
 	}
 }
 
+#if defined(CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES) || defined(CONFIG_IGEL_LENOVO_M600_SOUND_FIXES)
+static void alc_rename_ctl(struct hda_codec *codec, unsigned int nid,
+			   const char *name, const char *new_name)
+{
+	int i;
+	struct hda_nid_item *items = codec->mixers.list;
+
+	for (i = 0; i < codec->mixers.used; i++) {
+		if (items[i].nid == nid && !strcmp(items[i].kctl->id.name, name)) {
+			strcpy(items[i].kctl->id.name, new_name);
+			break;
+		}
+	}
+}
+
+static void alc_rename_jack(struct hda_codec *codec, unsigned int nid,
+			    const char *name, const char *new_name)
+{
+	struct hda_jack_tbl *j;
+	struct snd_jack_kctl *jack_kctl, *tmp_jack_kctl;
+
+	j = snd_hda_jack_tbl_get(codec, nid);
+	if (NULL != j && NULL != j->jack) {
+		list_for_each_entry_safe(jack_kctl,
+					 tmp_jack_kctl, &(j->jack->kctl_list), list)
+		{
+			if (!strcmp(jack_kctl->kctl->id.name, name)) {
+				strcpy(jack_kctl->kctl->id.name, new_name);
+			}
+		}
+	}
+}
+
+#ifdef CONFIG_IGEL_LENOVO_M600_SOUND_FIXES
+/* hamburg@igel.com */
+static void alc233_fixup_lenovo_m600(struct hda_codec *codec,
+				     const struct hda_fixup *fix, int action)
+{
+	if (HDA_FIXUP_ACT_BUILD == action) {
+		/* rename double */
+		alc_rename_jack(codec, 0x19,
+				"Mic Jack", "Headset Mic Jack");
+	}
+}
+#endif
+#endif
+
 static void alc233_alc662_fixup_lenovo_dual_codecs(struct hda_codec *codec,
 					 const struct hda_fixup *fix,
 					 int action)
@@ -6623,6 +6714,32 @@ static void alc274_fixup_hp_headset_mic(
 	}
 }
 
+#ifdef CONFIG_IGEL_LG_AIO_MIC_FIXES
+static void alc_fixup_lg_headphone(struct hda_codec *codec,
+				  const struct hda_fixup *fix, int action)
+{
+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
+		snd_hda_override_wcaps(codec, 0x19, get_wcaps(codec, 0x19) & ~AC_WCAP_IN_AMP);
+	
+//		alc_update_coef_idx(codec, 0x10, 0x000c, 2 << 2); // Line2 JD gate
+//		alc_update_coef_idx(codec, 0x1b, 0x0f00, 0xc << 8); // Analog JD
+		alc_write_coef_idx(codec, 0x1b, 0x0a4b);
+		alc_update_coef_idx(codec, 0x47, 0x00f0, 0xa << 4); // TD1 timing
+	
+//		if (!query_amp_caps(codec, 0x8, HDA_INPUT))
+			/* override the amp caps for capture generator */
+			snd_hda_override_amp_caps(codec, 0x08, HDA_INPUT,
+					  (0x01f << AC_AMPCAP_OFFSET_SHIFT) |
+					  (0x037 << AC_AMPCAP_NUM_STEPS_SHIFT) |  // 18db --> 0x3f-0x08=0x37
+										  // 6db  --> 0x3f-0x20=0x1f
+										  // 0db  --> 0x3f-0x28-0x17		
+					  (0x02 << AC_AMPCAP_STEP_SIZE_SHIFT) |
+					  (1 << AC_AMPCAP_MUTE_SHIFT));
+	}
+	
+}
+#endif
+
 static void alc_fixup_no_int_mic(struct hda_codec *codec,
 				    const struct hda_fixup *fix, int action)
 {
@@ -6696,6 +6813,32 @@ static void alc285_fixup_hp_spectre_x360
 	}
 }
 
+#ifdef CONFIG_IGEL_HP_T640_SOUND_FIXES
+static void alc256_hp_playback_pcm_hook(struct hda_pcm_stream *hinfo,
+					struct hda_codec *codec,
+					struct snd_pcm_substream *substream,
+					int action)
+{
+	switch (action) {
+	case HDA_GEN_PCM_ACT_OPEN:
+		alc_auto_setup_eapd(codec, true);
+		break;
+	case HDA_GEN_PCM_ACT_CLOSE:
+		alc_auto_setup_eapd(codec, false);
+		break;
+	}
+}
+
+static void alc_fixup_hp_spk_noise(struct hda_codec *codec,
+				   const struct hda_fixup *fix, int action)
+{
+	struct alc_spec *spec = codec->spec;
+
+	if (action == HDA_FIXUP_ACT_PRE_PROBE)
+		spec->gen.pcm_playback_hook = alc256_hp_playback_pcm_hook;
+}
+#endif
+
 static void alc285_fixup_hp_envy_x360(struct hda_codec *codec,
 				      const struct hda_fixup *fix,
 				      int action)
@@ -7279,6 +7422,9 @@ enum {
 	ALC225_FIXUP_DISABLE_MIC_VREF,
 	ALC225_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC295_FIXUP_DISABLE_DAC3,
+#ifdef CONFIG_IGEL_LENOVO_M600_SOUND_FIXES
+	ALC233_FIXUP_LENOVO_M600,
+#endif
 	ALC285_FIXUP_SPEAKER2_TO_DAC1,
 	ALC285_FIXUP_ASUS_SPEAKER2_TO_DAC1,
 	ALC285_FIXUP_ASUS_HEADSET_MIC,
@@ -7403,6 +7549,10 @@ enum {
 	ALC285_FIXUP_HP_SPECTRE_X360,
 	ALC287_FIXUP_IDEAPAD_BASS_SPK_AMP,
 	ALC623_FIXUP_LENOVO_THINKSTATION_P340,
+#ifdef CONFIG_IGEL_LG_AIO_MIC_FIXES
+	ALC256_FIXUP_HEADPHONE_HEADSET,
+	ALC256_FIXUP_LG_AIO,
+#endif
 	ALC255_FIXUP_ACER_HEADPHONE_AND_MIC,
 	ALC236_FIXUP_HP_LIMIT_INT_MIC_BOOST,
 	ALC287_FIXUP_LEGION_15IMHG05_SPEAKERS,
@@ -7441,6 +7591,9 @@ enum {
 	ALC2XX_FIXUP_HEADSET_MIC,
 	ALC289_FIXUP_DELL_CS35L41_SPI_2,
 	ALC294_FIXUP_CS35L41_I2C_2,
+#ifdef CONFIG_IGEL_HP_T640_SOUND_FIXES
+	ALC256_FIXUP_HP_SPK_NOISE,
+#endif
 };
 
 /* A special fixup for Lenovo C940 and Yoga Duet 7;
@@ -8295,6 +8448,13 @@ static const struct hda_fixup alc269_fix
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc295_fixup_disable_dac3,
 	},
+#ifdef CONFIG_IGEL_LENOVO_M600_SOUND_FIXES
+	/* hamburg@igel.com */
+	[ALC233_FIXUP_LENOVO_M600] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc233_fixup_lenovo_m600
+	},
+#endif
 	[ALC285_FIXUP_SPEAKER2_TO_DAC1] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc285_fixup_speaker2_to_dac1,
@@ -9254,6 +9414,22 @@ static const struct hda_fixup alc269_fix
 		.chained = true,
 		.chain_id = ALC283_FIXUP_HEADSET_MIC,
 	},
+#ifdef CONFIG_IGEL_LG_AIO_MIC_FIXES
+	[ALC256_FIXUP_HEADPHONE_HEADSET] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_lg_headphone,
+	},
+	[ALC256_FIXUP_LG_AIO] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = (const struct hda_pintbl[]) {
+			{ 0x19, 0x04a11030 },
+			{ 0x21, 0x411111f0 },
+			{}
+		},
+		.chained = true,
+		.chain_id = ALC256_FIXUP_HEADPHONE_HEADSET,
+	},
+#endif
 	[ALC255_FIXUP_ACER_HEADPHONE_AND_MIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
@@ -9620,6 +9796,12 @@ static const struct hda_fixup alc269_fix
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cs35l41_fixup_i2c_two,
 	},
+#ifdef CONFIG_IGEL_HP_T640_SOUND_FIXES
+	[ALC256_FIXUP_HP_SPK_NOISE] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_hp_spk_noise,
+	},
+#endif
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
@@ -10311,6 +10493,9 @@ static const struct snd_pci_quirk alc269
 	SND_PCI_QUIRK(0x17aa, 0x9e54, "LENOVO NB", ALC269_FIXUP_LENOVO_EAPD),
 	SND_PCI_QUIRK(0x17aa, 0x9e56, "Lenovo ZhaoYang CF4620Z", ALC286_FIXUP_SONY_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1849, 0x1233, "ASRock NUC Box 1100", ALC233_FIXUP_NO_AUDIO_JACK),
+#ifdef CONFIG_IGEL_LG_AIO_MIC_FIXES
+	SND_PCI_QUIRK(0x1854, 0x0345, "LG CL66 AIO", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),
+#endif
 	SND_PCI_QUIRK(0x1849, 0xa233, "Positivo Master C6300", ALC269_FIXUP_HEADSET_MIC),
 	SND_PCI_QUIRK(0x19e5, 0x3204, "Huawei MACH-WX9", ALC256_FIXUP_HUAWEI_MACH_WX9_PINS),
 	SND_PCI_QUIRK(0x19e5, 0x320f, "Huawei WRT-WX9 ", ALC256_FIXUP_ASUS_MIC_NO_PRESENCE),
@@ -10346,6 +10531,9 @@ static const struct snd_pci_quirk alc269
 	SND_PCI_QUIRK(0x8086, 0x3038, "Intel NUC 13", ALC295_FIXUP_CHROME_BOOK),
 	SND_PCI_QUIRK(0xf111, 0x0001, "Framework Laptop", ALC295_FIXUP_FRAMEWORK_LAPTOP_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0xf111, 0x0006, "Framework Laptop", ALC295_FIXUP_FRAMEWORK_LAPTOP_MIC_NO_PRESENCE),
+#ifdef CONFIG_IGEL_HP_T640_SOUND_FIXES
+	SND_PCI_QUIRK(0x103c, 0x8523, "HP t640", ALC256_FIXUP_HP_SPK_NOISE),
+#endif
 
 #if 0
 	/* Below is a quirk table taken from the old code.
@@ -10495,6 +10683,9 @@ static const struct hda_model_fixup alc2
 	{.id = ALC255_FIXUP_DELL_SPK_NOISE, .name = "dell-spk-noise"},
 	{.id = ALC225_FIXUP_DELL1_MIC_NO_PRESENCE, .name = "alc225-dell1"},
 	{.id = ALC295_FIXUP_DISABLE_DAC3, .name = "alc295-disable-dac3"},
+#ifdef CONFIG_IGEL_LENOVO_M600_SOUND_FIXES
+	{.id = ALC233_FIXUP_LENOVO_M600, .name = "lenovo-m600"},
+#endif
 	{.id = ALC285_FIXUP_SPEAKER2_TO_DAC1, .name = "alc285-speaker2-to-dac1"},
 	{.id = ALC280_FIXUP_HP_HEADSET_MIC, .name = "alc280-hp-headset"},
 	{.id = ALC221_FIXUP_HP_FRONT_MIC, .name = "alc221-hp-mic"},
@@ -11716,6 +11907,103 @@ static void alc668_restore_default_value
 	alc_process_coef_fw(codec, alc668_coefs);
 }
 
+#ifdef CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES
+static void alc662_fixup_limit_mic_boost(struct hda_codec *codec,
+					 const struct hda_fixup *fix,
+					 int action)
+{
+	if (action != HDA_FIXUP_ACT_PROBE)
+		return;
+
+	/* The mic boosts on level 2 and 3 are too noisy
+	   on the internal mic input. Therefore limit the boost to 0 or 1. */
+	snd_hda_override_amp_caps(codec, 0x18, HDA_INPUT,
+				  (0x00 << AC_AMPCAP_OFFSET_SHIFT) |
+				  (0x01 << AC_AMPCAP_NUM_STEPS_SHIFT) |
+				  (0x2f << AC_AMPCAP_STEP_SIZE_SHIFT) |
+				  (0 << AC_AMPCAP_MUTE_SHIFT));
+
+	/* limit Mic Playback Volume to avoid noise in sound output */
+	snd_hda_override_amp_caps(codec, 0x0b, HDA_INPUT,
+				  (0x00 << AC_AMPCAP_OFFSET_SHIFT) |
+				  (0x14 << AC_AMPCAP_NUM_STEPS_SHIFT) |
+				  (0x02 << AC_AMPCAP_STEP_SIZE_SHIFT) |
+				  (0 << AC_AMPCAP_MUTE_SHIFT));
+}
+
+static void alc_fixup_igel_m340c_ctl(struct hda_codec *codec,
+				     const struct hda_fixup *fix, int action)
+{
+	struct snd_kcontrol *kctl;
+
+	if (action == HDA_FIXUP_ACT_BUILD) {
+		kctl = snd_hda_find_mixer_ctl(codec, "Speaker Playback Volume");
+		if (kctl) {
+			strcpy(kctl->id.name, "Alt Speaker Playback Volume");
+		}
+		kctl = snd_hda_find_mixer_ctl(codec, "Speaker Playback Switch");
+		if (kctl) {
+			strcpy(kctl->id.name, "Alt Speaker Playback Switch");
+		}
+
+		kctl = snd_hda_find_mixer_ctl(codec, "Headphone Playback Volume");
+		if (kctl) {
+			strcpy(kctl->id.name, "Speaker Playback Volume");
+		}
+		kctl = snd_hda_find_mixer_ctl(codec, "Headphone Playback Switch");
+		if (kctl) {
+			strcpy(kctl->id.name, "Speaker Playback Switch");
+		}
+	}
+}
+
+/* hamburg@igel.com: rename speaker control */
+static void alc_fixup_igel_ud9_ctl(struct hda_codec *codec,
+				   const struct hda_fixup *fix, int action)
+{
+	struct snd_kcontrol *kctl;
+
+	if (action == HDA_FIXUP_ACT_BUILD) {
+		/* ud9 with the new BIOS */
+		kctl = snd_hda_find_mixer_ctl(codec, "Front Playback Volume");
+		if (kctl) {
+			strcpy(kctl->id.name, "Speaker Playback Volume");
+		}
+		kctl = snd_hda_find_mixer_ctl(codec, "Front Playback Switch");
+		if (kctl) {
+			strcpy(kctl->id.name, "Speaker Playback Switch");
+		}
+
+		/* ud9 with the old BIOS */
+		kctl = snd_hda_find_mixer_ctl(codec, "Master Playback Volume");
+		if (kctl) {
+			strcpy(kctl->id.name, "PCM Playback Volume");
+		}
+		kctl = snd_hda_find_mixer_ctl(codec, "Master Playback Switch");
+		if (kctl) {
+			strcpy(kctl->id.name, "PCM Playback Switch");
+		}
+		alc_rename_ctl(codec, 0x09, "Capture Volume", "Alt Capture Volume");
+		alc_rename_ctl(codec, 0x09, "Capture Switch", "Alt Capture Switch");
+	}
+}
+
+/* hamburg@igel.com */
+static void alc_fixup_igel_h830(struct hda_codec *codec,
+				const struct hda_fixup *fix, int action)
+{
+	if (HDA_FIXUP_ACT_BUILD == action) {
+		/* rename mixer control element for the line out on the rear side */
+		alc_rename_ctl(codec, 0x03,
+				"PCM Playback Volume", "Headphone Playback Volume");
+		alc_rename_ctl(codec, 0x1b,
+				"PCM Playback Switch", "Headphone Playback Switch");
+		alc_rename_jack(codec, 0x1b,
+				"Line Out Jack", "Headphone Jack");
+	}
+}
+#endif
+
 enum {
 	ALC662_FIXUP_ASPIRE,
 	ALC662_FIXUP_LED_GPIO1,
@@ -11770,6 +12058,13 @@ enum {
 	ALC897_FIXUP_LENOVO_HEADSET_MIC,
 	ALC897_FIXUP_HEADSET_MIC_PIN,
 	ALC897_FIXUP_HP_HSMIC_VERB,
+#ifdef CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES
+	ALC662_FIXUP_IGEL_UD9,
+	ALC662_FIXUP_IGEL_UD9_CTL,
+	ALC662_FIXUP_LIMIT_MIC_BOOST,
+	ALC662_FIXUP_IGEL_H830,
+	ALC662_FIXUP_IGEL_M340C,
+#endif
 	ALC897_FIXUP_LENOVO_HEADSET_MODE,
 	ALC897_FIXUP_HEADSET_MIC_PIN2,
 	ALC897_FIXUP_UNIS_H3C_X500S,
@@ -12199,6 +12494,42 @@ static const struct hda_fixup alc662_fix
 			{ }
 		},
 	},
+#ifdef CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES
+	/* hamburg@igel.com : fix line out in H830 */
+	[ALC662_FIXUP_IGEL_H830] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_igel_h830,
+		.chained = true,
+		.chain_id = ALC662_FIXUP_LIMIT_MIC_BOOST
+	},
+	/* hamburg@igel.com : fix EAPD in UD9 devices */
+	[ALC662_FIXUP_IGEL_UD9] = {
+		.type = HDA_FIXUP_VERBS,
+		.v.verbs = (const struct hda_verb[]) {
+			{0x14, AC_VERB_SET_EAPD_BTLENABLE, 0},
+			{}
+		},
+		.chained = true,
+		.chain_id = ALC662_FIXUP_IGEL_UD9_CTL
+	},
+	/* hamburg@igel.com : rename playback control: "Front" into "Speaker"
+	 * in UD9 devices */
+	[ALC662_FIXUP_IGEL_UD9_CTL] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_igel_ud9_ctl,
+		.chained = true,
+		.chain_id = ALC662_FIXUP_LIMIT_MIC_BOOST
+	},
+	/* hamburg@igel.com : limit Mic Boost */
+	[ALC662_FIXUP_LIMIT_MIC_BOOST] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc662_fixup_limit_mic_boost,
+	},
+	[ALC662_FIXUP_IGEL_M340C] = {
+		.type = HDA_FIXUP_FUNC,
+		.v.func = alc_fixup_igel_m340c_ctl,
+	},
+#endif
 	[ALC897_FIXUP_LENOVO_HEADSET_MODE] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc897_fixup_lenovo_headset_mode,
@@ -12287,6 +12618,11 @@ static const struct snd_pci_quirk alc662
 	SND_PCI_QUIRK(0x1b35, 0x1234, "CZC ET26", ALC662_FIXUP_CZC_ET26),
 	SND_PCI_QUIRK(0x1b35, 0x2206, "CZC P10T", ALC662_FIXUP_CZC_P10T),
 	SND_PCI_QUIRK(0x1c6c, 0x1239, "Compaq N14JP6-V2", ALC897_FIXUP_HP_HSMIC_VERB),
+#ifdef CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES
+	/* hamburg@igel.com: activate ALC662 fixes */
+	SND_PCI_QUIRK(0x8086, 0x27d8, "IGEL-UD9", ALC662_FIXUP_IGEL_UD9),
+	SND_PCI_QUIRK(0x8086, 0x7270, "IGEL-H830", ALC662_FIXUP_IGEL_H830),
+#endif
 
 #if 0
 	/* Below is a quirk table taken from the old code.
@@ -12382,6 +12718,10 @@ static const struct hda_model_fixup alc6
 	{.id = ALC662_FIXUP_LENOVO_MULTI_CODECS, .name = "dual-codecs"},
 	{.id = ALC669_FIXUP_ACER_ASPIRE_ETHOS, .name = "aspire-ethos"},
 	{.id = ALC897_FIXUP_UNIS_H3C_X500S, .name = "unis-h3c-x500s"},
+#ifdef CONFIG_IGEL_OWN_DEVICE_SOUND_FIXES
+	{.id = ALC662_FIXUP_IGEL_UD9, .name = "igel-ud9"},
+	{.id = ALC662_FIXUP_IGEL_M340C, .name = "igel-m340c"},
+#endif
 	{}
 };
 
diff -Naurp a/linux-6.6.38.igel/sound/soc/codecs/rt5645.c b/linux-6.6.38.igel/sound/soc/codecs/rt5645.c
--- a/linux-6.6.38.igel/sound/soc/codecs/rt5645.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/codecs/rt5645.c	2024-08-02 15:41:31.575492063 +0200
@@ -42,6 +42,13 @@ static unsigned int quirk = -1;
 module_param(quirk, uint, 0444);
 MODULE_PARM_DESC(quirk, "RT5645 pdata quirk override");
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+unsigned int rt5645_jack_option = 0;
+module_param(rt5645_jack_option, uint, 0644);
+MODULE_PARM_DESC(rt5645_jack_option, "RT5645 Select combo jack(0) or split jack(1)");
+EXPORT_SYMBOL(rt5645_jack_option);
+#endif
+
 static const struct acpi_gpio_mapping *cht_rt5645_gpios;
 
 #define RT5645_DEVICE_ID 0x6308
@@ -3272,7 +3279,9 @@ int rt5645_set_jack_detect(struct snd_so
 		regmap_update_bits(rt5645->regmap, RT5645_DEPOP_M1,
 				RT5645_HP_CB_MASK, RT5645_HP_CB_PU);
 	}
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
 	rt5645_irq(0, rt5645);
+#endif
 
 	return 0;
 }
@@ -3302,11 +3311,62 @@ static void rt5645_jack_detect_work(stru
 {
 	struct rt5645_priv *rt5645 =
 		container_of(work, struct rt5645_priv, jack_detect_work.work);
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	int val, btn_type, gpio_state = 0, report = 0, cmp;
+#else
 	int val, btn_type, gpio_state = 0, report = 0;
+#endif
 
 	if (!rt5645->component)
 		return;
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	if (rt5645_jack_option == 1) {
+		/* Use JD1 2 ports check instead */
+		/*
+		 * HP is port 2 (JD 1_2)
+		 * MIC is port 1 (JD 1_1)
+		 */
+		cmp = snd_soc_component_read(rt5645->component, RT5645_A_JD_CTRL1) & 0x0070;
+		val = snd_soc_component_read(rt5645->component, RT5645_INT_IRQ_ST) & 0x3000;
+		pr_info("%s, cmp=0x%x, val=0x%x \n", __func__, cmp, val);
+		switch (cmp) {
+		case 0x10:
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_1_MASK, RT5645_JD_1_1_INV);
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_2_MASK, RT5645_JD_1_2_NOR);
+			snd_soc_jack_report(rt5645->hp_jack, SND_JACK_HEADPHONE, SND_JACK_HEADPHONE);
+			snd_soc_jack_report(rt5645->mic_jack, 0, SND_JACK_MICROPHONE);
+			break;
+		case 0x30:
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_1_MASK, RT5645_JD_1_1_NOR);
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_2_MASK, RT5645_JD_1_2_INV);
+			snd_soc_jack_report(rt5645->mic_jack, SND_JACK_MICROPHONE, SND_JACK_MICROPHONE);
+			snd_soc_jack_report(rt5645->hp_jack, 0, SND_JACK_HEADPHONE);
+			break;
+		case 0x00:
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_1_MASK, RT5645_JD_1_1_NOR);
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_2_MASK, RT5645_JD_1_2_NOR);
+			snd_soc_jack_report(rt5645->mic_jack, SND_JACK_MICROPHONE, SND_JACK_MICROPHONE);
+			snd_soc_jack_report(rt5645->hp_jack, SND_JACK_HEADPHONE, SND_JACK_HEADPHONE);
+			break;
+		default:
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_1_MASK | RT5645_JD_1_2_MASK,
+				RT5645_JD_1_1_INV | RT5645_JD_1_2_INV);
+			snd_soc_jack_report(rt5645->hp_jack, 0, SND_JACK_HEADPHONE);
+			snd_soc_jack_report(rt5645->mic_jack, 0, SND_JACK_MICROPHONE);
+			break;
+		}
+		return;
+	}
+#endif
+
 	mutex_lock(&rt5645->jd_mutex);
 
 	switch (rt5645->pdata.jd_mode) {
@@ -3434,6 +3494,10 @@ static int rt5645_probe(struct snd_soc_c
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct rt5645_priv *rt5645 = snd_soc_component_get_drvdata(component);
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	pr_info("%s: rt5645_jack_option=%d\n", __func__, rt5645_jack_option);	
+#endif
+
 	rt5645->component = component;
 
 	switch (rt5645->codec_type) {
@@ -3697,6 +3761,13 @@ static const struct rt5645_platform_data
 	.jd_mode = 3,
 };
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+static const struct rt5645_platform_data jd_mode1_platform_data = {
+	.jd_mode = 1,
+	.inv_jd1_1 = true,
+};
+#endif
+
 static const struct rt5645_platform_data lattepanda_board_platform_data = {
 	.jd_mode = 2,
 	.inv_jd1_1 = true
@@ -3763,6 +3834,17 @@ static const struct dmi_system_id dmi_pl
 		},
 		.driver_data = (void *)&intel_braswell_platform_data,
 	},
+#ifdef CONFIG_IGEL_SURFACE_SURFACE3_OEMB_FIX
+	{
+		.ident = "Microsoft Surface 3",
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+		.driver_data = (void *)&intel_braswell_platform_data,
+	},
+#endif
 	{
 		/*
 		 * Match for the GPDwin which unfortunately uses somewhat
@@ -3910,6 +3992,9 @@ static int rt5645_i2c_probe(struct i2c_c
 	int ret, i;
 	unsigned int val;
 	struct regmap *regmap;
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	const char *product = NULL, *vendor = NULL;
+#endif
 
 	rt5645 = devm_kzalloc(&i2c->dev, sizeof(struct rt5645_priv),
 				GFP_KERNEL);
@@ -3925,12 +4010,33 @@ static int rt5645_i2c_probe(struct i2c_c
 		pdata = dmi_data->driver_data;
 	}
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	if (rt5645_jack_option == 0 ) {
+		product = dmi_get_system_info(DMI_PRODUCT_NAME);
+		vendor = dmi_get_system_info(DMI_SYS_VENDOR);
+		if (product != NULL && vendor != NULL) {
+			if (strstr(product, "HP t240 Thin Client") && 
+				strstr(vendor, "HP")) {
+					rt5645_jack_option = 1;
+					pr_info("%s, HP t240 detected, rt5645_jack_option=%d\n", __func__, rt5645_jack_option);
+				}
+		}
+	}
+#endif
+
 	if (pdata)
 		rt5645->pdata = *pdata;
 	else if (rt5645_check_dp(&i2c->dev))
 		rt5645_parse_dt(rt5645, &i2c->dev);
 	else
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+		if (rt5645_jack_option == 1)
+			rt5645->pdata = jd_mode1_platform_data;
+		else
+			rt5645->pdata = jd_mode3_platform_data;
+#else
 		rt5645->pdata = jd_mode3_platform_data;
+#endif
 
 	if (quirk != -1) {
 		rt5645->pdata.in2_diff = QUIRK_IN2_DIFF(quirk);
@@ -4058,6 +4164,15 @@ static int rt5645_i2c_probe(struct i2c_c
 					   ret);
 	}
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	if (rt5645_jack_option == 1) {
+		regmap_write(rt5645->regmap, RT5645_GEN_CTRL3, 0x1b00);
+		regmap_write(rt5645->regmap, RT5645_IN1_CTRL1, 0x0022);
+		regmap_write(rt5645->regmap, RT5645_IN1_CTRL2, 0x68a7);
+		regmap_write(rt5645->regmap, RT5645_IN1_CTRL3, 0x2004);
+	}
+#endif
+
 	regmap_update_bits(rt5645->regmap, RT5645_CLSD_OUT_CTRL, 0xc0, 0xc0);
 
 	if (rt5645->pdata.in2_diff)
@@ -4146,6 +4261,10 @@ static int rt5645_i2c_probe(struct i2c_c
 				   RT5645_GP1_PIN_IRQ, RT5645_GP1_PIN_IRQ);
 		switch (rt5645->pdata.jd_mode) {
 		case 1:
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+					   RT5645_IRQ_JD_1_2_EN, RT5645_IRQ_JD_1_2_EN);
+#endif
 			regmap_update_bits(rt5645->regmap, RT5645_A_JD_CTRL1,
 					   RT5645_JD1_MODE_MASK,
 					   RT5645_JD1_MODE_0);
@@ -4167,6 +4286,10 @@ static int rt5645_i2c_probe(struct i2c_c
 		if (rt5645->pdata.inv_jd1_1) {
 			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
 				RT5645_JD_1_1_MASK, RT5645_JD_1_1_INV);
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+			regmap_update_bits(rt5645->regmap, RT5645_IRQ_CTRL2,
+				RT5645_JD_1_2_MASK, RT5645_JD_1_2_INV);
+#endif
 		}
 	}
 
diff -Naurp a/linux-6.6.38.igel/sound/soc/codecs/rt5645.h b/linux-6.6.38.igel/sound/soc/codecs/rt5645.h
--- a/linux-6.6.38.igel/sound/soc/codecs/rt5645.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/codecs/rt5645.h	2024-08-02 15:41:31.575492063 +0200
@@ -1629,6 +1629,13 @@
 #define RT5645_JD_1_1_SFT			7
 #define RT5645_JD_1_1_NOR			(0x0 << 7)
 #define RT5645_JD_1_1_INV			(0x1 << 7)
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+#define RT5645_IRQ_JD_1_2_EN			(0x1 << 6)
+#define RT5645_JD_1_2_MASK			(0x1 << 4)
+#define RT5645_JD_1_2_SFT			4
+#define RT5645_JD_1_2_NOR			(0x0 << 4)
+#define RT5645_JD_1_2_INV			(0x1 << 4)
+#endif
 
 /* IRQ Control 2 (0xbe) */
 #define RT5645_IRQ_MB1_OC_MASK			(0x1 << 15)
diff -Naurp a/linux-6.6.38.igel/sound/soc/intel/boards/cht_bsw_rt5645.c b/linux-6.6.38.igel/sound/soc/intel/boards/cht_bsw_rt5645.c
--- a/linux-6.6.38.igel/sound/soc/intel/boards/cht_bsw_rt5645.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/intel/boards/cht_bsw_rt5645.c	2024-08-02 15:41:31.579492158 +0200
@@ -31,6 +31,10 @@
 #define CHT_CODEC_DAI1	"rt5645-aif1"
 #define CHT_CODEC_DAI2	"rt5645-aif2"
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+extern unsigned int rt5645_jack_option;
+#endif
+
 struct cht_acpi_card {
 	char *codec_id;
 	int codec_type;
@@ -90,6 +94,21 @@ static int platform_clock_control(struct
 			return ret;
 		}
 	} else {
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+		if (rt5645_jack_option == 0) {
+			/* Set codec sysclk source to its internal clock because codec PLL will
+			 * be off when idle and MCLK will also be off when codec is
+			 * runtime suspended. Codec needs clock for jack detection and button
+			 * press. MCLK is turned off with clock framework or ACPI.
+			 */
+			ret = snd_soc_dai_set_sysclk(codec_dai, RT5645_SCLK_S_RCCLK,
+						48000 * 512, SND_SOC_CLOCK_IN);
+			if (ret < 0) {
+				dev_err(card->dev, "can't set codec sysclk: %d\n", ret);
+				return ret;
+			}
+		}
+#else
 		/* Set codec sysclk source to its internal clock because codec PLL will
 		 * be off when idle and MCLK will also be off when codec is
 		 * runtime suspended. Codec needs clock for jack detection and button
@@ -101,7 +120,7 @@ static int platform_clock_control(struct
 			dev_err(card->dev, "can't set codec sysclk: %d\n", ret);
 			return ret;
 		}
-
+#endif
 		clk_disable_unprepare(ctx->mclk);
 	}
 
@@ -118,6 +137,21 @@ static const struct snd_soc_dapm_widget
 			platform_clock_control, SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
 };
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+static const struct snd_soc_dapm_route cht_rt5645_split_jack_audio_map[] = {
+	{"IN1P", NULL, "Headset Mic"},
+	{"IN1N", NULL, "Headset Mic"},
+	{"IN2P", NULL, "Headset Mic"},
+	{"IN2N", NULL, "Headset Mic"},
+	{"IN1P", NULL, "micbias1"},
+	{"IN2P", NULL, "micbias2"},
+	{"Headphone", NULL, "HPOL"},
+	{"Headphone", NULL, "HPOR"},
+	{"Headphone", NULL, "Platform Clock"},
+	{"Headset Mic", NULL, "Platform Clock"},
+};
+#endif
+
 static const struct snd_soc_dapm_route cht_rt5645_audio_map[] = {
 	{"IN1P", NULL, "Headset Mic"},
 	{"IN1N", NULL, "Headset Mic"},
@@ -542,6 +576,10 @@ static int snd_cht_mc_probe(struct platf
 	int i;
 	const char *mclk_name;
 
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+	pr_info("%s: rt5645_jack_option=%d\n", __func__, rt5645_jack_option);
+#endif
+
 	drv = devm_kzalloc(&pdev->dev, sizeof(*drv), GFP_KERNEL);
 	if (!drv)
 		return -ENOMEM;
@@ -555,6 +593,15 @@ static int snd_cht_mc_probe(struct platf
 				"found codec %s\n", snd_soc_cards[i].codec_id);
 			card = snd_soc_cards[i].soc_card;
 			drv->acpi_card = &snd_soc_cards[i];
+#ifdef CONFIG_IGEL_HP_T240_SOUND_FIXES
+			if ((drv->acpi_card->codec_type == CODEC_TYPE_RT5645) &&
+					(rt5645_jack_option == 1)) {
+						pr_info("%s: Using split jack audio map", __func__);
+						card->dapm_routes = cht_rt5645_split_jack_audio_map;
+						card->num_dapm_routes = ARRAY_SIZE(cht_rt5645_split_jack_audio_map);
+						card->fully_routed = 1;
+			}
+#endif
 			found = true;
 			break;
 		}
diff -Naurp a/linux-6.6.38.igel/sound/soc/intel/common/soc-acpi-intel-cht-match.c b/linux-6.6.38.igel/sound/soc/intel/common/soc-acpi-intel-cht-match.c
--- a/linux-6.6.38.igel/sound/soc/intel/common/soc-acpi-intel-cht-match.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/intel/common/soc-acpi-intel-cht-match.c	2024-08-02 15:41:31.579492158 +0200
@@ -27,6 +27,16 @@ static const struct dmi_system_id cht_ta
 			DMI_MATCH(DMI_PRODUCT_NAME, "Surface 3"),
 		},
 	},
+#ifdef CONFIG_IGEL_SURFACE_SURFACE3_OEMB_FIX
+	{
+		.callback = cht_surface_quirk_cb,
+		.matches = {
+			DMI_MATCH(DMI_BIOS_VENDOR, "American Megatrends Inc."),
+			DMI_MATCH(DMI_SYS_VENDOR, "OEMB"),
+			DMI_MATCH(DMI_PRODUCT_NAME, "OEMB"),
+		},
+	},
+#endif
 	{ }
 };
 
diff -Naurp a/linux-6.6.38.igel/sound/soc/sof/ipc4-control.c b/linux-6.6.38.igel/sound/soc/sof/ipc4-control.c
--- a/linux-6.6.38.igel/sound/soc/sof/ipc4-control.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/sof/ipc4-control.c	2024-08-02 15:41:31.579492158 +0200
@@ -201,6 +201,105 @@ static int sof_ipc4_volume_get(struct sn
 	return 0;
 }
 
+#ifdef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
+static int
+sof_ipc4_set_generic_control_data(struct snd_sof_dev *sdev,
+				  struct snd_sof_widget *swidget,
+				  struct snd_sof_control *scontrol, bool lock)
+{
+	struct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;
+	struct sof_ipc4_control_msg_payload *data;
+	struct sof_ipc4_msg *msg = &cdata->msg;
+	size_t data_size;
+	unsigned int i;
+	int ret;
+
+	data_size = struct_size(data, chanv, scontrol->num_channels);
+	data = kzalloc(data_size, GFP_KERNEL);
+	if (!data)
+		return -ENOMEM;
+
+	data->id = cdata->index;
+	data->num_elems = scontrol->num_channels;
+	for (i = 0; i < scontrol->num_channels; i++) {
+		data->chanv[i].channel = cdata->chanv[i].channel;
+		data->chanv[i].value = cdata->chanv[i].value;
+	}
+
+	msg->data_ptr = data;
+	msg->data_size = data_size;
+
+	ret = sof_ipc4_set_get_kcontrol_data(scontrol, true, lock);
+	msg->data_ptr = NULL;
+	msg->data_size = 0;
+	if (ret < 0)
+		dev_err(sdev->dev, "Failed to set control update for %s\n",
+			scontrol->name);
+
+	kfree(data);
+
+	return ret;
+}
+
+static bool sof_ipc4_switch_put(struct snd_sof_control *scontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;
+	struct snd_soc_component *scomp = scontrol->scomp;
+	struct snd_sof_dev *sdev = snd_soc_component_get_drvdata(scomp);
+	struct snd_sof_widget *swidget;
+	bool widget_found = false;
+	bool change = false;
+	unsigned int i;
+	u32 value;
+	int ret;
+
+	/* update each channel */
+	for (i = 0; i < scontrol->num_channels; i++) {
+		value = ucontrol->value.integer.value[i];
+		change = change || (value != cdata->chanv[i].value);
+		cdata->chanv[i].channel = i;
+		cdata->chanv[i].value = value;
+	}
+
+	if (!pm_runtime_active(scomp->dev))
+		return change;
+
+	/* find widget associated with the control */
+	list_for_each_entry(swidget, &sdev->widget_list, list) {
+		if (swidget->comp_id == scontrol->comp_id) {
+			widget_found = true;
+			break;
+		}
+	}
+
+	if (!widget_found) {
+		dev_err(scomp->dev, "Failed to find widget for kcontrol %s\n", scontrol->name);
+		return false;
+	}
+
+	ret = sof_ipc4_set_generic_control_data(sdev, swidget, scontrol, true);
+	if (ret < 0)
+		return false;
+
+	return change;
+}
+
+static int sof_ipc4_switch_get(struct snd_sof_control *scontrol,
+			       struct snd_ctl_elem_value *ucontrol)
+{
+	struct sof_ipc4_control_data *cdata = scontrol->ipc_control_data;
+	unsigned int i;
+
+	/* read back each channel */
+	for (i = 0; i < scontrol->num_channels; i++)
+		ucontrol->value.integer.value[i] = cdata->chanv[i].value;
+
+	return 0;
+}
+
+#endif /* CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX */
+
 static int sof_ipc4_set_get_bytes_data(struct snd_sof_dev *sdev,
 				       struct snd_sof_control *scontrol,
 				       bool set, bool lock)
@@ -438,6 +537,18 @@ static int sof_ipc4_bytes_ext_volatile_g
 	return _sof_ipc4_bytes_ext_get(scontrol, binary_data, size, true);
 }
 
+#ifdef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
+static int
+sof_ipc4_volsw_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget,
+		     struct snd_sof_control *scontrol)
+{
+	if (scontrol->max == 1)
+		return sof_ipc4_set_generic_control_data(sdev, swidget, scontrol, false);
+
+	return sof_ipc4_set_volume_data(sdev, swidget, scontrol, false);
+}
+#endif /* CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX */
+
 /* set up all controls for the widget */
 static int sof_ipc4_widget_kcontrol_setup(struct snd_sof_dev *sdev, struct snd_sof_widget *swidget)
 {
@@ -450,8 +561,12 @@ static int sof_ipc4_widget_kcontrol_setu
 			case SND_SOC_TPLG_CTL_VOLSW:
 			case SND_SOC_TPLG_CTL_VOLSW_SX:
 			case SND_SOC_TPLG_CTL_VOLSW_XR_SX:
+#ifndef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
 				ret = sof_ipc4_set_volume_data(sdev, swidget,
 							       scontrol, false);
+#else
+				ret = sof_ipc4_volsw_setup(sdev, swidget, scontrol);
+#endif
 				break;
 			case SND_SOC_TPLG_CTL_BYTES:
 				ret = sof_ipc4_set_get_bytes_data(sdev, scontrol,
@@ -498,6 +613,10 @@ sof_ipc4_set_up_volume_table(struct snd_
 const struct sof_ipc_tplg_control_ops tplg_ipc4_control_ops = {
 	.volume_put = sof_ipc4_volume_put,
 	.volume_get = sof_ipc4_volume_get,
+#ifdef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
+	.switch_put = sof_ipc4_switch_put,
+	.switch_get = sof_ipc4_switch_get,
+#endif
 	.bytes_put = sof_ipc4_bytes_put,
 	.bytes_get = sof_ipc4_bytes_get,
 	.bytes_ext_put = sof_ipc4_bytes_ext_put,
diff -Naurp a/linux-6.6.38.igel/sound/soc/sof/ipc4-pcm.c b/linux-6.6.38.igel/sound/soc/sof/ipc4-pcm.c
--- a/linux-6.6.38.igel/sound/soc/sof/ipc4-pcm.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/sof/ipc4-pcm.c	2024-08-02 15:41:31.579492158 +0200
@@ -703,10 +703,15 @@ static void sof_ipc4_build_time_info(str
 	info->llp_offset = offsetof(struct sof_ipc4_fw_registers, llp_evad_reading_slot) +
 					sdev->fw_info_box.offset;
 	sof_mailbox_read(sdev, info->llp_offset, &llp_slot, sizeof(llp_slot));
+#ifdef CONFIG_IGEL_METEOR_LAKE_REMOVE_UNWANTED_LOGS
+	if (llp_slot.node_id != dai_copier->data.gtw_cfg.node_id)
+		info->llp_offset = 0;
+#else
 	if (llp_slot.node_id != dai_copier->data.gtw_cfg.node_id) {
 		dev_info(sdev->dev, "no llp found, fall back to default HDA path");
 		info->llp_offset = 0;
 	}
+#endif
 }
 
 static int sof_ipc4_pcm_hw_params(struct snd_soc_component *component,
diff -Naurp a/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.c b/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.c
--- a/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.c	2024-08-02 15:41:31.579492158 +0200
@@ -2121,12 +2121,30 @@ static int sof_ipc4_control_load_volume(
 	msg->primary |= SOF_IPC4_MSG_DIR(SOF_IPC4_MSG_REQUEST);
 	msg->primary |= SOF_IPC4_MSG_TARGET(SOF_IPC4_MODULE_MSG);
 
+#ifndef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
 	msg->extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_GAIN_PARAM_ID);
+#else
+	/* volume controls with range 0-1 (off/on) are switch controls */
+	if (scontrol->max == 1)
+		msg->extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_SWITCH_CONTROL_PARAM_ID);
+	else
+		msg->extension = SOF_IPC4_MOD_EXT_MSG_PARAM_ID(SOF_IPC4_GAIN_PARAM_ID);
+#endif
 
-	/* set default volume values to 0dB in control */
 	for (i = 0; i < scontrol->num_channels; i++) {
 		control_data->chanv[i].channel = i;
+#ifndef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
 		control_data->chanv[i].value = SOF_IPC4_VOL_ZERO_DB;
+#else
+		/*
+		 * Default, initial values:
+		 * - 0dB for volume controls
+		 * - off (0) for switch controls - value already zero after
+		 *				   memory allocation
+		 */
+		if (scontrol->max > 1)
+			control_data->chanv[i].value = SOF_IPC4_VOL_ZERO_DB;
+#endif
 	}
 
 	return 0;
diff -Naurp a/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.h b/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.h
--- a/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/soc/sof/ipc4-topology.h	2024-08-02 15:41:31.579492158 +0200
@@ -319,7 +319,7 @@ struct sof_ipc4_copier {
 /**
  * struct sof_ipc4_ctrl_value_chan: generic channel mapped value data
  * @channel: Channel ID
- * @value: gain value
+ * @value: Value associated with @channel
  */
 struct sof_ipc4_ctrl_value_chan {
 	u32 channel;
@@ -361,6 +361,25 @@ struct sof_ipc4_gain_params {
 	uint32_t curve_duration_h;
 } __packed __aligned(4);
 
+#ifdef CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX
+#define SOF_IPC4_SWITCH_CONTROL_PARAM_ID	200
+#define SOF_IPC4_ENUM_CONTROL_PARAM_ID		201
+
+/**
+ * struct sof_ipc4_control_msg_payload - IPC payload for kcontrol parameters
+ * @id: unique id of the control
+ * @num_elems: Number of elements in the chanv array
+ * @reserved: reserved for future use, must be set to 0
+ * @chanv: channel ID and value array
+ */
+struct sof_ipc4_control_msg_payload {
+	uint16_t id;
+	uint16_t num_elems;
+	uint32_t reserved[4];
+	DECLARE_FLEX_ARRAY(struct sof_ipc4_ctrl_value_chan, chanv);
+} __packed;
+#endif /* CONFIG_IGEL_LENOVO_MTL_MIC_MUTE_LED_FIX */
+
 /**
  * struct sof_ipc4_gain_data - IPC gain init blob
  * @base_config: IPC base config data
diff -Naurp a/linux-6.6.38.igel/sound/sound_core.c b/linux-6.6.38.igel/sound/sound_core.c
--- a/linux-6.6.38.igel/sound/sound_core.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/sound_core.c	2024-08-02 15:41:31.579492158 +0200
@@ -251,7 +251,17 @@ retry:
 	
 	if (r < 0)
 		goto fail;
+#ifdef CONFIG_IGEL_CHANGE_OSS_DEVICE_NAMES
+	/* lang@igel: for the oss devices dsp/audio/mixer we want
+	   a number "0" at the end of the device name, because we create
+	   a device node link dsp -> dsp0 */
+	else if (r < SOUND_STEP &&
+		 strncmp(name, "dsp", 3) != 0 &&
+		 strncmp(name, "audio", 5) != 0 &&
+		 strncmp(name, "mixer", 5) != 0)
+#else
 	else if (r < SOUND_STEP)
+#endif
 		sprintf(s->name, "sound/%s", name);
 	else
 		sprintf(s->name, "sound/%s%d", name, r / SOUND_STEP);
diff -Naurp a/linux-6.6.38.igel/sound/usb/mixer.c b/linux-6.6.38.igel/sound/usb/mixer.c
--- a/linux-6.6.38.igel/sound/usb/mixer.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/usb/mixer.c	2024-08-02 15:41:31.579492158 +0200
@@ -90,6 +90,14 @@ enum {
 	USB_XU_SOFT_LIMIT_SELECTOR = 0x03	/* soft limiter */
 };
 
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS) || defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+/* prototype for get_fu_volume_min_max_range */
+
+static void get_fu_volume_min_max_range(struct usb_mixer_interface *mixer,
+                                  struct usb_mixer_elem_info *cval, int unitid,
+                                  struct snd_kcontrol *kctl);
+#endif
+
 /*
  * manual mapping of mixer names
  * if the mixer topology is too complicated and the parsed names are
@@ -1451,13 +1459,30 @@ static int mixer_ctl_feature_put(struct
 			if (!(cval->cmask & (1 << c)))
 				continue;
 			err = snd_usb_get_cur_mix_value(cval, c + 1, cnt, &oval);
-			if (err < 0)
+			if (err < 0) {
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS) || defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+				usb_audio_dbg(cval->head.mixer->chip,
+						"%s(): failed to get volume value on channel %d\n",
+						__func__, c + 1);
+#endif
 				return filter_error(cval, err);
+			}
 			val = ucontrol->value.integer.value[cnt];
 			val = get_abs_value(cval, val);
 			if (oval != val) {
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS) || defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+				err = snd_usb_set_cur_mix_value(cval, c + 1, cnt, val);
+				if (err) {
+					usb_audio_dbg(cval->head.mixer->chip,
+					      "%s(): failed to change volume value on channel %d\n",
+					    __func__, c + 1);
+				} else {
+					changed = 1;
+				}
+#else
 				snd_usb_set_cur_mix_value(cval, c + 1, cnt, val);
 				changed = 1;
+#endif
 			}
 			cnt++;
 		}
@@ -1729,6 +1754,15 @@ static void __build_feature_ctl(struct u
 		len = snd_usb_copy_string_desc(mixer->chip, nameid,
 				kctl->id.name, sizeof(kctl->id.name));
 
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS)
+	/* hamburg@igel.com fixed Sennheiser DW Pro2 headset: renamed control
+	 * elements in FEATURE_UNIT of sidetone chain */
+
+	if (!len) {
+		len = snd_usb_mixer_control_name_apply_quirk(mixer, unitid, kctl);
+	}
+#endif
+
 	switch (control) {
 	case UAC_FU_MUTE:
 	case UAC_FU_VOLUME:
@@ -1779,7 +1813,14 @@ static void __build_feature_ctl(struct u
 	}
 
 	/* get min/max values */
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS) || defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+	get_fu_volume_min_max_range(mixer, cval, unitid, kctl);
+	if (!cval->initialized) {
+		get_min_max_with_quirks(cval, 0, kctl);
+	}
+#else
 	get_min_max_with_quirks(cval, 0, kctl);
+#endif
 
 	/* skip a bogus volume range */
 	if (cval->max <= cval->min) {
@@ -1825,6 +1866,91 @@ static void __build_feature_ctl(struct u
 	snd_usb_mixer_add_control(&cval->head, kctl);
 }
 
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS) || defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+static int get_fu_control_min_max_res(struct usb_mixer_elem_info *cval)
+{
+	int i;
+	int minchn = 0;
+
+	if (cval->cmask) {
+		for (i = 0; i < MAX_CHANNELS; i++)
+			if (cval->cmask & (1 << i)) {
+				minchn = i + 1;
+				break;
+			}
+	}
+	if (get_ctl_value(cval, UAC_GET_MAX, (cval->control << 8) | minchn, &cval->max) < 0 ||
+			get_ctl_value(cval, UAC_GET_MIN, (cval->control << 8) | minchn, &cval->min) < 0) {
+		usb_audio_err(cval->head.mixer->chip,
+				"%d:%d: cannot get min/max values for control %d (id %d)\n",
+				cval->head.id, snd_usb_ctrl_intf(cval->head.mixer->chip),
+				cval->control, cval->head.id);
+		return -EINVAL;
+	}
+	if (get_ctl_value(cval, UAC_GET_RES,
+				(cval->control << 8) | minchn,
+				&cval->res) < 0) {
+		cval->res = 1;
+	}
+	if (cval->res == 0) {
+		cval->res = 1;
+	}
+
+	/* USB descriptions contain the dB scale in 1/256 dB unit
+	 * while ALSA TLV contains in 1/100 dB unit
+	 */
+	cval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;
+	cval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;
+
+	return 0;
+}
+
+static void get_fu_volume_min_max_range(struct usb_mixer_interface *mixer,
+				  struct usb_mixer_elem_info *cval, int unitid,
+				  struct snd_kcontrol *kctl)
+{
+	int err;
+
+	if (cval->control != UAC_FU_VOLUME) {
+		return;
+	}
+	if (cval->val_type == USB_MIXER_BOOLEAN ||
+		cval->val_type == USB_MIXER_INV_BOOLEAN) {
+		cval->initialized = 1;
+		return;
+	}
+
+	switch (USB_ID_VENDOR(mixer->chip->usb_id)) {
+#if defined(CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS)
+	case 0x1395: /* Sennheiser */
+		if (0x0037 == USB_ID_PRODUCT(mixer->chip->usb_id) && 11 == unitid) {
+			/* FU sidetone on SC660 */
+			cval->res = 512;
+			cval->min = 0;
+			cval->max = 4096;
+			cval->dBmin = (convert_signed_value(cval, cval->min) * 100) / 256;
+			cval->dBmax = (convert_signed_value(cval, cval->max) * 100) / 256;
+			cval->initialized = 1;
+		} else {
+			err = get_fu_control_min_max_res(cval);
+			if (!err) {
+				cval->initialized = 1;
+			}
+		}
+		break;
+#endif
+#if defined(CONFIG_IGEL_USB_SOUND_PLANTRONICS_QUIRKS)
+	case 0x047f: /* Plantronics */
+		err = get_fu_control_min_max_res(cval);
+		if (!err) {
+			cval->initialized = 1;
+		}
+		break;
+#endif
+	}
+}
+#endif
+
 static void build_feature_ctl(struct mixer_build *state, void *raw_desc,
 			      unsigned int ctl_mask, int control,
 			      struct usb_audio_term *iterm, int unitid,
diff -Naurp a/linux-6.6.38.igel/sound/usb/mixer_quirks.c b/linux-6.6.38.igel/sound/usb/mixer_quirks.c
--- a/linux-6.6.38.igel/sound/usb/mixer_quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/usb/mixer_quirks.c	2024-08-02 15:41:31.579492158 +0200
@@ -3591,3 +3591,25 @@ void snd_usb_mixer_fu_apply_quirk(struct
 	}
 }
 
+#ifdef CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS
+/* hamburg@igel.com fixed Sennheiser DW Pro2 headset: renamed control
+ * elements in FEATURE_UNIT of sidetone chain */
+
+size_t snd_usb_mixer_control_name_apply_quirk(struct usb_mixer_interface *mixer,
+		int unitid, struct snd_kcontrol *kctl)
+{
+	size_t len;
+
+	len = 0;
+
+	switch (mixer->chip->usb_id) {
+	case USB_ID(0x1395, 0x740a): /* Sennheiser DW Pro2 */
+		if (unitid == 6) {
+			len = strlcpy(kctl->id.name, "Sidetone", sizeof(kctl->id.name));
+		}
+		break;
+	}
+
+	return (len);
+}
+#endif
diff -Naurp a/linux-6.6.38.igel/sound/usb/mixer_quirks.h b/linux-6.6.38.igel/sound/usb/mixer_quirks.h
--- a/linux-6.6.38.igel/sound/usb/mixer_quirks.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/usb/mixer_quirks.h	2024-08-02 15:41:31.579492158 +0200
@@ -16,5 +16,11 @@ void snd_usb_mixer_fu_apply_quirk(struct
 
 void snd_usb_mixer_resume_quirk(struct usb_mixer_interface *mixer);
 
+#ifdef CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS
+/* hamburg@igel.com fixed Sennheiser DW Pro2 headset: renamed control
+ * elements in FEATURE_UNIT of sidetone chain */
+size_t snd_usb_mixer_control_name_apply_quirk(struct usb_mixer_interface *mixer,
+		int unitid, struct snd_kcontrol *kctl);
+#endif
 #endif /* SND_USB_MIXER_QUIRKS_H */
 
diff -Naurp a/linux-6.6.38.igel/sound/usb/quirks.c b/linux-6.6.38.igel/sound/usb/quirks.c
--- a/linux-6.6.38.igel/sound/usb/quirks.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/sound/usb/quirks.c	2024-08-02 15:41:31.579492158 +0200
@@ -1837,6 +1837,17 @@ void snd_usb_ctl_msg_quirk(struct usb_de
 	if (!chip || (requesttype & USB_TYPE_MASK) != USB_TYPE_CLASS)
 		return;
 
+#ifdef CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS
+	/* Sennheiser headsets need a delay */
+	if (USB_ID_VENDOR(chip->usb_id) == 0x1395) {
+		if (UAC_SET_CUR == request) {
+			msleep(50);
+		} else {
+			msleep(20);
+		}
+	}
+#endif
+
 	if (chip->quirk_flags & QUIRK_FLAG_CTL_MSG_DELAY)
 		msleep(20);
 	else if (chip->quirk_flags & QUIRK_FLAG_CTL_MSG_DELAY_1M)
@@ -2025,6 +2036,20 @@ static const struct usb_audio_quirk_flag
 		   QUIRK_FLAG_DISABLE_AUTOSUSPEND),
 	DEVICE_FLG(0x046d, 0x084c, /* Logitech ConferenceCam Connect */
 		   QUIRK_FLAG_GET_SAMPLE_RATE | QUIRK_FLAG_CTL_MSG_DELAY_1M),
+#ifdef CONFIG_IGEL_USB_SOUND_SENNHEISER_QUIRKS
+	DEVICE_FLG(0x1395, 0x0036, /* Sennheiser SC630 */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+	DEVICE_FLG(0x1395, 0x0037, /* Sennheiser SC660 */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+	DEVICE_FLG(0x1395, 0x0050, /* Sennheiser SC260 */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+	DEVICE_FLG(0x1395, 0x005a, /* Sennheiser SC60 */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+	DEVICE_FLG(0x1395, 0x0060, /* Sennheiser SC45/S */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+	DEVICE_FLG(0x1395, 0x002d, /* Sennheiser BTD800 */
+		   QUIRK_FLAG_GET_SAMPLE_RATE),
+#endif
 	DEVICE_FLG(0x046d, 0x0991, /* Logitech QuickCam Pro */
 		   QUIRK_FLAG_CTL_MSG_DELAY_1M | QUIRK_FLAG_IGNORE_CTL_ERROR),
 	DEVICE_FLG(0x046d, 0x09a4, /* Logitech QuickCam E 3500 */
diff -Naurp a/linux-6.6.38.igel/tools/power/cpupower/Makefile b/linux-6.6.38.igel/tools/power/cpupower/Makefile
--- a/linux-6.6.38.igel/tools/power/cpupower/Makefile	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/tools/power/cpupower/Makefile	2024-08-02 15:41:31.579492158 +0200
@@ -217,12 +217,13 @@ $(OUTPUT)%.o: %.c
 	$(ECHO) "  CC      " $@
 	$(QUIET) $(CC) $(CFLAGS) -I./lib -I ./utils -o $@ -c $*.c
 
+# IGEL added -lz for build with musl
 $(OUTPUT)cpupower: $(UTIL_OBJS) $(OUTPUT)libcpupower.so.$(LIB_MAJ)
 	$(ECHO) "  CC      " $@
 ifeq ($(strip $(STATIC)),true)
-	$(QUIET) $(CC) $(CFLAGS) $(LDFLAGS) $(UTIL_OBJS) -lrt -lpci -L$(OUTPUT) -o $@
+	$(QUIET) $(CC) $(CFLAGS) $(LDFLAGS) $(UTIL_OBJS) -lrt -lpci -lz -L$(OUTPUT) -o $@
 else
-	$(QUIET) $(CC) $(CFLAGS) $(LDFLAGS) $(UTIL_OBJS) -lcpupower -lrt -lpci -L$(OUTPUT) -o $@
+	$(QUIET) $(CC) $(CFLAGS) $(LDFLAGS) $(UTIL_OBJS) -lcpupower -lrt -lpci -lz -L$(OUTPUT) -o $@
 endif
 	$(QUIET) $(STRIPCMD) $@
 
diff -Naurp a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-config.c b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-config.c
--- a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-config.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-config.c	2024-08-02 15:41:31.579492158 +0200
@@ -4,11 +4,15 @@
  * Copyright (c) 2019 Intel Corporation.
  */
 
-#include <linux/isst_if.h>
-#include <sys/utsname.h>
-
+/* CONFIG_IGEL_WORKAROUND
+ * Makefile script fails and isst_if.h symbolic link is not created
+ * instead the reference to header file is in isst.h
+ * #include <linux/isst_if.h>
+ */
 #include "isst.h"
 
+#include <sys/utsname.h>
+
 struct process_cmd_struct {
 	char *feature;
 	char *command;
diff -Naurp a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-core-tpmi.c b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-core-tpmi.c
--- a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-core-tpmi.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst-core-tpmi.c	2024-08-02 15:41:31.579492158 +0200
@@ -4,7 +4,12 @@
  * Copyright (c) 2022 Intel Corporation.
  */
 
-#include <linux/isst_if.h>
+/* CONFIG_IGEL_WORKAROUND
+ * Makefile script fails and isst_if.h symbolic link is not created
+ * instead the reference to header file is in isst.h
+ * #include <linux/isst_if.h>
+ */
+
 #include "isst.h"
 
 int tpmi_process_ioctl(int ioctl_no, void *info)
diff -Naurp a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst.h b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst.h
--- a/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst.h	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/tools/power/x86/intel-speed-select/isst.h	2024-08-02 15:41:31.579492158 +0200
@@ -28,7 +28,13 @@
 #include <stdarg.h>
 #include <sys/ioctl.h>
 
-#include <linux/isst_if.h>
+/* CONFIG_IGEL_WORKAROUND start
+ * Makefile script fails and isst_if.h symbolic link is not created
+ * #include <linux/isst_if.h>
+ * instead use the real path to header file below
+ */
+#include "../../../../include/uapi/linux/isst_if.h"
+/* CONFIG_IGEL_WORKAROUND end */
 
 #define BIT(x) (1 << (x))
 #define BIT_ULL(nr) (1ULL << (nr))
diff -Naurp a/linux-6.6.38.igel/tools/power/x86/turbostat/turbostat.c b/linux-6.6.38.igel/tools/power/x86/turbostat/turbostat.c
--- a/linux-6.6.38.igel/tools/power/x86/turbostat/turbostat.c	2024-07-09 11:44:29.000000000 +0200
+++ b/linux-6.6.38.igel/tools/power/x86/turbostat/turbostat.c	2024-08-02 15:41:31.579492158 +0200
@@ -36,6 +36,8 @@
 #include <linux/perf_event.h>
 #include <asm/unistd.h>
 #include <stdbool.h>
+/* IGEL for build with gcc-musl */
+#include <linux/limits.h>
 
 #define UNUSED(x) (void)(x)
 
